<!DOCTYPE html> <html><head>
		<title>8. Threads and Concurrency</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 8. Threads and Concurrency">
		<meta property="og:title" content="8. Threads and Concurrency">
		<meta property="og:description" content="Congzhi's Notes Vault - 8. Threads and Concurrency">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/8.-threads-and-concurrency.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/pasted-image-20241203220443.jpg">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c1D45A.TEX-I::before { padding: 0.442em 0.878em 0.011em 0px; content: "m"; }
mjx-c.mjx-c1D45F.TEX-I::before { padding: 0.442em 0.451em 0.011em 0px; content: "r"; }
mjx-c.mjx-c1D460.TEX-I::before { padding: 0.442em 0.469em 0.01em 0px; content: "s"; }
mjx-c.mjx-c1D436.TEX-I::before { padding: 0.705em 0.76em 0.022em 0px; content: "C"; }
mjx-c.mjx-c1D457.TEX-I::before { padding: 0.661em 0.412em 0.204em 0px; content: "j"; }
mjx-c.mjx-c1D456.TEX-I::before { padding: 0.661em 0.345em 0.011em 0px; content: "i"; }
mjx-c.mjx-c1D435.TEX-I::before { padding: 0.683em 0.759em 0px 0px; content: "B"; }
mjx-c.mjx-c1D441.TEX-I::before { padding: 0.683em 0.888em 0px 0px; content: "N"; }
mjx-mtext { display: inline-block; text-align: left; }
mjx-c.mjx-c44::before { padding: 0.683em 0.764em 0px 0px; content: "D"; }
mjx-c.mjx-c65::before { padding: 0.448em 0.444em 0.011em 0px; content: "e"; }
mjx-c.mjx-c61::before { padding: 0.448em 0.5em 0.011em 0px; content: "a"; }
mjx-c.mjx-c64::before { padding: 0.694em 0.556em 0.011em 0px; content: "d"; }
mjx-c.mjx-c6C::before { padding: 0.694em 0.278em 0px 0px; content: "l"; }
mjx-c.mjx-c69::before { padding: 0.669em 0.278em 0px 0px; content: "i"; }
mjx-c.mjx-c6E::before { padding: 0.442em 0.556em 0px 0px; content: "n"; }
mjx-c.mjx-c20::before { padding: 0px 0.25em 0px 0px; content: " "; }
mjx-c.mjx-c54::before { padding: 0.677em 0.722em 0px 0px; content: "T"; }
mjx-c.mjx-c6D::before { padding: 0.442em 0.833em 0px 0px; content: "m"; }
mjx-c.mjx-c2D::before { padding: 0.252em 0.333em 0px 0px; content: "-"; }
mjx-c.mjx-c43::before { padding: 0.705em 0.722em 0.021em 0px; content: "C"; }
mjx-c.mjx-c75::before { padding: 0.442em 0.556em 0.011em 0px; content: "u"; }
mjx-c.mjx-c72::before { padding: 0.442em 0.392em 0px 0px; content: "r"; }
mjx-c.mjx-c74::before { padding: 0.615em 0.389em 0.01em 0px; content: "t"; }
mjx-c.mjx-c53::before { padding: 0.705em 0.556em 0.022em 0px; content: "S"; }
mjx-c.mjx-c63::before { padding: 0.448em 0.444em 0.011em 0px; content: "c"; }
mjx-c.mjx-c6B::before { padding: 0.694em 0.528em 0px 0px; content: "k"; }
mjx-c.mjx-c52::before { padding: 0.683em 0.736em 0.022em 0px; content: "R"; }
mjx-c.mjx-c67::before { padding: 0.453em 0.5em 0.206em 0px; content: "g"; }
mjx-c.mjx-c45::before { padding: 0.68em 0.681em 0px 0px; content: "E"; }
mjx-c.mjx-c78::before { padding: 0.431em 0.528em 0px 0px; content: "x"; }
mjx-c.mjx-c6F::before { padding: 0.448em 0.5em 0.01em 0px; content: "o"; }
mjx-c.mjx-c2C::before { padding: 0.121em 0.278em 0.194em 0px; content: ","; }
mjx-c.mjx-c34::before { padding: 0.677em 0.5em 0px 0px; content: "4"; }
mjx-c.mjx-c37::before { padding: 0.676em 0.5em 0.022em 0px; content: "7"; }
mjx-c.mjx-c30::before { padding: 0.666em 0.5em 0.022em 0px; content: "0"; }
mjx-c.mjx-c220F.TEX-S2::before { padding: 0.95em 1.278em 0.45em 0px; content: "∏"; }
mjx-c.mjx-c1D447.TEX-I::before { padding: 0.677em 0.704em 0px 0px; content: "T"; }
mjx-c.mjx-c2264::before { padding: 0.636em 0.778em 0.138em 0px; content: "≤"; }
mjx-munderover { display: inline-block; text-align: left; }
mjx-munderover:not([limits="false"]) { padding-top: 0.1em; }
mjx-munderover:not([limits="false"]) > * { display: block; }
mjx-msubsup { display: inline-block; text-align: left; }
mjx-script { display: inline-block; padding-right: 0.05em; padding-left: 0.033em; }
mjx-script > mjx-spacer { display: block; }
mjx-c.mjx-c1D70F.TEX-I::before { padding: 0.431em 0.517em 0.013em 0px; content: "τ"; }
mjx-c.mjx-c1D458.TEX-I::before { padding: 0.694em 0.521em 0.011em 0px; content: "k"; }
mjx-c.mjx-c1D450.TEX-I::before { padding: 0.442em 0.433em 0.011em 0px; content: "c"; }
mjx-c.mjx-c1D448.TEX-I::before { padding: 0.683em 0.767em 0.022em 0px; content: "U"; }
mjx-c.mjx-c2211.TEX-S2::before { padding: 0.95em 1.444em 0.45em 0px; content: "∑"; }
mjx-c.mjx-c3C::before { padding: 0.54em 0.778em 0.04em 0px; content: "<"; }
mjx-container[jax="CHTML"] { line-height: 0; }
mjx-container [space="1"] { margin-left: 0.111em; }
mjx-container [space="2"] { margin-left: 0.167em; }
mjx-container [space="3"] { margin-left: 0.222em; }
mjx-container [space="4"] { margin-left: 0.278em; }
mjx-container [space="5"] { margin-left: 0.333em; }
mjx-container [rspace="1"] { margin-right: 0.111em; }
mjx-container [rspace="2"] { margin-right: 0.167em; }
mjx-container [rspace="3"] { margin-right: 0.222em; }
mjx-container [rspace="4"] { margin-right: 0.278em; }
mjx-container [rspace="5"] { margin-right: 0.333em; }
mjx-container [size="s"] { font-size: 70.7%; }
mjx-container [size="ss"] { font-size: 50%; }
mjx-container [size="Tn"] { font-size: 60%; }
mjx-container [size="sm"] { font-size: 85%; }
mjx-container [size="lg"] { font-size: 120%; }
mjx-container [size="Lg"] { font-size: 144%; }
mjx-container [size="LG"] { font-size: 173%; }
mjx-container [size="hg"] { font-size: 207%; }
mjx-container [size="HG"] { font-size: 249%; }
mjx-container [width="full"] { width: 100%; }
mjx-box { display: inline-block; }
mjx-block { display: block; }
mjx-itable { display: inline-table; }
mjx-row { display: table-row; }
mjx-row > * { display: table-cell; }
mjx-mtext { display: inline-block; }
mjx-mstyle { display: inline-block; }
mjx-merror { display: inline-block; color: red; background-color: yellow; }
mjx-mphantom { visibility: hidden; }
mjx-assistive-mml { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; padding: 1px 0px 0px !important; border: 0px !important; display: block !important; width: auto !important; overflow: hidden !important; }
mjx-assistive-mml[display="block"] { width: 100% !important; }
mjx-math { display: inline-block; text-align: left; line-height: 0; text-indent: 0px; font-style: normal; font-weight: normal; font-size: 100%; letter-spacing: normal; border-collapse: collapse; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; direction: ltr; padding: 1px 0px; }
mjx-container[jax="CHTML"][display="true"] { display: block; text-align: center; margin: 1em 0px; }
mjx-container[jax="CHTML"][display="true"][width="full"] { display: flex; }
mjx-container[jax="CHTML"][display="true"] mjx-math { padding: 0px; }
mjx-container[jax="CHTML"][justify="left"] { text-align: left; }
mjx-container[jax="CHTML"][justify="right"] { text-align: right; }
mjx-mi { display: inline-block; text-align: left; }
mjx-c { display: inline-block; }
mjx-utext { display: inline-block; padding: 0.75em 0px 0.2em; }
mjx-mo { display: inline-block; text-align: left; }
mjx-stretchy-h { display: inline-table; width: 100%; }
mjx-stretchy-h > * { display: table-cell; width: 0px; }
mjx-stretchy-h > * > mjx-c { display: inline-block; transform: scaleX(1); }
mjx-stretchy-h > * > mjx-c::before { display: inline-block; width: initial; }
mjx-stretchy-h > mjx-ext { overflow: clip visible; width: 100%; }
mjx-stretchy-h > mjx-ext > mjx-c::before { transform: scaleX(500); }
mjx-stretchy-h > mjx-ext > mjx-c { width: 0px; }
mjx-stretchy-h > mjx-beg > mjx-c { margin-right: -0.1em; }
mjx-stretchy-h > mjx-end > mjx-c { margin-left: -0.1em; }
mjx-stretchy-v { display: inline-block; }
mjx-stretchy-v > * { display: block; }
mjx-stretchy-v > mjx-beg { height: 0px; }
mjx-stretchy-v > mjx-end > mjx-c { display: block; }
mjx-stretchy-v > * > mjx-c { transform: scaleY(1); transform-origin: left center; overflow: hidden; }
mjx-stretchy-v > mjx-ext { display: block; height: 100%; box-sizing: border-box; border: 0px solid transparent; overflow: visible clip; }
mjx-stretchy-v > mjx-ext > mjx-c::before { width: initial; box-sizing: border-box; }
mjx-stretchy-v > mjx-ext > mjx-c { transform: scaleY(500) translateY(0.075em); overflow: visible; }
mjx-mark { display: inline-block; height: 0px; }
mjx-mfrac { display: inline-block; text-align: left; }
mjx-frac { display: inline-block; vertical-align: 0.17em; padding: 0px 0.22em; }
mjx-frac[type="d"] { vertical-align: 0.04em; }
mjx-frac[delims] { padding: 0px 0.1em; }
mjx-frac[atop] { padding: 0px 0.12em; }
mjx-frac[atop][delims] { padding: 0px; }
mjx-dtable { display: inline-table; width: 100%; }
mjx-dtable > * { font-size: 2000%; }
mjx-dbox { display: block; font-size: 5%; }
mjx-num { display: block; text-align: center; }
mjx-den { display: block; text-align: center; }
mjx-mfrac[bevelled] > mjx-num { display: inline-block; }
mjx-mfrac[bevelled] > mjx-den { display: inline-block; }
mjx-den[align="right"], mjx-num[align="right"] { text-align: right; }
mjx-den[align="left"], mjx-num[align="left"] { text-align: left; }
mjx-nstrut { display: inline-block; height: 0.054em; width: 0px; vertical-align: -0.054em; }
mjx-nstrut[type="d"] { height: 0.217em; vertical-align: -0.217em; }
mjx-dstrut { display: inline-block; height: 0.505em; width: 0px; }
mjx-dstrut[type="d"] { height: 0.726em; }
mjx-line { display: block; box-sizing: border-box; min-height: 1px; height: 0.06em; border-top: 0.06em solid; margin: 0.06em -0.1em; overflow: hidden; }
mjx-line[type="d"] { margin: 0.18em -0.1em; }
mjx-mrow { display: inline-block; text-align: left; }
mjx-mn { display: inline-block; text-align: left; }
mjx-msub { display: inline-block; text-align: left; }
mjx-texatom { display: inline-block; text-align: left; }
mjx-c::before { display: block; width: 0px; }
.MJX-TEX { font-family: MJXZERO, MJXTEX; }
.TEX-B { font-family: MJXZERO, MJXTEX-B; }
.TEX-I { font-family: MJXZERO, MJXTEX-I; }
.TEX-MI { font-family: MJXZERO, MJXTEX-MI; }
.TEX-BI { font-family: MJXZERO, MJXTEX-BI; }
.TEX-S1 { font-family: MJXZERO, MJXTEX-S1; }
.TEX-S2 { font-family: MJXZERO, MJXTEX-S2; }
.TEX-S3 { font-family: MJXZERO, MJXTEX-S3; }
.TEX-S4 { font-family: MJXZERO, MJXTEX-S4; }
.TEX-A { font-family: MJXZERO, MJXTEX-A; }
.TEX-C { font-family: MJXZERO, MJXTEX-C; }
.TEX-CB { font-family: MJXZERO, MJXTEX-CB; }
.TEX-FR { font-family: MJXZERO, MJXTEX-FR; }
.TEX-FRB { font-family: MJXZERO, MJXTEX-FRB; }
.TEX-SS { font-family: MJXZERO, MJXTEX-SS; }
.TEX-SSB { font-family: MJXZERO, MJXTEX-SSB; }
.TEX-SSI { font-family: MJXZERO, MJXTEX-SSI; }
.TEX-SC { font-family: MJXZERO, MJXTEX-SC; }
.TEX-T { font-family: MJXZERO, MJXTEX-T; }
.TEX-V { font-family: MJXZERO, MJXTEX-V; }
.TEX-VB { font-family: MJXZERO, MJXTEX-VB; }
mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c { font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A !important; }
@font-face { font-family: MJXZERO; src: url("lib/fonts/mathjax_zero.woff") format("woff"); }
@font-face { font-family: MJXTEX; src: url("lib/fonts/mathjax_main-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-B; src: url("lib/fonts/mathjax_main-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-I; src: url("lib/fonts/mathjax_math-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-MI; src: url("lib/fonts/mathjax_main-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-BI; src: url("lib/fonts/mathjax_math-bolditalic.woff") format("woff"); }
@font-face { font-family: MJXTEX-S1; src: url("lib/fonts/mathjax_size1-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S2; src: url("lib/fonts/mathjax_size2-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S3; src: url("lib/fonts/mathjax_size3-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S4; src: url("lib/fonts/mathjax_size4-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-A; src: url("lib/fonts/mathjax_ams-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-C; src: url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-CB; src: url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-FR; src: url("lib/fonts/mathjax_fraktur-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-FRB; src: url("lib/fonts/mathjax_fraktur-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SS; src: url("lib/fonts/mathjax_sansserif-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSB; src: url("lib/fonts/mathjax_sansserif-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSI; src: url("lib/fonts/mathjax_sansserif-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-SC; src: url("lib/fonts/mathjax_script-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-T; src: url("lib/fonts/mathjax_typewriter-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-V; src: url("lib/fonts/mathjax_vector-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-VB; src: url("lib/fonts/mathjax_vector-bold.woff") format("woff"); }
mjx-c.mjx-c1D445.TEX-I::before { padding: 0.683em 0.759em 0.021em 0px; content: "R"; }
mjx-c.mjx-c3D::before { padding: 0.583em 0.778em 0.082em 0px; content: "="; }
mjx-c.mjx-c28::before { padding: 0.75em 0.389em 0.25em 0px; content: "("; }
mjx-c.mjx-c1D44A.TEX-I::before { padding: 0.683em 1.048em 0.022em 0px; content: "W"; }
mjx-c.mjx-c2B::before { padding: 0.583em 0.778em 0.082em 0px; content: "+"; }
mjx-c.mjx-c1D446.TEX-I::before { padding: 0.705em 0.645em 0.022em 0px; content: "S"; }
mjx-c.mjx-c29::before { padding: 0.75em 0.389em 0.25em 0px; content: ")"; }
mjx-c.mjx-c31::before { padding: 0.666em 0.5em 0px 0px; content: "1"; }
mjx-c.mjx-c1D444.TEX-I::before { padding: 0.704em 0.791em 0.194em 0px; content: "Q"; }
mjx-c.mjx-c3E::before { padding: 0.54em 0.778em 0.04em 0px; content: ">"; }
mjx-c.mjx-c32::before { padding: 0.666em 0.5em 0px 0px; content: "2"; }
mjx-c.mjx-c2E::before { padding: 0.12em 0.278em 0px 0px; content: "."; }
mjx-c.mjx-c1D45B.TEX-I::before { padding: 0.442em 0.6em 0.011em 0px; content: "n"; }
mjx-c.mjx-c2212::before { padding: 0.583em 0.778em 0.082em 0px; content: "−"; }
mjx-c.mjx-c1D443.TEX-I::before { padding: 0.683em 0.751em 0px 0px; content: "P"; }
mjx-c.mjx-c33::before { padding: 0.665em 0.5em 0.022em 0px; content: "3"; }
</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="8. Threads and Concurrency"><ol start="8">
<li dir="auto">Threads and Concurrency</li>
</ol></h1><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner">第一遍重写中</div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第一课 Thread of Execution" dir="auto" class="heading" id="第一课_Thread_of_Execution"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课 Thread of Execution</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-blockquote"><blockquote dir="auto">
<p>Thread is short for thread of execution.</p>
</blockquote></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Concurrency and Processes" dir="auto" class="heading" id="1.1_Concurrency_and_Processes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Concurrency and Processes</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们已经了解过了进程的概念，也简单地了解过了什么是并发。当前，消费级的 CPU 大多都是多核心的，在某一时刻，我们可以有 CPU 核心数个进程<strong>同时</strong>运行在 CPU 上。而在单核 CPU 的时代，我们只能通过系统分时在机器上模拟多个进程“同时”运行。我们再来回温一下什么是分时和并发。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 Concurrency: Time Sharing" dir="auto" class="heading" id="1.1.1_Concurrency:_Time_Sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 Concurrency: Time Sharing</h4><div class="heading-children"><div class="el-p"><p dir="auto">要实现并发，系统就需要是分时的。分时就是系统将CPU时间分为一段一段的CPU时间片。通过快速的切换任务，当时间片越来越小时，在宏观上用户和程序就会就会感觉像是独占了CPU。在时间片小到人类不能察觉时，程序就在<strong>微观上交替执行，宏观上”同时“执行</strong>了，这就是<strong>并发</strong>。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241203220443.jpg" src="Pasted image 20241203220443.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241203220443.jpg" src="congzhi's-os-series/pics/pasted-image-20241203220443.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 Parallelism" dir="auto" class="heading" id="1.1.2_Parallelism"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 Parallelism</h4><div class="heading-children"><div class="el-p"><p dir="auto">提到了并发，与之对应地，我们往往会想到并行的概念。并行我们很好理解，同时地做很多件事。初学时我常会将这两个概念搞混，因为在宏观上，它们提供的效果太类似了。但只要把视角转向微观，我们就会明白它们的不同。</p></div><div class="el-p"><p dir="auto">并发是”同时“做多件事，但并行是同时做多件事。他们在宏观上好似都拥有<strong>同时</strong>，但在微观上只有并行是同时做的。并发关注结构，而并行关注执行，并发提供了解决问题的结构方法，可能支持并行化（多核），但也不必然（单核）。</p></div><div class="el-p"><p dir="auto"><span alt="threads_parallelism_concurrency.jpg" src="threads_parallelism_concurrency.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="threads_parallelism_concurrency.jpg" src="congzhi's-os-series/pics/threads_parallelism_concurrency.jpg"></span></p></div><div class="el-p"><p dir="auto">在上面的图示中，展示了两个核心上四个线程（你可以看成是进程）的并行并发执行。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.3 Concurrency Unleashed: Redefining Multi-tasking" dir="auto" class="heading" id="1.1.3_Concurrency_Unleashed:_Redefining_Multi-tasking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 Concurrency Unleashed: Redefining Multi-tasking</h4><div class="heading-children"><div class="el-p"><p dir="auto">并发为我们带来许多优点，我们现在可以在单处理器上允许多个程序，实现微观上虽然是交替执行，但宏观上”并行“执行的特点。这种特性提升了CPU的利用率，从而带给我们更好的性能表现。</p></div><div class="el-p"><p dir="auto">缺点同样显而易见，调度器需要瞻前顾后，增加了系统调度的复杂性，多个进程可能会相互作用，互相争夺资源，所以避免并发线程导致 inconsistent states 是我们需要关心的一大问题。除此之外，频繁调度所产生的上下文切换开销也是我们要关心的。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.2 Thread Motivations" dir="auto" class="heading" id="1.2_Thread_Motivations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 Thread Motivations</h3><div class="heading-children"><div class="el-p"><p dir="auto">假如我们有一个 HTTP 服务器，在没有线程的时候，每一个客户端的连接都将对应一个进程的创建。在高并发的场景下，每秒都可能有成百上千个客户端需要与服务器建立连接。在 HTTP 服务器上，可能出现频繁地创建、切换和销毁进程，这样带来的开销可能是服务器不可承受之重。更何况进程间通信也会为系统带来不小的开销。</p></div><div class="el-p"><p dir="auto">那么，我们是否有更好地方法来降低系统开销，实现一种机制来避免进程操作给我们带来的系统开销呢？在剖析进程时，我们发现进程中有很多部件，而执行程序是在栈区中执行的。为了减少进程操作开销，人们将进程中负责执行程序的部分独立出来称为线程，而进程仅作为资源管理的单位为提供线程其所需要的资源。</p></div><div class="el-p"><p dir="auto">从而，我们可以在服务器进程中，用多线程的方式同时服务多个客户端，减少了进程开销。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204003952.jpg" src="Pasted image 20241204003952.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204003952.jpg" src="congzhi's-os-series/pics/pasted-image-20241204003952.jpg"></span></p></div><div class="el-p"><p dir="auto">线程是<strong>执行线程</strong>的简写，它是一系列顺序任务流，这些任务流可被CPU调度。由于线程的调度和操作相比进程系统开销要小很多，所以现在的操作系统使用线程作为CPU调度的基本单位，即线程是最小的可调度单位。而进程，作为资源管理的基本单位，可以被看作是线程的容器。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.3 Thread Possessions" dir="auto" class="heading" id="1.3_Thread_Possessions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 Thread Possessions</h3><div class="heading-children"><div class="el-p"><p dir="auto">为了让这个最小的可调度单位能够正常的工作，我们需要给线程分配必要的资源。每个线程都需要独立的 <strong>TCB</strong> ，包括<strong>寄存器组</strong>、<strong>PC寄存器</strong>和<strong>堆栈指针</strong>等。此外，还需要给每个线程分配<strong>栈空间</strong>以确保能够调度执行。这些线程会共享同一个进程中的<strong>代码段</strong>、<strong>数据段</strong>和<strong>文件</strong>等资源。由于线程的轻量，我们也称其为<strong>轻量级进程(Light-weight process)</strong>，这样的轻量型为减少系统开销帮了不少忙。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241203215622.jpg" src="Pasted image 20241203215622.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241203215622.jpg" src="congzhi's-os-series/pics/pasted-image-20241203215622.jpg"></span></p></div><div class="el-p"><p dir="auto">由于线程所占用的资源很少，所以创建和销毁线程要比进程快得多（10×），而且上下文切换的时间也更快。又因为所有线程共享进程的资源，所以同一进程中线程间交流并不需要IPC。要使程序运行起来，一个进程就至少需要有一个线程，叫做主线程(main thread)。</p></div><div class="el-p"><p dir="auto">此外，线程间共享进程资源还为我们带来另一个好处——高缓存命中率（关于缓存亲和性的内容将在<a data-tooltip-position="top" aria-label="9. CPU Scheduling > 第三课 Multiple-Processor Scheduling" data-href="9. CPU Scheduling#第三课 Multiple-Processor Scheduling" href="congzhi's-os-series/9.-cpu-scheduling.html#第三课_Multiple-Processor_Scheduling" class="internal-link" target="_self" rel="noopener nofollow">CPU调度</a>阶段中学习到）。由于线程的轻量型，线程切换通常不需要将一些上下文重新加载到缓存中，所以缓存命中率高。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.4 TCB and Thread States" dir="auto" class="heading" id="1.4_TCB_and_Thread_States"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4 TCB and Thread States</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.1 Thread Control Block" dir="auto" class="heading" id="1.4.1_Thread_Control_Block"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.1 Thread Control Block</h4><div class="heading-children"><div class="el-p"><p dir="auto">线程和进程一样有各种各样的状态，操作系统为了对线程进行管理和调度，在线程创建的时候会为线程创建一个TCB来存放线程执行相关的信息。TCB数据结构中的数据通常包括：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>线程ID</strong>：用于唯一标识系统内的线程；</li>
<li data-line="1" dir="auto"><strong>线程状态</strong>：如运行、等待、就绪等；</li>
<li data-line="2" dir="auto"><strong>寄存器内容</strong>：保存线程的上下文信息，确保线程能够恢复执行；</li>
<li data-line="3" dir="auto"><strong>优先级</strong>：用于调度策略；</li>
<li data-line="4" dir="auto"><strong>线程特定的数据</strong>：每个线程私有的数据区；</li>
<li data-line="5" dir="auto"><strong>指向PCB的指针</strong>；</li>
<li data-line="6" dir="auto"><strong>指向不同内存区域的指针</strong>：text,data,heap and stack；</li>
<li data-line="7" dir="auto"><strong>资源信息指针</strong>。</li>
<li data-line="8" dir="auto">...</li>
</ul></div><div class="el-p"><p dir="auto">为了使线程执行相独立，线程的栈空间和上下文信息是线程独享的，与其他线程相独立。虽然线程TCB中有指向资源的指针，但这些资源都是共享的，线程并不作为资源的管理者。</p></div><div class="el-p"><p dir="auto">在Linux中，进程和线程都使用<code>task_struct</code>数据结构来描述它们的状态和信息。但同一进程内的线程间共享进程内的地址空间和资源。我们也有线程组的概念，同一进程内的主线程和其他线程组成一个线程组，组号<code>tgid</code>即为主线程的线程标识符。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.2 Thread States" dir="auto" class="heading" id="1.4.2_Thread_States"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.2 Thread States</h4><div class="heading-children"><div class="el-p"><p dir="auto">和进程一样，每个独立的线程也都有自己的状态。我们之前介绍的进程模型有七种状态，线程也有自己的<strong>五态模型</strong>。由于线程并不是资源的调度单位，我们不用考虑线程在内存上的换入和换出，因此在线程模型中不会看到挂起态。线程的五态有：<strong>new</strong>、<strong>ready</strong>、<strong>running</strong>、<strong>waiting</strong>、<strong>terminate</strong>。</p></div><div class="el-p"><p dir="auto">线程的状态和进程的状态息息相关，如果进程因等待I/O操作或其他资源而阻塞，那么所有线程也会进入阻塞状态。当进程处于就绪状态时，虽然它的线程已经准备好运行，但进程没有被调度到CPU上，因此所有线程暂时不能使用CPU资源。这就是进程被称为最基本的资源调度单位的原因。</p></div><div class="el-p"><p dir="auto">如果所有的线程都被阻塞，而进程处在就绪态呢？由与进程的运行需要依托至少一个线程的可运行状态，所有即使进程能够获取资源也不可以执行任何任务。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.5 Thread Context Switch" dir="auto" class="heading" id="1.5_Thread_Context_Switch"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5 Thread Context Switch</h3><div class="heading-children"><div class="el-p"><p dir="auto">线程上下文切换是操作系统从一个线程的执行状态切换到另一个线程的执行状态的过程。这个过程的过程和进程上下文切换的过程类似。与进程的上下文切换相比，线程的上下文信息更小，所以切换效率更高。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.5.1 Thread Switching Inside a Process" dir="auto" class="heading" id="1.5.1_Thread_Switching_Inside_a_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5.1 Thread Switching Inside a Process</h4><div class="heading-children"><div class="el-p"><p dir="auto">在同一进程下，由于线程之间共享进程资源，其上下文切换通常不涉及存储块的交换，所以线程切换的局部性更好（保留缓存内容，可能不需要刷新MMU）。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.5.2 Thread Switching Between Processes" dir="auto" class="heading" id="1.5.2_Thread_Switching_Between_Processes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5.2 Thread Switching Between Processes</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们刚才比较同一进程内的线程切换，由于进程内的线程共享了大部分进程资源，因而开销相对较低。而跨进程的线程切换则不太一样了。由于跨进程的线程没有共享的进程资源，而且进程与进程之间的内存空间和安全环境的完全隔离，所以跨进程间的线程切换的系统开销要大得多。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.5.x Kernel Heap" dir="auto" class="heading" id="1.5.x_Kernel_Heap"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5.x Kernel Heap</h4><div class="heading-children"><div class="el-p"><p dir="auto">在<a data-tooltip-position="top" aria-label="4. Interrupts and System Calls > 第七课 Interrupt Context" data-href="4. Interrupts and System Calls#第七课 Interrupt Context" href="congzhi's-os-series/4.-interrupts-and-system-calls.html#第七课_Interrupt_Context" class="internal-link" target="_self" rel="noopener nofollow">阶段-5</a>，我们接触到了内核栈，我们用内核栈来存储中断上下文。那问题来了，进程的上下文 PCB 和线程的上下文 TCB 在哪里存储呢（<code>task_struct</code> in Linux）？它们在内核堆中存储。内核堆和用户进程的堆空间一样，是一种动态内核数据结构。</p></div><div class="el-p"><p dir="auto">我们没有接触 CPU 调度的内容。简单起见，你需要理解——当线程切换时，内核需要负责保存当前线程的 TCB 并恢复调度线程的 TCB 。由于这一过程在内核中进行，所以硬件和系统会先将中断上下文保存到内核栈中。然后操作系统保存剩余的上下文（TCB）到内核堆，调度程序选择一个线程，恢复其 TCB 并通过 <code>iret</code> 返回用户态或内核态执行。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.6 Lighter but Stronger" dir="auto" class="heading" id="1.6_Lighter_but_Stronger"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.6 Lighter but Stronger</h3><div class="heading-children"><div class="el-p"><p dir="auto">线程的这种轻量型可以带给我们很多好处，但也能够给程序的执行带去不少的烦恼。下面，我们将比较线程和进程在各个方面上的不同，然我们得以对两者有更好的理解。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.6.1 Lighter is Lighter" dir="auto" class="heading" id="1.6.1_Lighter_is_Lighter"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.6.1 Lighter is Lighter</h4><div class="heading-children"><div class="el-p"><p dir="auto">在它们的创建方式上，我们讨论进程<code>fork()</code>的创建方式。在POSIX thread库中，线程通过<code>pthread_create()</code>来创建。由于进程是资源调度的基本单位，所以在进程创建的过程中，除了创建一个主线程之外，还要将父进程的所有资源映像拷贝到进程自己的内存空间中。相比之下，线程不需要进行资源的完整复制，而是共享同一进程的资源，因而线程的创建更小。</p></div><div class="el-p"><p dir="auto">由于线程共享进程中的资源，因而线程的内存开销和切换开销要小很多。你可以将进程和线程理解为大石头和小石头，操作系统搬小石头肯定更加地容易。在数据的共享上，进程会使用繁琐的IPC机制，在同一进程内的线程不需要考虑这些，因为它们的资源是共享的。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.6.2 Lighter can Indeed Cause Fires" dir="auto" class="heading" id="1.6.2_Lighter_can_Indeed_Cause_Fires"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.6.2 Lighter can Indeed Cause Fires</h4><div class="heading-children"><div class="el-p"><p dir="auto">事事都有其两面性，看过线程光鲜亮丽的一部分，我们接下来学习线程阴暗的一面。相比进程之间彼此隔离，由于线程间资源共享可能导致一系列问题。比如不当的调度导致的资源竞和死锁问题。我们说线程栈是独立的，但不像进程空间那样隔离。理论上，一个线程可能访问另一个线程的栈空间，这是非常危险的。可能导致程序的崩溃。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.6.3 Thread-Local Storage" dir="auto" class="heading" id="1.6.3_Thread-Local_Storage"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.6.3 Thread-Local Storage</h4><div class="heading-children"><div class="el-p"><p dir="auto">在前面，我们说多个线程可能属于一个进程，这些线程共享进程中的数据。这种数据共享是多线程编程带给我们的一个好处。但在某些情况下，每个线程可能需要自己的某些数据副本。我们将这种数据称为<strong>线程局部存储</strong>。</p></div><div class="el-p"><p dir="auto">一个线程的TLS仅对这一个线程可见，这破坏了一定的共享性，但会带来很多好处（比如避免可能导致的资源竞争和死锁问题）。为了在线程的生存周期内可用，TLS通常声明为静态的。在C语言和C++中，可以使用 <code>__thread</code> (编译器提供)或 <code>thread_local</code> (C++11)来声明TLS变量。</p></div><div class="el-p"><p dir="auto">如果我们想为一个线程分配一个唯一的标识符，我们可以这样声明：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

__thread <span class="token keyword">int</span> threadID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">printThreadID</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    threadID <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread ID: %d\n"</span><span class="token punctuation">,</span> threadID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">;</span>

    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> printThreadID<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> printThreadID<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> printThreadID<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t3<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">thread_local</span> <span class="token keyword">int</span> threadID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printThreadID</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    threadID <span class="token operator">=</span> id<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread ID: "</span> <span class="token operator">&lt;&lt;</span> threadID <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>printThreadID<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>printThreadID<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>printThreadID<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.7 Multi-threading Models" dir="auto" class="heading" id="1.7_Multi-threading_Models"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7 Multi-threading Models</h3><div class="heading-children"><div class="el-p"><p dir="auto">现在，我们对线程也有了一定的理解。我们对比了进程和线程上下文切换开销。由于线程的轻量型，我们将线程作为 CPU 调度的基本单位，而进程仅作为资源管理的基本单位。</p></div><div class="el-p"><p dir="auto">然而，线程究竟是内核所创建并进行调度的。在用户空间，我们所能够接触到的并不是我们所讲到的线程，而是另一种线程——<strong>用户级线程</strong>。内核调度的线程我们称为——<strong>内核级线程</strong>。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.1 Thread Types" dir="auto" class="heading" id="1.7.1_Thread_Types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.1 Thread Types</h4><div class="heading-children"><div class="el-p"><p dir="auto">以上，我们简单地了解了<strong>内核级线程(Kernel-Level Threads)</strong> 和<strong>用户级线程(User-Level Threads)</strong> 。内核级线程是由操作系统直接管理的线程。而用户级线程是由用户态的线程库（如 POSIX Thread 库）所管理的，由于用户级线程的创建、切换和销毁都在用户态中进行。因此内核级线程并不知晓用户级线程的存在。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204011034.jpg" src="Pasted image 20241204011034.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204011034.jpg" src="congzhi's-os-series/pics/pasted-image-20241204011034.jpg"></span></p></div><div class="el-p"><p dir="auto">无论是内核级线程还是用户级线程都有自己的线程资源（栈、上下文信息等），但是内核级线程的 TCB 是被操作系统内核管理的，而用户级线程的 TCB 被用户空间的线程库程序所管理。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.1 李逵和李鬼" dir="auto" class="heading" id="1.7.1_李逵和李鬼"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.1 李逵和李鬼</h5><div class="heading-children"><div class="el-p"><p dir="auto">用户级线程是对内核级线程的模拟。在前面学习的线程中，我们说（内核级）线程是CPU基本的调度单位，这里的线程实际上就是内核级线程。因为内核的线程调度器是通过内核级线程的 TCB 对线程进行调度的。而在用户空间创建的用户级线程不会被操作系统所察觉，因而系统没有办法对用户级线程进行调度。</p></div><div class="el-p"><p dir="auto">由于内核并不会记录 ULTs 的资源和上下文，所以 ULTs 并不能参与 CPU 的调度。ULTs 的运行建立在运行在 CPU 的 KLTs 之上。虽然看上去 ULTs 好像并不大方便高效，但这种线程事实上能够带给我们许多好处。</p></div><div class="el-p"><p dir="auto">由于 ULTs 的操作都是在用户态进行的，所以 ULTs 切换时不需要考虑系统调用的开销。一般情况下，用户级线程的 TCB 也相较内核线程小得多，所以上下文切换的开销可以非常低。由此，ULTs 的创建、切换等操作并不需要内核的帮助，速度可以相较 KLTs 快很多。</p></div><div class="el-p"><p dir="auto">但是这种线程的缺点也显而易见，多个 ULTs 可能运行在一个 KLT 上，没有实际上线程的并发，性能可能并不够好。如果一个 KLT 对应多个 ULTs，每个 ULT 可能只会获得 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math></mjx-container></span> 的线程性能。下面，我们将介绍三种用户级线程和内核级线程的设计模型：多对一模型、一对一模型、多对多模型。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.2 Many-to-One Model" dir="auto" class="heading" id="1.7.2_Many-to-One_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.2 Many-to-One Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">多对一模型中，一个 KLT 上要支持多个 ULTs 的执行。我们前面提到过，ULTs 的切换开销很低，所以这种模型中的上下文切换非常快。但由于这种模型只有一个 KLT，这就意味着一时间在这些 ULTs 只能有一个在 CPU 核心上执行。这种模型在多核处理器上并不能发挥并行执行的优势。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204011053.jpg" src="Pasted image 20241204011053.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204011053.jpg" src="congzhi's-os-series/pics/pasted-image-20241204011053.jpg"></span></p></div><div class="el-p"><p dir="auto">而且，如果某个时刻其中一个ULT调用了阻塞的系统调用（使用I/O），那么唯一的那个内核级线程就会阻塞。进而，整个进程会被阻塞，剩下的那些用户级线程就也随之阻塞。即一个 ULT 的阻塞导致了所有 ULTs 的阻塞。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.3 One-to-One Model" dir="auto" class="heading" id="1.7.3_One-to-One_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.3 One-to-One Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">一对一模型是最简单的模型，即一个 ULT 都对应着一个 KLT ，每个 ULT 事实上变成了一个独立的调度单位（因为 ULT 的线程操作就对应着 KLT 的线程操作）。这种模型和我们学习的线程是对应的。使用一对一模型后，我们就不必担心一个 ULT 的阻塞导致整个进程阻塞的事件发生。而且，使用一对一模型后，这些 ULTs 可以在多处理器上并发地运行。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204011045.jpg" src="Pasted image 20241204011045.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204011045.jpg" src="congzhi's-os-series/pics/pasted-image-20241204011045.jpg"></span></p></div><div class="el-p"><p dir="auto">由于这种模型的一一对应，我们实际上失去了 ULTs 给我们带来的好处。不能再享受到多用户级线程带来的低开销线程上下文切换。意味着你每创建一个用户级线程，背后都对应着一个支持 ULT 的系统级线程，所有的调度都将在内核的调度器下完成。</p></div><div class="el-p"><p dir="auto">虽然看上去有这么些缺点，但现在的许多操作系统仍然采用一对一的模型。一方面这种模型较好实现，在多核处理器的时代也能够有较好的性能来支持庞大数量的内核级线程数量。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.4 Many-to-Many Model" dir="auto" class="heading" id="1.7.4_Many-to-Many_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.4 Many-to-Many Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">在多对多模型上，M 个用户级线程被固定的 N 个内核级线程所支持。相比上两种模型，多对多模型更加灵活，性能看上去也更好。在多对多模型中，ULT 可以不再绑定到特定的 KLT 上了。我们可以在用户级的线程库中实现一些调度机制，比如当某个 KLT 被阻塞，我们可以让其余的 ULTs 可以迁移到其他的 KLTs 上，当然，这就意味着可怜的 cache 命中率。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204011100.jpg" src="Pasted image 20241204011100.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204011100.jpg" src="congzhi's-os-series/pics/pasted-image-20241204011100.jpg"></span></p></div><div class="el-p"><p dir="auto">历史上， M:N 模型曾在 FreeBSD5 上得到过支持，但由于调度的复杂性和维护成本低限制，在 FreeBSD7 默认转为 1:1 模型，并从 FreeBSD8 起完全弃用 M:N 模型。</p></div><div class="el-p"><p dir="auto">而随着 Go 语言进入人们的视野，这一模型重获新生。Go 原生的 GPM (Goroutine, Processor, Machine) 调度架构，通过在用户空间低成本调度海量 Goroutines（也就是 ULTs），显著降低了线程创建和切换的开销，让 M:N 模型在高并发的场景下展现其优越性。详见<a data-href="GPM Model of Go" href="let's-go/gpm-model-of-go.html" class="internal-link" target="_self" rel="noopener nofollow">GPM Model of Go</a>。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.5 Two-Level Model" dir="auto" class="heading" id="1.7.5_Two-Level_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.5 Two-Level Model</h4><div class="heading-children"><div class="el-p"><p dir="auto"><span alt="Pasted image 20241204011158.jpg" src="Pasted image 20241204011158.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241204011158.jpg" src="congzhi's-os-series/pics/pasted-image-20241204011158.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.6 Scheduler Activations" dir="auto" class="heading" id="1.7.6_Scheduler_Activations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.6 Scheduler Activations</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们已经了解了不同的线程模型，那么用户态线程库中创建的线程是如何变成可调度的内核线程的呢？对于多对多或两级线程模型的系统实现中，通常会引入一个中间层，称为轻量级进程(LWP)。对于用户线程库来说，LWP 相当于一个虚拟的处理器，应用程序可以在其上进行调度和运行。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.6.1 LWPs" dir="auto" class="heading" id="1.7.6.1_LWPs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.6.1 LWPs</h5><div class="heading-children"><div class="el-p"><p dir="auto">每个 LWP 都会关联到一个内核线程，操作系统通过调度这些内核线程来控制它们在物理处理器上的执行。如果一个内核线程进入阻塞状态（例如等待 I/O 操作完成），相应的 LWP 也会阻塞，从而导致附加到该 LWP 的用户线程无法继续执行。</p></div><div class="el-p"><p dir="auto">为了保证程序的高效运行，应用程序通常需要多个 LWP 。对于不同的应用，所需要的 LWP 数量也各不相同。下面我们举例 CPU bound 和 IO bound 的应用场景：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>对于 CPU 密集型应用</strong>：假设一个在单处理器上运行的 CPU 密集型应用程序。在这种情况下，一次只能运行一个线程，因此一个 LWP 就足够了。</li>
<li data-line="1" dir="auto"><strong>对于 IO 密集型应用</strong>：可能需要多个 LWP。因为每个并发阻塞的系统调用都需要单独的 LWP。例如，假设一个程序发出了 5 个独立的文件读取请求，但系统只分配了 4 个 LWP，那么第 5 个请求必须等待某个 LWP 释放后才能继续。</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250113014249.jpg" src="Pasted image 20250113014249.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250113014249.jpg" src="congzhi's-os-series/pics/pasted-image-20250113014249.jpg"></span></p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.6.2 Scheduler Activations" dir="auto" class="heading" id="1.7.6.2_Scheduler_Activations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.6.2 Scheduler Activations</h5><div class="heading-children"><div class="el-p"><p dir="auto">用于用户线程库和内核之间通信的方案称为<strong>调度激活</strong>。其工作原理如下：内核为应用程序提供一组 LWP 作为虚拟处理器，用户线程库可以将用户线程调度到可用的虚拟处理器上运行。</p></div><div class="el-p"><p dir="auto">如果有关键事件发生，内核会通过<strong>上行调用(Upcall)</strong> 来通知用户线程库。比如，当用户线程即将被阻塞时，上行调用就会被触发，通知应用用户线程库保存阻塞线程的状态，并调度其他线程运行。当阻塞事件结束时，内核再次触发上行调用，通知用户线程库程序恢复之前阻塞的线程。</p></div><div class="el-p"><p dir="auto">上行调用由用户线程库的处理程序负责，且该处理程序必须运行在虚拟处理器（LWP）上。通过这种机制，调度激活实现了用户态与内核态的高效协作。</p></div><div class="el-p"><p dir="auto">在一对一线程模型中，每个用户级线程直接对应一个内核级线程，因此不需要 LWP 作为中间层。在 1:1 模型中，用户级线程会直接映射到内核级线程上。内核负责调度所有的内核级线程，从而实现线程管理的简化和高效性。也就是说，1:1 模型中用户线程的 TCB 完全由内核负责创建和维护。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.7.7 Different Thread Libraries" dir="auto" class="heading" id="1.7.7_Different_Thread_Libraries"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.7 Different Thread Libraries</h4><div class="heading-children"><div class="el-p"><p dir="auto">对于用户而言，我们没发直接创建一个内核级线程。我们能做的只有通过一些封装了系统调用的线程库来创建一个线程。这些封装接口大多运行在高级语言层面。常见的线程库有 POSIX threads,  Windows threads, Java threads 等。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.7.1 POSIX Threads" dir="auto" class="heading" id="1.7.7.1_POSIX_Threads"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.7.1 POSIX Threads</h5><div class="heading-children"><div class="el-p"><p dir="auto">POSIX threads(pthreads) 标准仅仅定义 API 接口的实现，并不规定底层的实现。区别于不同的系统实现，pthreads 创建的线程可以是用户线程也可以是内核线程。因为现代主流的系统都采用 1:1 模型，通过 pthreads 库创建的 TCB 完全由内核创建维护。所以 pthreads 实现的是内核线程。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.7.2 Windows Threads" dir="auto" class="heading" id="1.7.7.2_Windows_Threads"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.7.2 Windows Threads</h5><div class="heading-children"><div class="el-p"><p dir="auto">Windows threads 明确设计了 1:1 的线程模型。每个 TCB 都存储在一个内核对象表里，所有调度都由内核控制，无用户级线程实现。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.7.7.3 OS Independent: Java Threads" dir="auto" class="heading" id="1.7.7.3_OS_Independent:_Java_Threads"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.7.7.3 OS Independent: Java Threads</h5><div class="heading-children"><div class="el-p"><p dir="auto">以上两个线程库都是平台相关的。即使 C++/Rust 等这类高级语言拥有自己的标准线程库，所编译后的代码仍然是平台相关的。而 Java threads 库是平台无关的。</p></div><div class="el-p"><p dir="auto">由于 Java “一次编写，处处运行（Write Once, Run Anywhere）” 的设计理念， Java 会通过引入虚拟机（JVM）来实现对底层系统的封装。简单来说，Java 会将源程序编译为 Java 字节码，在运行字节码程序时，Java 会启动一个 JVM 来在不同操作系统上解释或编译运行。</p></div><div class="el-p"><p dir="auto">所以宿主机上的线程是什么类型， Java thread API 提供的线程就是什么类型的。</p></div></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 The POSIX Thread" dir="auto" class="heading" id="第二课_The_POSIX_Thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 The POSIX Thread</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">POSIX 线程库提供了许多系统调用用于管理线程和线程属性。我们下面一步一步的来介绍这些系统调用。本阶段，我们着重于学习线程管理和线程属性相关的 POSIX 线程库中的系统调用。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 The POSIX Thread: `pthread` API" dir="auto" class="heading" id="2.1_The_POSIX_Thread:_`pthread`_API"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 The POSIX Thread: <code>pthread</code> API</h3><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread</code> 是 POSIX 标准线程的缩写，它的标准定义在 IEEE 1003.1c 中，规范了 UNIX 系统中的线程行为。这些规范促成了代码在不同平台上（类 Unix 系统）的可移植性。常用管理线程相关系统调用有：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// Create a new thread</span>
<span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// Terminate the calling thread</span>
<span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// Wait for a specific thread to exit</span>
<span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// Detach a thread</span>
<span class="token function">pthread_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Yield the processor to another thread</span>
<span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// Send a cancellation request to a thread</span>
<span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Test for pending cancellation requests</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">常用的线程属性相关的系统调用有：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Initialize thread attributes object</span>
<span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Destroy thread attributes object</span>
<span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set the detach state attribute</span>
<span class="token function">pthread_attr_getdetachstate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Get the detach state attribute</span>
<span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Set the stack size attribute</span>
<span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Get the stack size attribute</span>
<span class="token function">pthread_attr_setstackaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Set the stack address attribute</span>
<span class="token function">pthread_attr_getstackaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Get the stack address attribute</span>
<span class="token function">pthread_attr_setscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Set the contention scope attribute</span>
<span class="token function">pthread_attr_getscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Get the contention scope attribute</span>
<span class="token function">pthread_attr_setschedparam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Set the scheduling parameters attribute</span>
<span class="token function">pthread_attr_getschedparam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Get the scheduling parameters attribute</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.2 `pthread` Management" dir="auto" class="heading" id="2.2_`pthread`_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 <code>pthread</code> Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们先从管理 POSIX thread 的相关系统调用上学起。我们先来看线程创建的系统调用。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.1 Create a POSIX Thread: `pthread_create()`" dir="auto" class="heading" id="2.2.1_Create_a_POSIX_Thread:_`pthread_create()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1 Create a POSIX Thread: <code>pthread_create()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">当要创建一个新的线程时，我们会用到<code>pthread_create</code>系统调用，其函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. thread: Pointer to a pthread_t variable that will hold the thread ID.
	2. attr: Pointer to a pthread_attr_t structure that specifies thread attributes (can be NULL for default attributes).
	3. start_routine: Function pointer to the function to be executed by the thread.
	4. arg: Argument to be passed to the start_routine function.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这个函数有 4 个参数，需要接受一个 <code>pthread_t</code> 类型的线程类型变量、一个 <code>pthread_attr_t</code> 类型的线程属性、指向一个可调用对象的函数指针和需要传递的参数。本小节我们不需要关注第二个参数，线程属性是为了更小粒度的控制线程，我们留在下小节介绍。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.1.1 Start Routine and New Calling Thread" dir="auto" class="heading" id="2.2.1.1_Start_Routine_and_New_Calling_Thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1.1 Start Routine and New Calling Thread</h5><div class="heading-children"><div class="el-p"><p dir="auto">在创建线程时，通过设置<code>start_routine</code>的函数指针，我们可以让创建好的线程去执行相关的<code>start&nbsp;routine</code>。在编写<code>start_routine</code>函数时，我们需要遵循以下规则：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token comment">/* Rules to obey:
Return value must be a (void*) pointer.
Parameter only can be one void* type pointer, can be a function pointer or else.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面展示如何使用<code>pthread_create</code>创建一个线程并打印 <code>"Hello from thread!\\n"</code> ：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">printHello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// This is a start routine</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from thread!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span> <span class="token comment">// To store the thread ID</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> printHello<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to create thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to join thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from main!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">当调用 <code>pthread_create</code> 后，新的线程将会创建并开始执行 <code>start_routine</code> 参数所指向的函数。创建完成之后，我们可以用<code>pthread_t</code>类型的变量来操作特定的线程。通过<code>pthread_t</code>变量，我们可以进行线程的管理和控制，比如调用<code>pthread_join</code>等操作来等待线程结束。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.2  Join the Family: `pthread_join()`" dir="auto" class="heading" id="2.2.2__Join_the_Family:_`pthread_join()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.2  Join the Family: <code>pthread_join()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">当我们需要等待一个线程结束时，就会用到<code>pthread_join()</code>系统调用。<code>pthread_join()</code>会阻塞主线程（或其他线程）等待指定线程完成后再继续执行，它的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. thread: Thread ID of the thread to wait for.
	2. retval: Pointer to a location where the thread's return value will be stored (can be NULL if not needed).

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">为什么一个线程要等待另一个线程呢（主要是主线程等待子线程）？和我们前面学习过的进程 <code>wait()</code> 系统调用类似。主线程需要 <code>pthread_join()</code> 来读取返回值并回收子线程的资源。避免资源泄漏。</p></div><div class="el-p"><p dir="auto">而且如果主线程没有等待子线程完成或者没有将子线程分离，主线程先行退出，那么所有未分离的子线程会被强制退出。这时，操作系统会强制性地回收子线程所占有的资源，可能导致数据完整性问题并带来同步问题。这里，你需要关心的问题是资源没有得到正确的释放。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.3 Exit a Thread: `pthread_exit()`" dir="auto" class="heading" id="2.2.3_Exit_a_Thread:_`pthread_exit()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.3 Exit a Thread: <code>pthread_exit()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">线程有创建就有终止，当我们使用<code>pthread_exit()</code>系统调用时，线程就会终止执行并返回一个值给调用者。函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. retval: Pointer to the return value of the thread.

This function does not return.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>pthread_exit()</code>&nbsp;可以确保线程在退出时正确清理资源（<code>pthread_cleanup_push</code>），并将返回值传递给任何等待它的线程，例如通过&nbsp;<code>pthread_join()</code>&nbsp;函数等待的线程。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// Function to be executed by the thread</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ret_val <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>ret_val <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// Set the return value to 42</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>ret_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Exit the thread and return the value</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>
    <span class="token keyword">int</span> result<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">;</span>

    <span class="token comment">// Create a new thread</span>
    result <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_function<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Handle error</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Wait for the specific thread to exit and get the return value</span>
    result <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Handle error</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Print the return value</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread returned value: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Free the allocated memory</span>
    <span class="token function">free</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.4  Detach from the Family: `pthread_detach()`" dir="auto" class="heading" id="2.2.4__Detach_from_the_Family:_`pthread_detach()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.4  Detach from the Family: <code>pthread_detach()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">我们用<code>pthread_detach</code>&nbsp;系统调用将线程设置为分离状态，使线程结束时资源能被自动回收。要设置守护线程等后台线程就需要将线程设置为分离状态。它的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. thread: Thread ID of the thread to detach.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们前面提到，主线程的退出会导致所有未分离线程的强制退出。而当线程被设置为分离状态后，主线程的退出就不会再影响分离后线程的运行了，这时分离的子线程会在后台继续运行，并在完成后由操作系统自动释放资源（当所有子线程完成后，操作系统会终止整个进程并回收资源）。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.5 Yield a Thread Execution: `pthread_yield()`" dir="auto" class="heading" id="2.2.5_Yield_a_Thread_Execution:_`pthread_yield()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.5 Yield a Thread Execution: <code>pthread_yield()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">当有需要让线程让出 CPU 给其他线程时，就会用到 <code>pthread_yield</code> 系统调用。需要注意的是，这个出让是系统层面上的。其函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Explanation:
This function yields the processor to another thread.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>pthread_yield()</code>会让线程主动放弃 CPU 。当线程调用<code>pthread_yield()</code>后，它将处于就绪状态，并让操作系统的调度程序选择运行其他就绪线程。一旦其他线程完成或被调度程序切换，原线程可以重新获得CPU时间并继续执行。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.3 Attributes Control in POSIX Thread" dir="auto" class="heading" id="2.3_Attributes_Control_in_POSIX_Thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 Attributes Control in POSIX Thread</h3><div class="heading-children"><div class="el-p"><p dir="auto">在前面，我们学习了线程会共享进程的地址空间、进程的一系列资源。但是要使得线程能够正常运行，线程还需要拥有自己独立的 TCB、寄存器组和栈空间。前面的两个由操作系统帮我们管理，作为程序员，你可以在创建子线程时规定一些线程的属性信息。包括：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>栈大小(stack size)</strong>：定义线程的栈大小空间，确保线程运行过程中不会发生栈溢出。你可以通过<code>pthread_attr_setstacksize</code>函数设置栈大小。</li>
<li data-line="1" dir="auto"><strong>调度参数(scheduling parameters)</strong>：设置线程的优先级，以决定线程的执行顺序。可以通过<code>pthread_attr_setschedparam</code>函数设置调度参数。</li>
<li data-line="2" dir="auto"><strong>线程状态(thread state)</strong>：可以设置线程是分离状态还是可连接状态。分离状态的线程在终止后会自动释放资源，而可连接状态的线程需要通过<code>pthread_join</code>来回收资源。可以通过<code>pthread_attr_setdetachstate</code>函数设置线程状态。</li>
</ol></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.1 Structure of Thread Attributes: `thread_attr_t`" dir="auto" class="heading" id="2.3.1_Structure_of_Thread_Attributes:_`thread_attr_t`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1 Structure of Thread Attributes: <code>thread_attr_t</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">在上小结 <code>pthread_create()</code> 中，我们见到了存放线程属性的结构 <code>thread_attr_t</code> 。所有关于线程属性的系统调用都是围绕着这个结构所展开的。简化版的结构体原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> detachstate<span class="token punctuation">;</span>          <span class="token comment">// Thread detach state (PTHREAD_CREATE_JOINABLE or PTHREAD_CREATE_DETACHED)</span>
    <span class="token keyword">int</span> scope<span class="token punctuation">;</span>                <span class="token comment">// Contention scope (PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS)</span>
    <span class="token class-name">size_t</span> stacksize<span class="token punctuation">;</span>         <span class="token comment">// Thread stack size</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>stackaddr<span class="token punctuation">;</span>          <span class="token comment">// Thread stack address</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">sched_param</span> schedparam<span class="token punctuation">;</span> <span class="token comment">// Scheduling parameters (priority, etc.)</span>
    <span class="token comment">// Other fields specific to the implementation</span>
<span class="token punctuation">}</span> <span class="token class-name">pthread_attr_t</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面是一个例子：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// Thread start routine</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">startRoutine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Thread work here</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_attr_t</span> attr<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>
    <span class="token keyword">int</span> result<span class="token punctuation">;</span>

    <span class="token comment">// Initialize the thread attributes object</span>
    <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Specific settings for thread attributes</span>
    <span class="token comment">// Example: set the detach state</span>
    <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_CREATE_JOINABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Create a thread with the specified attributes</span>
    result <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> startRoutine<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to create thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
    Do something here
    */</span>

    <span class="token comment">// Wait for the thread to terminate</span>
    result <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to join thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Destroy the thread attributes object</span>
    <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.2 Initialize the Structure:`pthread_attr_init()`" dir="auto" class="heading" id="2.3.2_Initialize_the_Structure:`pthread_attr_init()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.2 Initialize the Structure:<code>pthread_attr_init()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_attr_init</code>函数用于初始化一个线程属性对象，使其具有默认属性。初始化为默认属性有许多好处，我们希望避免未初始化属性导致的不确定行为，减少潜在的错误，提高查询的可靠性。<code>pthread_attr_init</code>系统调用完成后，我们就可以设置特定化一些的线程属性。</p></div><div class="el-p"><p dir="auto">系统调用的原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to a pthread_attr_t structure to be initialized.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">默认属性一般如下：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">Thread attributes: 
	- Detach state <span class="token operator">=</span> PTHREAD_CREATE_JOINABLE 
	- Scope <span class="token operator">=</span> PTHREAD_SCOPE_SYSTEM 
	- Inherit scheduler <span class="token operator">=</span> PTHREAD_INHERIT_SCHED 
	- Scheduling policy <span class="token operator">=</span> SCHED_OTHER 
	- Scheduling priority <span class="token operator">=</span> <span class="token number">0</span> 
	- Guard size <span class="token operator">=</span> <span class="token number">4096</span> bytes 
	- Stack address <span class="token operator">=</span> 0x40196000 
	- Stack size <span class="token operator">=</span> 0x201000 bytes
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.3 `pthread_attr_destroy()`" dir="auto" class="heading" id="2.3.3_`pthread_attr_destroy()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.3 <code>pthread_attr_destroy()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_attr_destroy</code>&nbsp;用于销毁一个线程属性对象并释放其占用的资源。函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to a pthread_attr_t structure to be destroyed.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.4 Setters and Getters" dir="auto" class="heading" id="2.3.4_Setters_and_Getters"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.4 Setters and Getters</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> detachstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. detachstate: Detach state to be set (PTHREAD_CREATE_JOINABLE or PTHREAD_CREATE_DETACHED).

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_getdetachstate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>detachstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. detachstate: Pointer to an integer where the detach state will be stored.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. stacksize: Stack size to be set.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. stacksize: Pointer to a size_t where the stack size will be stored.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_setstackaddr</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>stackaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. stackaddr: Stack address to be set.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_getstackaddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>stackaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. stackaddr: Pointer to a void* where the stack address will be stored.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_setscope</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. scope: Contention scope to be set (PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS).

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_attr_getscope</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the thread attributes object.
	2. scope: Pointer to an integer where the contention scope will be stored.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.4 Thread Cancellation" dir="auto" class="heading" id="2.4_Thread_Cancellation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4 Thread Cancellation</h3><div class="heading-children"><div class="el-p"><p dir="auto">线程取消是一种机制，允许线程在完成其工作之前被另一个线程终止掉。其中，我们将要取消的线程叫做 target 。要取消某一线程，我们需要先用 <code>pthread_cancel</code> 发送取消请求给目标线程。之后，目标线程一般会在取消点检查取消请求，检查到取消请求后终止线程。（延迟取消）</p></div><div class="el-p"><p dir="auto">线程可以设置自己的取消状态和取消类型，来决定如何相应取消请求。取消类型有：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">异步取消(Asynchronous Cancellation)：线程可以随时被取消。（风险较大）</li>
<li data-line="1" dir="auto">延迟取消(Deferred Cancellation)：线程在到达取消点时检查取消请求。</li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.1 Setting Cancellation Type" dir="auto" class="heading" id="2.4.1_Setting_Cancellation_Type"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1 Setting Cancellation Type</h4><div class="heading-children"><div class="el-p"><p dir="auto">线程可以使用&nbsp;<code>pthread_setcanceltype</code>&nbsp;系统调用来设置自己的取消类型</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. type: Specifies the new cancelability type for the thread. It can be one of the following:
	   - PTHREAD_CANCEL_DEFERRED: The thread will respond to cancellation requests at cancellation points (default).
	   - PTHREAD_CANCEL_ASYNCHRONOUS: The thread will respond to cancellation requests immediately.
	2. oldtype: Pointer to an integer where the previous cancelability type will be stored. Can be NULL if the previous type is not needed.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.2 Cancel a Thread: `pthread_cancel()`" dir="auto" class="heading" id="2.4.2_Cancel_a_Thread:_`pthread_cancel()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.2 Cancel a Thread: <code>pthread_cancel()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">我们用&nbsp;<code>pthread_cancel</code>&nbsp;系统调用取消一个正在运行的线程。与 <code>pthread_exit</code> 不同的是， <code>pthread_cancel</code> 通常是其他线程调用。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. thread: Thread ID of the thread to be canceled.

Return value: Returns 0 on success, non-zero on failure.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.3 Create a Explicit Cancellation Point: `pthread_testcancel()`" dir="auto" class="heading" id="2.4.3_Create_a_Explicit_Cancellation_Point:_`pthread_testcancel()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.3 Create a Explicit Cancellation Point: <code>pthread_testcancel()</code></h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_testcancel</code>&nbsp;系统调用可以在调用线程中创建一个取消点，使线程能够响应取消请求。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Explanation: This function creates a cancellation point in the calling thread. If a cancellation request is pending, the thread will be canceled.

This function does not return a value.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.4 Implicit Cancellation Points" dir="auto" class="heading" id="2.4.4_Implicit_Cancellation_Points"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.4 Implicit Cancellation Points</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们常常使用<code>pthread_testcancel</code>作为取消点来检查是否有取消请求，当检测到请求时，目标线程就会终止线程。然而，pthread 中的库函数还会作为潜在取消点(Potential&nbsp;Cancellation&nbsp;Points)。</p></div><div class="el-p"><p dir="auto">潜在取消点指的是线程在执行这些操作时，可以检查并响应取消请求的地方。这些点通常是在系统调用或库函数内部，它们也会检查是否有取消请求，以确保线程能够及时响应取消请求。常见的潜在取消点有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><code>pthread_join</code>：等待线程终止。如果在等待过程中收到取消请求，当前线程会响应并退出。</li>
<li data-line="1" dir="auto"><code>pthread_testcancel</code>：显式检查取消请求的位置。插入此调用可以设置明确的取消点。</li>
<li data-line="2" dir="auto"><code>pthread_cond_wait</code>：等待条件变量。如果在等待过程中收到取消请求，线程会响应取消。</li>
<li data-line="3" dir="auto"><code>read</code>&nbsp;和&nbsp;<code>write</code>：许多I/O操作，如文件读写，也会作为取消点。</li>
<li data-line="4" dir="auto"><code>sleep</code>：休眠函数在终止时也会检查取消请求。</li>
</ol></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.5 Send Cancellation" dir="auto" class="heading" id="2.4.5_Send_Cancellation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.5 Send Cancellation</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们主要使用 <code>pthread_cancel</code> 系统调用来发送取消请求，这是 POSIX 标准中提供的线程取消机制。通过 <code>pthread_cancel</code> ，可以发送取消请求并使目标线程在取消点检查和相应取消请求。下面是一个简单的例子：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">startRoutine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread running\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set a cancellation point, check for cancel request</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>

    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> startRoutine<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Blocking for 3s before send cancellation.</span>
    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Send cancellation.</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main thread ends\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.6 Cleanup Handler" dir="auto" class="heading" id="2.4.6_Cleanup_Handler"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.6 Cleanup Handler</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果取消线程的时候线程仍然占有资源怎么办？为了避免资源泄漏，我们可以用下面的系统调用来设置一个 cleanup 句柄。确保每次线程取消时都会调用 cleanup&nbsp;routine 来清理线程，释放资源。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token comment">// Register cleanup handler with argument.</span>
<span class="token keyword">void</span> <span class="token function">pthread_cleanup_push</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>argument<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
1. routine: Pointer to the cleanup handler function.
2. argument: Argument to be passed to the cleanup handler function.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Run if execute is non-zero.</span>
<span class="token keyword">void</span> <span class="token function">pthread_cleanup_pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> execute<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
1. execute: If non-zero, the cleanup handler is executed.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">注意，<code>pthread_cleanup_push</code>&nbsp;和&nbsp;<code>pthread_cleanup_pop</code>&nbsp;必须在同一作用域下成对使用。如果使用了一个，就必须使用另一个。如果没有一个，那么两个都不要出现。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.4.6.1 Cleanup Handler Example" dir="auto" class="heading" id="2.4.6.1_Cleanup_Handler_Example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.6.1 Cleanup Handler Example</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">cleanupHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> array<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>a <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Array cleaned up.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">startRoutine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先分配内存</span>
    <span class="token function">pthread_cleanup_push</span><span class="token punctuation">(</span>cleanupHandler<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread running\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_testcancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">pthread_cleanup_pop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// To pair</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> startRoutine<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main thread ends\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>void** a = (void**) array;</code>的必要性：使用<code>(void**)</code>提供了指针的间接访问，通过传递&nbsp;<code>void*</code>&nbsp;参数到清理函数，如果需要修改或检查传入的内存指针指向的内容，可以将其转换为&nbsp;<code>void**</code>。通过类型转换确保指针类型匹配，使得我们能够访问并释放原指针指向的内存。</p></div><div class="el-p"><p dir="auto">如果cancellation在<code>pthread_cleanup_push(cleanupHandler, array);</code>之前就发生了怎么办？我们可以用下面的方法：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">pthread_cleanup_push</span><span class="token punctuation">(</span>cleanupHandler<span class="token punctuation">,</span> <span class="token operator">&amp;</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> 
array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Concurrency on Multicore System" dir="auto" class="heading" id="第三课_Concurrency_on_Multicore_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Concurrency on Multicore System</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 Dark Age's Gone" dir="auto" class="heading" id="3.1_Dark_Age's_Gone"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 Dark Age's Gone</h3><div class="heading-children"><div class="el-p"><p dir="auto">在上一个阶段的结尾，我们简要讨论了多核处理器的调度问题。对于大多数系统来说，多核处理器和优化调度确实能够显著加快系统的运行速度。想象一下，如果有100个人在排队吃面条，显然两家面馆一起营业的效率会比只有一家面馆要高一倍。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.1 Time Slicing on Unicore" dir="auto" class="heading" id="3.1.1_Time_Slicing_on_Unicore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 Time Slicing on Unicore</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.2 Time Slicing on Multicore" dir="auto" class="heading" id="3.1.2_Time_Slicing_on_Multicore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.2 Time Slicing on Multicore</h4><div class="heading-children"></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.2 Parallelism and Speedup" dir="auto" class="heading" id="3.2_Parallelism_and_Speedup"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 Parallelism and Speedup</h3><div class="heading-children"><div class="el-p"><p dir="auto">This depends on the nature of the task (n&lt;core number and in an ideal scenario)</p></div><div class="el-p"><p dir="auto">Fully parallelized: n*Threads = n*Speed<br>
Partitally parallelized: n*Threads = N*Speed (1&lt;N&lt;n)<br>
Cannot be parallelized: n*Threads = 1*Speed</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.3 Amdahl's Law" dir="auto" class="heading" id="3.3_Amdahl's_Law"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3 Amdahl's Law</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>阿姆达尔定律(Amdahl's&nbsp;Law)</strong> 是计算机科学中的一个公式，用来预测系统在添加多个处理器后的最大可能加速比。阿姆达尔定律表达了一个程序中可以被并行化的部分和不能被并行化的部分，以及在添加更多处理器后系统性能的提升受限于那部分不可并行的计算。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.3.1 Formula" dir="auto" class="heading" id="3.3.1_Formula"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.1 Formula</h4><div class="heading-children"><div class="el-p"><p dir="auto"><span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-merror data-mjx-error="Misplaced &amp;" title="Misplaced &amp;"><mjx-mtext style="font-family: MJXZERO, serif;"><mjx-utext variant="-explicitFont" style="width: 544px;">S(n)&amp;nbsp;=&amp;nbsp;\frac{1}{(1&amp;nbsp;-&amp;nbsp;P)&amp;nbsp;+&amp;nbsp;\frac{P}{n}}</mjx-utext></mjx-mtext></mjx-merror></mjx-math></mjx-container></span></p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>&nbsp;是使用&nbsp;n&nbsp;个处理器时的加速比。</li>
<li data-line="1" dir="auto"><span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D443 TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span> 是可以并行化的程序部分比例。</li>
<li data-line="2" dir="auto"><span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D443 TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span>&nbsp;是不能并行化的程序部分比例。</li>
<li data-line="3" dir="auto"><span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span>&nbsp;是处理器数量。</li>
</ul></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="x. Threads on Different Platform(DO NOT READ)" dir="auto" class="heading" id="x._Threads_on_Different_Platform(DO_NOT_READ)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x. Threads on Different Platform(DO NOT READ)</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.1 线程和执行流" dir="auto" class="heading" id="x.1_线程和执行流"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1 线程和执行流</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.1 为什么用线程？" dir="auto" class="heading" id="x.1.1_为什么用线程？"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.1 为什么用线程？</h4><div class="heading-children"><div class="el-p"><p dir="auto">上述课程的学习完毕后，我们应当对线程有了一定了解了。简单来说，线程就是进程的执行流，执行流是什么我们马上会介绍。还记得我们进程番外篇学习的 IPC 机制么？通过IPC，我们创建多个进程共同解决一个问题，但这样做除了资源的浪费，还不得不考虑进程间通信带来的开销。但是引入线程后，上述两个我们最关系的问题迎刃而解。</p></div><div class="el-p"><p dir="auto">在多核处理器的背景下，创建多个线程的好处是显而易见的——<strong>节省资源</strong>。线程虽然有独立的TCB，<strong>但是线程没有独立的进程虚拟地址空间</strong>。这就为线程带来很多相对进程而言的优点，这也是为什么线程能够打赢进程。当项目的代码量很大的时候，<code>fork()</code>创建的子进程的代码区会浪费很大一部分珍贵的内存空间，本质上还是父子进程共享”同一段“代码。但使用线程后，双引号就可以去掉了。</p></div><div class="el-p"><p dir="auto">而且相比进程，线程为我们带来的优点有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">对线程的操作更快（创建、切换、销毁等）；</li>
<li data-line="1" dir="auto">TCB 更轻量；</li>
<li data-line="2" dir="auto">线程间数据直接共享，免去繁琐的 IPC 操作。<br>
但是有优点就会有缺点，比如：</li>
<li data-line="4" dir="auto">因为进程之间彼此隔离，因而进程的稳定性更好。</li>
</ol></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.2 栈空间的理解" dir="auto" class="heading" id="x.1.2_栈空间的理解"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.2 栈空间的理解</h4><div class="heading-children"><div class="el-p"><p dir="auto">在理解栈空间之前，我们可以先去看看进程代码是如何执行的——详见 <strong><em>《<a data-href="进程的一生——从出生到死亡 (Abandoned)" href="some-notes/进程的一生——从出生到死亡-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">进程的一生——从出生到死亡 (Abandoned)</a>》</em></strong>。知道了进程的执行逻辑之后，我们会注意到进程虚拟空间中 <strong>“栈”</strong> 这个名词的分量。栈是一个很重要的概念，代码的功能是在函数中执行的，而函数的执行依赖在栈空间中创造的一个个栈帧来实现。因此程序的执行和栈空间密不可分，即<strong>栈空间就是独立的运行上下文</strong>。</p></div><div class="el-p"><p dir="auto">当一个进程拥有多个线程时，每个线程共享代码段、数据段等资源。每个线程创建的时候操作系统会为这个线程分配单独的栈空间资源。比如，一个线程的栈空间从A到B，另一个线程的栈空间从B到C（A&lt;B&lt;C），以此类推。每个线程的代码在各自的栈空间内运行。</p></div><div class="el-p"><p dir="auto">我们可以用下面的代码来进行<strong>线程栈空间的初始化</strong>。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">m_Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>size_t stack_size <span class="token operator">=</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">// 1MB</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>stack_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们说线程之间数据共享，其实不仅仅是指数据段中的数据。理论上如果知道其他线程栈中局部变量在栈帧中的位置，也可以对这些数据进行操作。因此，线程中的资源是高度共享的。如果线程甲创建的栈帧覆盖线程乙的栈空间，就有可能导致进程的终止。（<em>Threads share all segments except the stack, but a thread can still access the stack of another thread.</em>）</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.2 Thread in Different System" dir="auto" class="heading" id="x.2_Thread_in_Different_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2 Thread in Different System</h3><div class="heading-children"><div class="el-p"><p dir="auto">在当下的日常生活中，无论是手机、电脑、工作站或是服务器都采用多核处理器架构。这是因为相比于执着地将单核登峰造极（在单核心上堆料），多加一个核心性价比要来的更好。由此，多核处理器成为了绝对的主流。但核心也不是越多越好的，要发挥多核处理器的性能优势，不仅仅需要操作系统合理的调度，同样也需要我们开发人员编写多线程的程序以供操作系统调度。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.2.1 Thread Model in Windows" dir="auto" class="heading" id="x.2.1_Thread_Model_in_Windows"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2.1 Thread Model in Windows</h4><div class="heading-children"><div class="el-p"><p dir="auto">在Windows操作系统中，线程是进程的基本执行单元。每个进程可以包含一个或多个线程，这些线程共享进程的资源（如内存空间、文件句柄等）。当用户创建一个线程时，Windows会在内核中创建一个对应的内核级线程。Windows采用我们前面所说的1:1线程模型，即每个用户级线程对应一个内核级线程。这种模型的优点是线程管理和调度由操作系统内核负责，简化了开发者的工作。</p></div><div class="el-p"><p dir="auto">在Windows中，同一台主机上，不同进程中的线程ID可能会重复，因为线程ID在进程内是唯一的。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.2.2 Thread Model in Linux" dir="auto" class="heading" id="x.2.2_Thread_Model_in_Linux"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2.2 Thread Model in Linux</h4><div class="heading-children"><div class="el-p"><p dir="auto">在Linux操作系统中，线程和进程的概念则更加模糊。Linux使用轻量级进程(Lightweight Process, LWP)来实现线程，每个线程在内核中都是一个task。Linux通过<code>pthread_create()</code>或<code>clone()</code>系统调用创建线程，<code>clone()</code>允许创建一个共享资源的task（线程）。每个task都有一个唯一的<code>struct task_struct</code>数据结构，用于管理和调度。与Windows不同，Linux的线程模型更灵活，可以通过<code>clone()</code>的参数指定共享哪些资源。</p></div><div class="el-p"><p dir="auto">在Linux中，所有属于同一进程的线程共享相同的线程组ID（TGID），这个TGID实际上就是进程的PID。而由于进程和线程都是为task，每个任务都有唯一的TID。所以同一台主机上的所有的线程ID都是唯一的。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.3 Threads in Modern C++ : `std::thread`" dir="auto" class="heading" id="x.3_Threads_in_Modern_C++_:_`std::thread`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3 Threads in Modern C++ : <code>std::thread</code></h3><div class="heading-children"><div class="el-p"><p dir="auto">C++11的多线程库提供了一组标准的API，用于创建和管理线程、同步线程操作等。这些API包括<code>std::thread</code>、<code>std::mutex</code>、<code>std::condition_variable</code>等。由于这些API是基于pthread标准设计的，因此它们在不同操作系统上的实现是相似的。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.3.1 No OS Specific" dir="auto" class="heading" id="x.3.1_No_OS_Specific"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.1 No OS Specific</h4><div class="heading-children"><div class="el-p"><p dir="auto">Windows操作系统本身提供了丰富的线程API，如<code>CreateThread</code>、<code>WaitForSingleObject</code>等。C++11的多线程库在Windows上实现时，底层会调用这些Windows API。由于Windows采用1:1线程模型，因此每个C++创建的线程都会对应一个内核级线程。</p></div><div class="el-p"><p dir="auto">Linux操作系统主要使用pthread库来实现多线程。C++11的多线程库在Linux上实现时，底层调用了pthread API，如<code>pthread_create</code>、<code>pthread_join</code>等。Linux的线程模型基于轻量级进程（LWP），C++程序中创建的每个线程都会对应一个<code>task_struct</code>。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.3.2 Crate a Thread" dir="auto" class="heading" id="x.3.2_Crate_a_Thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.2 Crate a Thread</h4><div class="heading-children"><div class="el-p"><p dir="auto">当程序加载进内存，内核会创建该程序的主线程，其 start routine 的入口在 <code>main()</code> 的开始。在 <code>main()</code> 这个主线程下，我们可以使用 <code>thread</code> 类创建多个子线程。过程如下：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello there! I am No."</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_1</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_2</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_3</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_4</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_5</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_6</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_7</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_8</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_9</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_10</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过<code>thread</code>类就可以创建线程类对象，我们需要给<code>thread</code>类的构造函数传递可调用对象的参数，这里使用函数作为参数。但这个程序会出现bug，这是因为：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>主线程没有等待子线程而先行退出</strong>；</li>
<li data-line="1" dir="auto"><strong>并没有实现对共享变量<code>i</code>的互斥访问。</strong></li>
</ol></div><div class="el-p"><p dir="auto">因而会导致如下的问题出现：</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240905160146.png" src="Pasted image 20240905160146.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240905160146.png" src="congzhi's-os-series/pics/pasted-image-20240905160146.png"></span></p></div><div class="el-pre"><pre class="language-shell" tabindex="0"><code data-line="0" class="language-shell is-loaded">du@DVM:~/Desktop$ ./thread 
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.6
terminate called without an active exception
Hello there<span class="token operator">!</span> I am No.7
Aborted <span class="token punctuation">(</span>core dumped<span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.3.2 Main Thread and Child Thread" dir="auto" class="heading" id="x.3.2_Main_Thread_and_Child_Thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.2 Main Thread and Child Thread</h4><div class="heading-children"><div class="el-p"><p dir="auto">程序执行对应着新进程的创建，在进程中，main函数就是主线程，而在主线程执行时，我们可以创建另外的线程，让这些线程并行独立执行。我们需要<strong>注意</strong>的是，如果主线程在子线程完成之前结束，程序会调用<code>std::terminate</code>，导致所有未完成的子线程被强制终止，从而引发<code>abort()</code>。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="x.3.2.1 `join()`" dir="auto" class="heading" id="x.3.2.1_`join()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.2.1 <code>join()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">为了避免主线程先于子线程结束，我们用<code>join()</code>函数来阻塞主线程等待子线程结束后再返回。<code>join()</code>确保主线程在子线程结束后回收其资源，避免资源泄漏。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello there! I am No."</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_1</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_2</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_3</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_4</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_5</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_5<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread say byebye!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">运行结果如下：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">Hello there<span class="token operator">!</span> I am No.2
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Main thread say byebye<span class="token operator">!</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>join()</code>函数适用于需要确保子线程完成其任务后再继续主线程工作的情况。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="x.3.2.2 `detach()`" dir="auto" class="heading" id="x.3.2.2_`detach()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.2.2 <code>detach()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">另一种情况是我们想让子线程与主线程分离，主线程从此无法控制子线程，子线程被C++的运行库接管。主进程不需要等待子线程结束在退出，运行库会在这些子线程运行结束后自动清理资源。由此，<code>detach()</code>函数适用于不需要等待子线程完成的任务，例如后台任务或守护线程。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello there! I am No."</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_1</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_2</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_3</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_4</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_5</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_1<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_2<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_3<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_4<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread_5<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread say byebye!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">运行结果如下：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">Main thread say byebye<span class="token operator">!</span>
Hello there<span class="token operator">!</span> I am No.1
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们看到主线程早早就结束了，有的子线程甚至还来不及在屏幕上向我们打招呼。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.3.3 Thread Parameters Passing" dir="auto" class="heading" id="x.3.3_Thread_Parameters_Passing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.3 Thread Parameters Passing</h4><div class="heading-children"><div class="el-p"><p dir="auto">有三种方式在在子线程中传递参数：1. <strong>值传递</strong>；2. <strong>引用传递</strong>；3. <strong>指针传递</strong>。一般来说使用 <code>detach()</code> 函数时<strong>尽量不要传递指针</strong>，还<strong>不要使用隐式类型转换</strong>。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="x.3.3.1 Pass by Value" dir="auto" class="heading" id="x.3.3.1_Pass_by_Value"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.3.1 Pass by Value</h5><div class="heading-children"><div class="el-p"><p dir="auto">普通类型在传递子线程函数参数时，我们可以直接使用值传递。当我们使用值传递时，函数收到的是变量的副本，也就是说，函数内部的变量和元素的变量是两个独立的变量了，修改函数内部的变量并不会影响到原始的变量。所以，当使用值传递时，主线程可以放心的退出。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="x.3.3.2 Pass by Reference" dir="auto" class="heading" id="x.3.3.2_Pass_by_Reference"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.3.2 Pass by Reference</h5><div class="heading-children"><div class="el-p"><p dir="auto">在C++的 <code>std::thread</code> 中，直接传递引用参数需要使用 <code>std::ref</code> 来包装引用，否则 <code>std::thread</code> 会尝试复制参数，这会导致编译错误或未定义行为。示例如下：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//void hello(const int i){</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello there! I am No."</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_1</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//  std::thread thread_1(hello, i);</span>
    thread_1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">使用普通的引用传递会调用一次复制构造函数，导致函数无法对引用对象进行修改，于是我们有<code>std::ref</code>，它可以使子线程在传递参数时不再调用复制构造函数。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="x.3.3.3 Pass by Pointer" dir="auto" class="heading" id="x.3.3.3_Pass_by_Pointer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.3.3 Pass by Pointer</h5><div class="heading-children"><div class="el-p"><p dir="auto">每个函数的调用和返回都是伴随着栈内存中栈帧的创建和销毁。如果函数内申请了一段堆内存空间，我们就需要在函数返回之前（栈帧销毁前）将这段堆内存给释放掉，因为栈内存是堆内存的唯一寻址方式。所以，当主线程退出而子线程仍在运行且访问传递的指针时，就可能会导致指针悬挂的问题（因为内存已经释放掉了）。</p></div><div class="el-p"><p dir="auto">再者，多个线程同时访问指针指向的数据。期间若是涉及到了数据的写操作，我们还不得不考虑<strong>数据一致性</strong>的问题，可能需要额外的同步机制来确保数据的安全问题。</p></div><div class="el-p"><p dir="auto">在现代C++中，我们可以使用智能指针来避免内存释放的问题，但是数据一致性还是我们需要考虑的。下面是使用<code>std::shared_ptr</code>的示例，即使主线程退出，我们仍然可以正确管理内存。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello there! I am No."</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_1</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_2</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_3</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_4</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread_5</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    thread_1<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_2<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_3<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_4<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread_5<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子线程有时间完成</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread say byebye!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">运行结果如下：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">Hello there<span class="token operator">!</span> I am No.2
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Hello there<span class="token operator">!</span> I am No.5
Main thread say byebye<span class="token operator">!</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.3.4&nbsp;Problem Caused by Condition Race" dir="auto" class="heading" id="x.3.4&nbsp;Problem_Caused_by_Condition_Race"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.3.4&nbsp;Problem Caused by Condition Race</h4><div class="heading-children"><div class="el-p"><p dir="auto">你可能已经注意到，我们上面代码的运行结果并不符合我们所想象的那样。虽然我们用<code>join()</code>确保子线程运行完成，但是我们仍然看到这种情况：</p></div><div class="el-pre"><pre><code data-line="0">Hello there! I am No.2
Hello there! I am No.5
Hello there! I am No.5
Hello there! I am No.5
Hello there! I am No.5
Main thread say byebye!
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这是由于操作系统的线程调度机制和竞态条件导致的。线程的执行顺序由操作系统的调度器决定，可能导致输出顺序的不确定性。为了解决这种问题，我们可以使用一些同步机制，如<strong>互斥锁（mutex）</strong>、<strong>条件变量(condition&nbsp;variable)</strong> 和 <strong>原子操作(atomic operation)</strong> 等。我们将在后面的阶段介绍这些技术。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第y课 Co-routine(C++20) / Go-routine" dir="auto" class="heading" id="第y课_Co-routine(C++20)_/_Go-routine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第y课 Co-routine(C++20) / Go-routine</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-blockquote"><blockquote dir="auto">
<p>协程本身并不作为操作系统中的内容。协程是用户级的并发编程模型。这里仅作为补充。协程并不算新鲜词，Melvin Conway 在 1958 年就提出了协程的概念，并应用于汇编程序中。</p>
</blockquote></div><div class="el-p"><p dir="auto">协程并不算是操作系统的内容，因为它是在用户态实现的。引入协程的概念就是为了避免线程切换的开销，作为更小型的并发控制流，协程随即应运而生。因为协程是用户级别的并发编程模型，所以协程切换时不需要从用户态陷入内核态，系统内核对协程的存在也一无所知。</p></div><div class="el-p"><p dir="auto">在本阶段，我们提到了内核调度的最小单位是内核级的线程。现代的操作系统中，一个用户级线程往往对应着一个内核级线程，当我们在用户空间创建一个用户空间线程之后，我们可以说我们创建了一个内核可以调用的<strong>真•线程</strong>。而协程往往在一个线程中运行，所以协程并不提高程序的性能。</p></div><div class="el-p"><p dir="auto">协程表面上看与用户级线程很相似，但在本质的实现上是不同的。用户级线程是通过线程库（如 POSIX Threads）在用户态提供的一种线程机制，依靠用户线程库完成调度。而协程是一种更轻量级的编程抽象，可以由高级语言的运行时系统（如 C++、Go 等）或用户自定义逻辑来实现。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="y.1 Function vs. Coroutine" dir="auto" class="heading" id="y.1_Function_vs._Coroutine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.1 Function vs. Coroutine</h3><div class="heading-children"><div class="el-p"><p dir="auto">协程和函数很类似，你可以说协程就是一个能暂停并继续执行的函数。当函数中出现<code>co_await</code>、<code>co_yield</code>或<code>co_return</code>的其中一项时，该函数就可被看作为一个协程。下图展示了函数和协程的调用过程。当函数被调用时，函数就会开始执行，直到遇到<code>return</code>或到达函数末尾。而协程可以执行一部分程序后挂起，等待再次调度。协程实现了在单个线程内的并发执行。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250112233950.png" src="Pasted image 20250112233950.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250112233950.png" src="congzhi's-os-series/pics/pasted-image-20250112233950.png"></span><br>
由于协程在用户空间实现并发，我们可以控制代码的执行顺序，从而减少多任务调度造成的竞争问题（特别是cooperative multitasking）。由于协程在单个线程内运行，并且可以在执行过程中暂停和恢复，因此我们可以避免传统多线程编程中常见的竞争条件和锁定问题。在某些情况下，仍然需要使用同步机制来确保一致性。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="y.2 Coroutine Frame and Coroutine Keywords" dir="auto" class="heading" id="y.2_Coroutine_Frame_and_Coroutine_Keywords"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.2 Coroutine Frame and Coroutine Keywords</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="y.2.1 Coroutine Frame" dir="auto" class="heading" id="y.2.1_Coroutine_Frame"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.2.1 Coroutine Frame</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了实现协程从挂起恢复后继续运行，协程也需要保存上下文状态信息，这些上下文状态信息被存放在coroutine frame中。根据coroutine frame的实现方式，我们有两类协程：stackfull coroutine和stackless coroutine（C++20 使用的是 stackless coroutine）。Stackfull coroutine会将coroutine的数据和c-routine frame存放在stack中，而stackless coroutine的实现方式则会把coroutine存放在堆上。</p></div><div class="el-p"><p dir="auto">这些上下文信息会有编译器代为我们管理。当协程的生命周期结束时，协程帧就会被销毁。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="y.2.2 Coroutine Keywords" dir="auto" class="heading" id="y.2.2_Coroutine_Keywords"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.2.2 Coroutine Keywords</h4><div class="heading-children"><div class="el-p"><p dir="auto">在C++中，我们有三个关键字：<code>co_await</code>、<code>co_yield</code>和<code>co_return</code>。这三个关键字得以让协程与外界进行交互。协程可以被暂停/挂起和恢复执行。其中，<code>co_await</code>和<code>co_yield</code>可以挂起协程，而<code>co_return</code>用于返回。它们有不同的行为，协程状态与这三个关键字也息息相关。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="y.3 Coroutine Return Type" dir="auto" class="heading" id="y.3_Coroutine_Return_Type"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3 Coroutine Return Type</h3><div class="heading-children"><div class="el-p"><p dir="auto">包含协程三个关键字之一的函数就可以被看作是一个协程。但需要注意的是，在C++中，当我们创建协程时，协程的返回类型必须是一个特定的类型，该类型需要包含一个名为<code>promise_type</code>的嵌套类型（和<code>std::promise</code>没关系）。所以下面返回类型为<code>int</code>的协程代码在编译时就会报错：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>promise_type</code>是一个类对象（<code>struct</code>或<code>class</code>，而且必须名为<code>promise_type</code>），定义并控制协程的行为和生命周期管理。返回值类型就是对这个<code>promise_type</code>的包装，如下：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">struct</span> <span class="token keyword">co_return</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
		<span class="token comment">// Something needs to be done here...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">co_return</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h4 heading-wrapper"><h4 data-heading="y.3.1 Elements in `promise_type`" dir="auto" class="heading" id="y.3.1_Elements_in_`promise_type`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1 Elements in <code>promise_type</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">在<code>promise_type</code>中，需要至少包含以下的方法<code>get_return_object</code>、<code>initial_suspend</code>、<code>final_suspend</code>、<code>return_void</code>（或<code>return_value</code>）和<code>unhandled_exception</code>。我们将一步一步的对这五个方法进行说明。最小的协程返回对象如下：</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token keyword">struct</span> <span class="token keyword">co_return</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
        <span class="token keyword">co_return</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="y.3.1.1 `get_return_object`" dir="auto" class="heading" id="y.3.1.1_`get_return_object`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1.1 <code>get_return_object</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">这是最先开始执行的方法，<code>get_return_object</code>方法构造协程的返回类型（这里是<code>co_return</code>）并返回<code>promise_type</code>的父类型，也就是协程的返回类型。这里的<code>return {};</code>表示返回默认构造的<code>co_return</code>。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="y.3.1.2 `initial_suspend`" dir="auto" class="heading" id="y.3.1.2_`initial_suspend`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1.2 <code>initial_suspend</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">这个方法在协程开始执行之前被调用，返回一个可等待对象，决定协程是否在开始时挂起。这里，返回的可等待对象可以是<code>std::suspend_never</code>或<code>std::suspend_always</code>。我们这里使用前者，表示协程在开始时不会挂起，而是立即执行。<code>return {};</code>返回默认构造的<code>std::suspend_never</code>。</p></div><div class="el-p"><p dir="auto">根据不同的启动方式，协程可以被分为Lazily started coroutines和eagerly started coroutines。我们例子中给出的是eagerly started coroutines，这些协程在创建时就会立即开始执行。如果我们在这里返回的可等待对象是<code>std::suspend_always</code>那么我们就会创建lazily started coroutine。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="y.3.1.3 `final_suspend`" dir="auto" class="heading" id="y.3.1.3_`final_suspend`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1.3 <code>final_suspend</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">与 <code>initial_suspend</code> 类似，<code>final_suspend</code> 方法在协程结束时被调用，它同样返回一个可等待对象，决定协程是否在结束时挂起。这里我们使用 <code>std::suspend_never</code> 。 <code>final_suspend</code> 是一个 non-throwing method，这就是为什么通常使用 <code>noexcept</code> 关键字。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="y.3.1.4 `return_void` or `return_value`" dir="auto" class="heading" id="y.3.1.4_`return_void`_or_`return_value`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1.4 <code>return_void</code> or <code>return_value</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">这两个方法用于处理协程的返回值。如果协程没有返回值，则使用<code>return_void</code>；如果协程返回值，则使用<code>return_value</code>。在例子中，我们不设置任何返回值，所以使用<code>return_void</code>。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="y.3.1.5 `unhandled_exception`" dir="auto" class="heading" id="y.3.1.5_`unhandled_exception`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.1.5 <code>unhandled_exception</code></h5><div class="heading-children"><div class="el-p"><p dir="auto"> <code>unhandled_exception</code> 方法用于协程中的异常处理，在协程中抛出未捕获的异常时被调用。在一些的例子中，我们不需要做任何的异常处理。例子中，我们使用 <code>std::terminate()</code> 来终止协程。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="y.3.2 Trivial Awaiters" dir="auto" class="heading" id="y.3.2_Trivial_Awaiters"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.3.2 Trivial Awaiters</h4><div class="heading-children"><div class="el-p"><p dir="auto">C++标准提供了两个常见的 awaiters，<code>std::suspend_always</code> 和 <code>std::suspend_never</code>。当使用 <code>std::suspend_always</code> 时，，协程会在遇到 <code>co_await</code> 时立即挂起。使用 <code>std::suspend_never</code> 时，协程会在遇到 <code>co_await</code> 时继续执行，不会挂起。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="y.4 Executing Coroutine and Resuming Coroutine" dir="auto" class="heading" id="y.4_Executing_Coroutine_and_Resuming_Coroutine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.4 Executing Coroutine and Resuming Coroutine</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="y.4.1 Executing a Coroutine" dir="auto" class="heading" id="y.4.1_Executing_a_Coroutine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.4.1 Executing a Coroutine</h4><div class="heading-children"><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;coroutine&gt;</span></span>

<span class="token keyword">struct</span> <span class="token keyword">co_return</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
        <span class="token keyword">co_return</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">co_return</span> <span class="token function">coroutine_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello "</span><span class="token punctuation">;</span>
    <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"world!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">co_return</span> cofoo <span class="token operator">=</span> <span class="token function">coroutine_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cofoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="y.4.2 Resuming Coroutine" dir="auto" class="heading" id="y.4.2_Resuming_Coroutine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>y.4.2 Resuming Coroutine</h4><div class="heading-children"><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;coroutine&gt;</span></span>

<span class="token keyword">struct</span> <span class="token keyword">co_return</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
        <span class="token keyword">co_return</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">co_return</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">coroutine_handle</span><span class="token operator">&lt;</span>promise_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">form_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> handle<span class="token punctuation">;</span>
    <span class="token keyword">co_return</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">&gt;</span> handle_<span class="token punctuation">)</span><span class="token operator">:</span> handle<span class="token punctuation">{</span>handle_<span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">operator</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">coroutine_handle</span><span class="token generic class-name"><span class="token operator">&lt;</span>promise_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> handle_<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">co_return</span> <span class="token function">coroutine_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1. Hello! \n"</span><span class="token punctuation">;</span>
    <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2. Again! \n"</span><span class="token punctuation">;</span>
    co_awiat std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"3. Another Hello! \n"</span><span class="token punctuation">;</span>
    co_awiat std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"4. Another another Hello! \n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">co_return</span> cofoo <span class="token operator">=</span> <span class="token function">coroutine_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cofoo<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cofoo<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls std::coroutine_handle&lt;&gt;::operator();</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&lt;&lt;</span> cofoo<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// Check if coroutine is executed.</span>
	<span class="token function">cofoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">学不明白。。。课程链接如下：</p></div><div class="el-p"><p dir="auto"><a data-tooltip-position="top" aria-label="https://www.youtube.com/playlist?list=PL2EnPlznFzmhKDBfE0lqMAWyr74LZsFVY" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/playlist?list=PL2EnPlznFzmhKDBfE0lqMAWyr74LZsFVY" target="_blank">Coroutines</a></p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#8. Threads and Concurrency"><div class="tree-item-contents heading-link" heading-name="
Threads and Concurrency
"><span class="tree-item-title">Threads and Concurrency</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#第一课_Thread_of_Execution"><div class="tree-item-contents heading-link" heading-name="第一课 Thread of Execution"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课 Thread of Execution</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.1_Concurrency_and_Processes"><div class="tree-item-contents heading-link" heading-name="1.1 Concurrency and Processes"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Concurrency and Processes</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.1.1_Concurrency:_Time_Sharing"><div class="tree-item-contents heading-link" heading-name="1.1.1 Concurrency: Time Sharing"><span class="tree-item-title">1.1.1 Concurrency: Time Sharing</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.1.2_Parallelism"><div class="tree-item-contents heading-link" heading-name="1.1.2 Parallelism"><span class="tree-item-title">1.1.2 Parallelism</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.1.3_Concurrency_Unleashed:_Redefining_Multi-tasking"><div class="tree-item-contents heading-link" heading-name="1.1.3 Concurrency Unleashed: Redefining Multi-tasking"><span class="tree-item-title">1.1.3 Concurrency Unleashed: Redefining Multi-tasking</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.2_Thread_Motivations"><div class="tree-item-contents heading-link" heading-name="1.2 Thread Motivations"><span class="tree-item-title">1.2 Thread Motivations</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.3_Thread_Possessions"><div class="tree-item-contents heading-link" heading-name="1.3 Thread Possessions"><span class="tree-item-title">1.3 Thread Possessions</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.4_TCB_and_Thread_States"><div class="tree-item-contents heading-link" heading-name="1.4 TCB and Thread States"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.4 TCB and Thread States</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.4.1_Thread_Control_Block"><div class="tree-item-contents heading-link" heading-name="1.4.1 Thread Control Block"><span class="tree-item-title">1.4.1 Thread Control Block</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.4.2_Thread_States"><div class="tree-item-contents heading-link" heading-name="1.4.2 Thread States"><span class="tree-item-title">1.4.2 Thread States</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.5_Thread_Context_Switch"><div class="tree-item-contents heading-link" heading-name="1.5 Thread Context Switch"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.5 Thread Context Switch</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.5.1_Thread_Switching_Inside_a_Process"><div class="tree-item-contents heading-link" heading-name="1.5.1 Thread Switching Inside a Process"><span class="tree-item-title">1.5.1 Thread Switching Inside a Process</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.5.2_Thread_Switching_Between_Processes"><div class="tree-item-contents heading-link" heading-name="1.5.2 Thread Switching Between Processes"><span class="tree-item-title">1.5.2 Thread Switching Between Processes</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.5.x_Kernel_Heap"><div class="tree-item-contents heading-link" heading-name="1.5.x Kernel Heap"><span class="tree-item-title">1.5.x Kernel Heap</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.6_Lighter_but_Stronger"><div class="tree-item-contents heading-link" heading-name="1.6 Lighter but Stronger"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.6 Lighter but Stronger</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.6.1_Lighter_is_Lighter"><div class="tree-item-contents heading-link" heading-name="1.6.1 Lighter is Lighter"><span class="tree-item-title">1.6.1 Lighter is Lighter</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.6.2_Lighter_can_Indeed_Cause_Fires"><div class="tree-item-contents heading-link" heading-name="1.6.2 Lighter can Indeed Cause Fires"><span class="tree-item-title">1.6.2 Lighter can Indeed Cause Fires</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.6.3_Thread-Local_Storage"><div class="tree-item-contents heading-link" heading-name="1.6.3 Thread-Local Storage"><span class="tree-item-title">1.6.3 Thread-Local Storage</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7_Multi-threading_Models"><div class="tree-item-contents heading-link" heading-name="1.7 Multi-threading Models"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.7 Multi-threading Models</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.1_Thread_Types"><div class="tree-item-contents heading-link" heading-name="1.7.1 Thread Types"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.7.1 Thread Types</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.1_李逵和李鬼"><div class="tree-item-contents heading-link" heading-name="1.7.1 李逵和李鬼"><span class="tree-item-title">1.7.1 李逵和李鬼</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.2_Many-to-One_Model"><div class="tree-item-contents heading-link" heading-name="1.7.2 Many-to-One Model"><span class="tree-item-title">1.7.2 Many-to-One Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.3_One-to-One_Model"><div class="tree-item-contents heading-link" heading-name="1.7.3 One-to-One Model"><span class="tree-item-title">1.7.3 One-to-One Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.4_Many-to-Many_Model"><div class="tree-item-contents heading-link" heading-name="1.7.4 Many-to-Many Model"><span class="tree-item-title">1.7.4 Many-to-Many Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.5_Two-Level_Model"><div class="tree-item-contents heading-link" heading-name="1.7.5 Two-Level Model"><span class="tree-item-title">1.7.5 Two-Level Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.6_Scheduler_Activations"><div class="tree-item-contents heading-link" heading-name="1.7.6 Scheduler Activations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.7.6 Scheduler Activations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.6.1_LWPs"><div class="tree-item-contents heading-link" heading-name="1.7.6.1 LWPs"><span class="tree-item-title">1.7.6.1 LWPs</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.6.2_Scheduler_Activations"><div class="tree-item-contents heading-link" heading-name="1.7.6.2 Scheduler Activations"><span class="tree-item-title">1.7.6.2 Scheduler Activations</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.7_Different_Thread_Libraries"><div class="tree-item-contents heading-link" heading-name="1.7.7 Different Thread Libraries"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.7.7 Different Thread Libraries</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.7.1_POSIX_Threads"><div class="tree-item-contents heading-link" heading-name="1.7.7.1 POSIX Threads"><span class="tree-item-title">1.7.7.1 POSIX Threads</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.7.2_Windows_Threads"><div class="tree-item-contents heading-link" heading-name="1.7.7.2 Windows Threads"><span class="tree-item-title">1.7.7.2 Windows Threads</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#1.7.7.3_OS_Independent:_Java_Threads"><div class="tree-item-contents heading-link" heading-name="1.7.7.3 OS Independent: Java Threads"><span class="tree-item-title">1.7.7.3 OS Independent: Java Threads</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#第二课_The_POSIX_Thread"><div class="tree-item-contents heading-link" heading-name="第二课 The POSIX Thread"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 The POSIX Thread</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.1_The_POSIX_Thread:_`pthread`_API"><div class="tree-item-contents heading-link" heading-name="2.1 The POSIX Thread: `pthread` API"><span class="tree-item-title">2.1 The POSIX Thread: <code>pthread</code> API</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2_`pthread`_Management"><div class="tree-item-contents heading-link" heading-name="2.2 `pthread` Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2 <code>pthread</code> Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.1_Create_a_POSIX_Thread:_`pthread_create()`"><div class="tree-item-contents heading-link" heading-name="2.2.1 Create a POSIX Thread: `pthread_create()`"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2.1 Create a POSIX Thread: <code>pthread_create()</code></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.1.1_Start_Routine_and_New_Calling_Thread"><div class="tree-item-contents heading-link" heading-name="2.2.1.1 Start Routine and New Calling Thread"><span class="tree-item-title">2.2.1.1 Start Routine and New Calling Thread</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.2__Join_the_Family:_`pthread_join()`"><div class="tree-item-contents heading-link" heading-name="2.2.2  Join the Family: `pthread_join()`"><span class="tree-item-title">2.2.2  Join the Family: <code>pthread_join()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.3_Exit_a_Thread:_`pthread_exit()`"><div class="tree-item-contents heading-link" heading-name="2.2.3 Exit a Thread: `pthread_exit()`"><span class="tree-item-title">2.2.3 Exit a Thread: <code>pthread_exit()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.4__Detach_from_the_Family:_`pthread_detach()`"><div class="tree-item-contents heading-link" heading-name="2.2.4  Detach from the Family: `pthread_detach()`"><span class="tree-item-title">2.2.4  Detach from the Family: <code>pthread_detach()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.2.5_Yield_a_Thread_Execution:_`pthread_yield()`"><div class="tree-item-contents heading-link" heading-name="2.2.5 Yield a Thread Execution: `pthread_yield()`"><span class="tree-item-title">2.2.5 Yield a Thread Execution: <code>pthread_yield()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.3_Attributes_Control_in_POSIX_Thread"><div class="tree-item-contents heading-link" heading-name="2.3 Attributes Control in POSIX Thread"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3 Attributes Control in POSIX Thread</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.3.1_Structure_of_Thread_Attributes:_`thread_attr_t`"><div class="tree-item-contents heading-link" heading-name="2.3.1 Structure of Thread Attributes: `thread_attr_t`"><span class="tree-item-title">2.3.1 Structure of Thread Attributes: <code>thread_attr_t</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.3.2_Initialize_the_Structure:`pthread_attr_init()`"><div class="tree-item-contents heading-link" heading-name="2.3.2 Initialize the Structure:`pthread_attr_init()`"><span class="tree-item-title">2.3.2 Initialize the Structure:<code>pthread_attr_init()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.3.3_`pthread_attr_destroy()`"><div class="tree-item-contents heading-link" heading-name="2.3.3 `pthread_attr_destroy()`"><span class="tree-item-title">2.3.3 <code>pthread_attr_destroy()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.3.4_Setters_and_Getters"><div class="tree-item-contents heading-link" heading-name="2.3.4 Setters and Getters"><span class="tree-item-title">2.3.4 Setters and Getters</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4_Thread_Cancellation"><div class="tree-item-contents heading-link" heading-name="2.4 Thread Cancellation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.4 Thread Cancellation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.1_Setting_Cancellation_Type"><div class="tree-item-contents heading-link" heading-name="2.4.1 Setting Cancellation Type"><span class="tree-item-title">2.4.1 Setting Cancellation Type</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.2_Cancel_a_Thread:_`pthread_cancel()`"><div class="tree-item-contents heading-link" heading-name="2.4.2 Cancel a Thread: `pthread_cancel()`"><span class="tree-item-title">2.4.2 Cancel a Thread: <code>pthread_cancel()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.3_Create_a_Explicit_Cancellation_Point:_`pthread_testcancel()`"><div class="tree-item-contents heading-link" heading-name="2.4.3 Create a Explicit Cancellation Point: `pthread_testcancel()`"><span class="tree-item-title">2.4.3 Create a Explicit Cancellation Point: <code>pthread_testcancel()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.4_Implicit_Cancellation_Points"><div class="tree-item-contents heading-link" heading-name="2.4.4 Implicit Cancellation Points"><span class="tree-item-title">2.4.4 Implicit Cancellation Points</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.5_Send_Cancellation"><div class="tree-item-contents heading-link" heading-name="2.4.5 Send Cancellation"><span class="tree-item-title">2.4.5 Send Cancellation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.6_Cleanup_Handler"><div class="tree-item-contents heading-link" heading-name="2.4.6 Cleanup Handler"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.4.6 Cleanup Handler</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#2.4.6.1_Cleanup_Handler_Example"><div class="tree-item-contents heading-link" heading-name="2.4.6.1 Cleanup Handler Example"><span class="tree-item-title">2.4.6.1 Cleanup Handler Example</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#第三课_Concurrency_on_Multicore_System"><div class="tree-item-contents heading-link" heading-name="第三课 Concurrency on Multicore System"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Concurrency on Multicore System</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.1_Dark_Age's_Gone"><div class="tree-item-contents heading-link" heading-name="3.1 Dark Age's Gone"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 Dark Age's Gone</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.1.1_Time_Slicing_on_Unicore"><div class="tree-item-contents heading-link" heading-name="3.1.1 Time Slicing on Unicore"><span class="tree-item-title">3.1.1 Time Slicing on Unicore</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.1.2_Time_Slicing_on_Multicore"><div class="tree-item-contents heading-link" heading-name="3.1.2 Time Slicing on Multicore"><span class="tree-item-title">3.1.2 Time Slicing on Multicore</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.2_Parallelism_and_Speedup"><div class="tree-item-contents heading-link" heading-name="3.2 Parallelism and Speedup"><span class="tree-item-title">3.2 Parallelism and Speedup</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.3_Amdahl's_Law"><div class="tree-item-contents heading-link" heading-name="3.3 Amdahl's Law"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.3 Amdahl's Law</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#3.3.1_Formula"><div class="tree-item-contents heading-link" heading-name="3.3.1 Formula"><span class="tree-item-title">3.3.1 Formula</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x._Threads_on_Different_Platform(DO_NOT_READ)"><div class="tree-item-contents heading-link" heading-name="x. Threads on Different Platform(DO NOT READ)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x. Threads on Different Platform(DO NOT READ)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.1_线程和执行流"><div class="tree-item-contents heading-link" heading-name="x.1 线程和执行流"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.1 线程和执行流</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.1.1_为什么用线程？"><div class="tree-item-contents heading-link" heading-name="x.1.1 为什么用线程？"><span class="tree-item-title">x.1.1 为什么用线程？</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.1.2_栈空间的理解"><div class="tree-item-contents heading-link" heading-name="x.1.2 栈空间的理解"><span class="tree-item-title">x.1.2 栈空间的理解</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.2_Thread_in_Different_System"><div class="tree-item-contents heading-link" heading-name="x.2 Thread in Different System"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.2 Thread in Different System</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.2.1_Thread_Model_in_Windows"><div class="tree-item-contents heading-link" heading-name="x.2.1 Thread Model in Windows"><span class="tree-item-title">x.2.1 Thread Model in Windows</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.2.2_Thread_Model_in_Linux"><div class="tree-item-contents heading-link" heading-name="x.2.2 Thread Model in Linux"><span class="tree-item-title">x.2.2 Thread Model in Linux</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3_Threads_in_Modern_C++_:_`std::thread`"><div class="tree-item-contents heading-link" heading-name="x.3 Threads in Modern C++ : `std::thread`"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.3 Threads in Modern C++ : <code>std::thread</code></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.1_No_OS_Specific"><div class="tree-item-contents heading-link" heading-name="x.3.1 No OS Specific"><span class="tree-item-title">x.3.1 No OS Specific</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.2_Crate_a_Thread"><div class="tree-item-contents heading-link" heading-name="x.3.2 Crate a Thread"><span class="tree-item-title">x.3.2 Crate a Thread</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.2_Main_Thread_and_Child_Thread"><div class="tree-item-contents heading-link" heading-name="x.3.2 Main Thread and Child Thread"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.3.2 Main Thread and Child Thread</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.2.1_`join()`"><div class="tree-item-contents heading-link" heading-name="x.3.2.1 `join()`"><span class="tree-item-title">x.3.2.1 <code>join()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.2.2_`detach()`"><div class="tree-item-contents heading-link" heading-name="x.3.2.2 `detach()`"><span class="tree-item-title">x.3.2.2 <code>detach()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.3_Thread_Parameters_Passing"><div class="tree-item-contents heading-link" heading-name="x.3.3 Thread Parameters Passing"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.3.3 Thread Parameters Passing</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.3.1_Pass_by_Value"><div class="tree-item-contents heading-link" heading-name="x.3.3.1 Pass by Value"><span class="tree-item-title">x.3.3.1 Pass by Value</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.3.2_Pass_by_Reference"><div class="tree-item-contents heading-link" heading-name="x.3.3.2 Pass by Reference"><span class="tree-item-title">x.3.3.2 Pass by Reference</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.3.3_Pass_by_Pointer"><div class="tree-item-contents heading-link" heading-name="x.3.3.3 Pass by Pointer"><span class="tree-item-title">x.3.3.3 Pass by Pointer</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#x.3.4&nbsp;Problem_Caused_by_Condition_Race"><div class="tree-item-contents heading-link" heading-name="x.3.4&nbsp;Problem Caused by Condition Race"><span class="tree-item-title">x.3.4&nbsp;Problem Caused by Condition Race</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#第y课_Co-routine(C++20)_/_Go-routine"><div class="tree-item-contents heading-link" heading-name="第y课 Co-routine(C++20) / Go-routine"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第y课 Co-routine(C++20) / Go-routine</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.1_Function_vs._Coroutine"><div class="tree-item-contents heading-link" heading-name="y.1 Function vs. Coroutine"><span class="tree-item-title">y.1 Function vs. Coroutine</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.2_Coroutine_Frame_and_Coroutine_Keywords"><div class="tree-item-contents heading-link" heading-name="y.2 Coroutine Frame and Coroutine Keywords"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">y.2 Coroutine Frame and Coroutine Keywords</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.2.1_Coroutine_Frame"><div class="tree-item-contents heading-link" heading-name="y.2.1 Coroutine Frame"><span class="tree-item-title">y.2.1 Coroutine Frame</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.2.2_Coroutine_Keywords"><div class="tree-item-contents heading-link" heading-name="y.2.2 Coroutine Keywords"><span class="tree-item-title">y.2.2 Coroutine Keywords</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3_Coroutine_Return_Type"><div class="tree-item-contents heading-link" heading-name="y.3 Coroutine Return Type"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">y.3 Coroutine Return Type</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1_Elements_in_`promise_type`"><div class="tree-item-contents heading-link" heading-name="y.3.1 Elements in `promise_type`"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">y.3.1 Elements in <code>promise_type</code></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1.1_`get_return_object`"><div class="tree-item-contents heading-link" heading-name="y.3.1.1 `get_return_object`"><span class="tree-item-title">y.3.1.1 <code>get_return_object</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1.2_`initial_suspend`"><div class="tree-item-contents heading-link" heading-name="y.3.1.2 `initial_suspend`"><span class="tree-item-title">y.3.1.2 <code>initial_suspend</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1.3_`final_suspend`"><div class="tree-item-contents heading-link" heading-name="y.3.1.3 `final_suspend`"><span class="tree-item-title">y.3.1.3 <code>final_suspend</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1.4_`return_void`_or_`return_value`"><div class="tree-item-contents heading-link" heading-name="y.3.1.4 `return_void` or `return_value`"><span class="tree-item-title">y.3.1.4 <code>return_void</code> or <code>return_value</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.1.5_`unhandled_exception`"><div class="tree-item-contents heading-link" heading-name="y.3.1.5 `unhandled_exception`"><span class="tree-item-title">y.3.1.5 <code>unhandled_exception</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.3.2_Trivial_Awaiters"><div class="tree-item-contents heading-link" heading-name="y.3.2 Trivial Awaiters"><span class="tree-item-title">y.3.2 Trivial Awaiters</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.4_Executing_Coroutine_and_Resuming_Coroutine"><div class="tree-item-contents heading-link" heading-name="y.4 Executing Coroutine and Resuming Coroutine"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">y.4 Executing Coroutine and Resuming Coroutine</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.4.1_Executing_a_Coroutine"><div class="tree-item-contents heading-link" heading-name="y.4.1 Executing a Coroutine"><span class="tree-item-title">y.4.1 Executing a Coroutine</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\8.-threads-and-concurrency.html#y.4.2_Resuming_Coroutine"><div class="tree-item-contents heading-link" heading-name="y.4.2 Resuming Coroutine"><span class="tree-item-title">y.4.2 Resuming Coroutine</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>