<!DOCTYPE html> <html><head>
		<title>15. File Systems</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 15. File Systems">
		<meta property="og:title" content="15. File Systems">
		<meta property="og:description" content="Congzhi's Notes Vault - 15. File Systems">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/15.-file-systems.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/ssd.jpg">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c4B::before { padding: 0.683em 0.778em 0px 0px; content: "K"; }
mjx-c.mjx-c46::before { padding: 0.68em 0.653em 0px 0px; content: "F"; }
mjx-c.mjx-c7A::before { padding: 0.431em 0.444em 0px 0px; content: "z"; }
mjx-c.mjx-cD7::before { padding: 0.491em 0.778em 0px 0px; content: "×"; }
mjx-msup { display: inline-block; text-align: left; }
mjx-c.mjx-c4D::before { padding: 0.683em 0.917em 0px 0px; content: "M"; }
mjx-c.mjx-c79::before { padding: 0.431em 0.528em 0.204em 0px; content: "y"; }
mjx-c.mjx-c42::before { padding: 0.683em 0.708em 0px 0px; content: "B"; }
mjx-c.mjx-c73::before { padding: 0.448em 0.394em 0.011em 0px; content: "s"; }
mjx-c.mjx-c38::before { padding: 0.666em 0.5em 0.022em 0px; content: "8"; }
mjx-c.mjx-c36::before { padding: 0.666em 0.5em 0.022em 0px; content: "6"; }
mjx-c.mjx-c1D43A.TEX-I::before { padding: 0.705em 0.786em 0.022em 0px; content: "G"; }
mjx-c.mjx-c1D43E.TEX-I::before { padding: 0.683em 0.889em 0px 0px; content: "K"; }
mjx-c.mjx-c47::before { padding: 0.705em 0.785em 0.022em 0px; content: "G"; }
mjx-c.mjx-c70::before { padding: 0.442em 0.556em 0.194em 0px; content: "p"; }
mjx-c.mjx-c2217::before { padding: 0.465em 0.5em 0px 0px; content: "∗"; }
mjx-c.mjx-c35::before { padding: 0.666em 0.5em 0.022em 0px; content: "5"; }
mjx-c.mjx-c1D45A.TEX-I::before { padding: 0.442em 0.878em 0.011em 0px; content: "m"; }
mjx-c.mjx-c1D45F.TEX-I::before { padding: 0.442em 0.451em 0.011em 0px; content: "r"; }
mjx-c.mjx-c1D460.TEX-I::before { padding: 0.442em 0.469em 0.01em 0px; content: "s"; }
mjx-c.mjx-c1D436.TEX-I::before { padding: 0.705em 0.76em 0.022em 0px; content: "C"; }
mjx-c.mjx-c1D457.TEX-I::before { padding: 0.661em 0.412em 0.204em 0px; content: "j"; }
mjx-c.mjx-c1D456.TEX-I::before { padding: 0.661em 0.345em 0.011em 0px; content: "i"; }
mjx-c.mjx-c1D435.TEX-I::before { padding: 0.683em 0.759em 0px 0px; content: "B"; }
mjx-c.mjx-c1D441.TEX-I::before { padding: 0.683em 0.888em 0px 0px; content: "N"; }
mjx-mtext { display: inline-block; text-align: left; }
mjx-c.mjx-c44::before { padding: 0.683em 0.764em 0px 0px; content: "D"; }
mjx-c.mjx-c65::before { padding: 0.448em 0.444em 0.011em 0px; content: "e"; }
mjx-c.mjx-c61::before { padding: 0.448em 0.5em 0.011em 0px; content: "a"; }
mjx-c.mjx-c64::before { padding: 0.694em 0.556em 0.011em 0px; content: "d"; }
mjx-c.mjx-c6C::before { padding: 0.694em 0.278em 0px 0px; content: "l"; }
mjx-c.mjx-c69::before { padding: 0.669em 0.278em 0px 0px; content: "i"; }
mjx-c.mjx-c6E::before { padding: 0.442em 0.556em 0px 0px; content: "n"; }
mjx-c.mjx-c20::before { padding: 0px 0.25em 0px 0px; content: " "; }
mjx-c.mjx-c54::before { padding: 0.677em 0.722em 0px 0px; content: "T"; }
mjx-c.mjx-c6D::before { padding: 0.442em 0.833em 0px 0px; content: "m"; }
mjx-c.mjx-c2D::before { padding: 0.252em 0.333em 0px 0px; content: "-"; }
mjx-c.mjx-c43::before { padding: 0.705em 0.722em 0.021em 0px; content: "C"; }
mjx-c.mjx-c75::before { padding: 0.442em 0.556em 0.011em 0px; content: "u"; }
mjx-c.mjx-c72::before { padding: 0.442em 0.392em 0px 0px; content: "r"; }
mjx-c.mjx-c74::before { padding: 0.615em 0.389em 0.01em 0px; content: "t"; }
mjx-c.mjx-c53::before { padding: 0.705em 0.556em 0.022em 0px; content: "S"; }
mjx-c.mjx-c63::before { padding: 0.448em 0.444em 0.011em 0px; content: "c"; }
mjx-c.mjx-c6B::before { padding: 0.694em 0.528em 0px 0px; content: "k"; }
mjx-c.mjx-c52::before { padding: 0.683em 0.736em 0.022em 0px; content: "R"; }
mjx-c.mjx-c67::before { padding: 0.453em 0.5em 0.206em 0px; content: "g"; }
mjx-c.mjx-c45::before { padding: 0.68em 0.681em 0px 0px; content: "E"; }
mjx-c.mjx-c78::before { padding: 0.431em 0.528em 0px 0px; content: "x"; }
mjx-c.mjx-c6F::before { padding: 0.448em 0.5em 0.01em 0px; content: "o"; }
mjx-c.mjx-c2C::before { padding: 0.121em 0.278em 0.194em 0px; content: ","; }
mjx-c.mjx-c34::before { padding: 0.677em 0.5em 0px 0px; content: "4"; }
mjx-c.mjx-c37::before { padding: 0.676em 0.5em 0.022em 0px; content: "7"; }
mjx-c.mjx-c30::before { padding: 0.666em 0.5em 0.022em 0px; content: "0"; }
mjx-c.mjx-c220F.TEX-S2::before { padding: 0.95em 1.278em 0.45em 0px; content: "∏"; }
mjx-c.mjx-c1D447.TEX-I::before { padding: 0.677em 0.704em 0px 0px; content: "T"; }
mjx-c.mjx-c2264::before { padding: 0.636em 0.778em 0.138em 0px; content: "≤"; }
mjx-munderover { display: inline-block; text-align: left; }
mjx-munderover:not([limits="false"]) { padding-top: 0.1em; }
mjx-munderover:not([limits="false"]) > * { display: block; }
mjx-msubsup { display: inline-block; text-align: left; }
mjx-script { display: inline-block; padding-right: 0.05em; padding-left: 0.033em; }
mjx-script > mjx-spacer { display: block; }
mjx-c.mjx-c1D70F.TEX-I::before { padding: 0.431em 0.517em 0.013em 0px; content: "τ"; }
mjx-c.mjx-c1D458.TEX-I::before { padding: 0.694em 0.521em 0.011em 0px; content: "k"; }
mjx-c.mjx-c1D450.TEX-I::before { padding: 0.442em 0.433em 0.011em 0px; content: "c"; }
mjx-c.mjx-c1D448.TEX-I::before { padding: 0.683em 0.767em 0.022em 0px; content: "U"; }
mjx-c.mjx-c2211.TEX-S2::before { padding: 0.95em 1.444em 0.45em 0px; content: "∑"; }
mjx-c.mjx-c3C::before { padding: 0.54em 0.778em 0.04em 0px; content: "<"; }
mjx-container[jax="CHTML"] { line-height: 0; }
mjx-container [space="1"] { margin-left: 0.111em; }
mjx-container [space="2"] { margin-left: 0.167em; }
mjx-container [space="3"] { margin-left: 0.222em; }
mjx-container [space="4"] { margin-left: 0.278em; }
mjx-container [space="5"] { margin-left: 0.333em; }
mjx-container [rspace="1"] { margin-right: 0.111em; }
mjx-container [rspace="2"] { margin-right: 0.167em; }
mjx-container [rspace="3"] { margin-right: 0.222em; }
mjx-container [rspace="4"] { margin-right: 0.278em; }
mjx-container [rspace="5"] { margin-right: 0.333em; }
mjx-container [size="s"] { font-size: 70.7%; }
mjx-container [size="ss"] { font-size: 50%; }
mjx-container [size="Tn"] { font-size: 60%; }
mjx-container [size="sm"] { font-size: 85%; }
mjx-container [size="lg"] { font-size: 120%; }
mjx-container [size="Lg"] { font-size: 144%; }
mjx-container [size="LG"] { font-size: 173%; }
mjx-container [size="hg"] { font-size: 207%; }
mjx-container [size="HG"] { font-size: 249%; }
mjx-container [width="full"] { width: 100%; }
mjx-box { display: inline-block; }
mjx-block { display: block; }
mjx-itable { display: inline-table; }
mjx-row { display: table-row; }
mjx-row > * { display: table-cell; }
mjx-mtext { display: inline-block; }
mjx-mstyle { display: inline-block; }
mjx-merror { display: inline-block; color: red; background-color: yellow; }
mjx-mphantom { visibility: hidden; }
mjx-assistive-mml { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; padding: 1px 0px 0px !important; border: 0px !important; display: block !important; width: auto !important; overflow: hidden !important; }
mjx-assistive-mml[display="block"] { width: 100% !important; }
mjx-math { display: inline-block; text-align: left; line-height: 0; text-indent: 0px; font-style: normal; font-weight: normal; font-size: 100%; letter-spacing: normal; border-collapse: collapse; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; direction: ltr; padding: 1px 0px; }
mjx-container[jax="CHTML"][display="true"] { display: block; text-align: center; margin: 1em 0px; }
mjx-container[jax="CHTML"][display="true"][width="full"] { display: flex; }
mjx-container[jax="CHTML"][display="true"] mjx-math { padding: 0px; }
mjx-container[jax="CHTML"][justify="left"] { text-align: left; }
mjx-container[jax="CHTML"][justify="right"] { text-align: right; }
mjx-mi { display: inline-block; text-align: left; }
mjx-c { display: inline-block; }
mjx-utext { display: inline-block; padding: 0.75em 0px 0.2em; }
mjx-mo { display: inline-block; text-align: left; }
mjx-stretchy-h { display: inline-table; width: 100%; }
mjx-stretchy-h > * { display: table-cell; width: 0px; }
mjx-stretchy-h > * > mjx-c { display: inline-block; transform: scaleX(1); }
mjx-stretchy-h > * > mjx-c::before { display: inline-block; width: initial; }
mjx-stretchy-h > mjx-ext { overflow: clip visible; width: 100%; }
mjx-stretchy-h > mjx-ext > mjx-c::before { transform: scaleX(500); }
mjx-stretchy-h > mjx-ext > mjx-c { width: 0px; }
mjx-stretchy-h > mjx-beg > mjx-c { margin-right: -0.1em; }
mjx-stretchy-h > mjx-end > mjx-c { margin-left: -0.1em; }
mjx-stretchy-v { display: inline-block; }
mjx-stretchy-v > * { display: block; }
mjx-stretchy-v > mjx-beg { height: 0px; }
mjx-stretchy-v > mjx-end > mjx-c { display: block; }
mjx-stretchy-v > * > mjx-c { transform: scaleY(1); transform-origin: left center; overflow: hidden; }
mjx-stretchy-v > mjx-ext { display: block; height: 100%; box-sizing: border-box; border: 0px solid transparent; overflow: visible clip; }
mjx-stretchy-v > mjx-ext > mjx-c::before { width: initial; box-sizing: border-box; }
mjx-stretchy-v > mjx-ext > mjx-c { transform: scaleY(500) translateY(0.075em); overflow: visible; }
mjx-mark { display: inline-block; height: 0px; }
mjx-mfrac { display: inline-block; text-align: left; }
mjx-frac { display: inline-block; vertical-align: 0.17em; padding: 0px 0.22em; }
mjx-frac[type="d"] { vertical-align: 0.04em; }
mjx-frac[delims] { padding: 0px 0.1em; }
mjx-frac[atop] { padding: 0px 0.12em; }
mjx-frac[atop][delims] { padding: 0px; }
mjx-dtable { display: inline-table; width: 100%; }
mjx-dtable > * { font-size: 2000%; }
mjx-dbox { display: block; font-size: 5%; }
mjx-num { display: block; text-align: center; }
mjx-den { display: block; text-align: center; }
mjx-mfrac[bevelled] > mjx-num { display: inline-block; }
mjx-mfrac[bevelled] > mjx-den { display: inline-block; }
mjx-den[align="right"], mjx-num[align="right"] { text-align: right; }
mjx-den[align="left"], mjx-num[align="left"] { text-align: left; }
mjx-nstrut { display: inline-block; height: 0.054em; width: 0px; vertical-align: -0.054em; }
mjx-nstrut[type="d"] { height: 0.217em; vertical-align: -0.217em; }
mjx-dstrut { display: inline-block; height: 0.505em; width: 0px; }
mjx-dstrut[type="d"] { height: 0.726em; }
mjx-line { display: block; box-sizing: border-box; min-height: 1px; height: 0.06em; border-top: 0.06em solid; margin: 0.06em -0.1em; overflow: hidden; }
mjx-line[type="d"] { margin: 0.18em -0.1em; }
mjx-mrow { display: inline-block; text-align: left; }
mjx-mn { display: inline-block; text-align: left; }
mjx-msub { display: inline-block; text-align: left; }
mjx-texatom { display: inline-block; text-align: left; }
mjx-c::before { display: block; width: 0px; }
.MJX-TEX { font-family: MJXZERO, MJXTEX; }
.TEX-B { font-family: MJXZERO, MJXTEX-B; }
.TEX-I { font-family: MJXZERO, MJXTEX-I; }
.TEX-MI { font-family: MJXZERO, MJXTEX-MI; }
.TEX-BI { font-family: MJXZERO, MJXTEX-BI; }
.TEX-S1 { font-family: MJXZERO, MJXTEX-S1; }
.TEX-S2 { font-family: MJXZERO, MJXTEX-S2; }
.TEX-S3 { font-family: MJXZERO, MJXTEX-S3; }
.TEX-S4 { font-family: MJXZERO, MJXTEX-S4; }
.TEX-A { font-family: MJXZERO, MJXTEX-A; }
.TEX-C { font-family: MJXZERO, MJXTEX-C; }
.TEX-CB { font-family: MJXZERO, MJXTEX-CB; }
.TEX-FR { font-family: MJXZERO, MJXTEX-FR; }
.TEX-FRB { font-family: MJXZERO, MJXTEX-FRB; }
.TEX-SS { font-family: MJXZERO, MJXTEX-SS; }
.TEX-SSB { font-family: MJXZERO, MJXTEX-SSB; }
.TEX-SSI { font-family: MJXZERO, MJXTEX-SSI; }
.TEX-SC { font-family: MJXZERO, MJXTEX-SC; }
.TEX-T { font-family: MJXZERO, MJXTEX-T; }
.TEX-V { font-family: MJXZERO, MJXTEX-V; }
.TEX-VB { font-family: MJXZERO, MJXTEX-VB; }
mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c { font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A !important; }
@font-face { font-family: MJXZERO; src: url("lib/fonts/mathjax_zero.woff") format("woff"); }
@font-face { font-family: MJXTEX; src: url("lib/fonts/mathjax_main-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-B; src: url("lib/fonts/mathjax_main-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-I; src: url("lib/fonts/mathjax_math-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-MI; src: url("lib/fonts/mathjax_main-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-BI; src: url("lib/fonts/mathjax_math-bolditalic.woff") format("woff"); }
@font-face { font-family: MJXTEX-S1; src: url("lib/fonts/mathjax_size1-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S2; src: url("lib/fonts/mathjax_size2-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S3; src: url("lib/fonts/mathjax_size3-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S4; src: url("lib/fonts/mathjax_size4-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-A; src: url("lib/fonts/mathjax_ams-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-C; src: url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-CB; src: url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-FR; src: url("lib/fonts/mathjax_fraktur-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-FRB; src: url("lib/fonts/mathjax_fraktur-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SS; src: url("lib/fonts/mathjax_sansserif-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSB; src: url("lib/fonts/mathjax_sansserif-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSI; src: url("lib/fonts/mathjax_sansserif-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-SC; src: url("lib/fonts/mathjax_script-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-T; src: url("lib/fonts/mathjax_typewriter-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-V; src: url("lib/fonts/mathjax_vector-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-VB; src: url("lib/fonts/mathjax_vector-bold.woff") format("woff"); }
mjx-c.mjx-c1D445.TEX-I::before { padding: 0.683em 0.759em 0.021em 0px; content: "R"; }
mjx-c.mjx-c3D::before { padding: 0.583em 0.778em 0.082em 0px; content: "="; }
mjx-c.mjx-c28::before { padding: 0.75em 0.389em 0.25em 0px; content: "("; }
mjx-c.mjx-c1D44A.TEX-I::before { padding: 0.683em 1.048em 0.022em 0px; content: "W"; }
mjx-c.mjx-c2B::before { padding: 0.583em 0.778em 0.082em 0px; content: "+"; }
mjx-c.mjx-c1D446.TEX-I::before { padding: 0.705em 0.645em 0.022em 0px; content: "S"; }
mjx-c.mjx-c29::before { padding: 0.75em 0.389em 0.25em 0px; content: ")"; }
mjx-c.mjx-c31::before { padding: 0.666em 0.5em 0px 0px; content: "1"; }
mjx-c.mjx-c1D444.TEX-I::before { padding: 0.704em 0.791em 0.194em 0px; content: "Q"; }
mjx-c.mjx-c3E::before { padding: 0.54em 0.778em 0.04em 0px; content: ">"; }
mjx-c.mjx-c32::before { padding: 0.666em 0.5em 0px 0px; content: "2"; }
mjx-c.mjx-c2E::before { padding: 0.12em 0.278em 0px 0px; content: "."; }
mjx-c.mjx-c1D45B.TEX-I::before { padding: 0.442em 0.6em 0.011em 0px; content: "n"; }
mjx-c.mjx-c2212::before { padding: 0.583em 0.778em 0.082em 0px; content: "−"; }
mjx-c.mjx-c1D443.TEX-I::before { padding: 0.683em 0.751em 0px 0px; content: "P"; }
mjx-c.mjx-c33::before { padding: 0.665em 0.5em 0.022em 0px; content: "3"; }
</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="15. File Systems"><ol start="15">
<li dir="auto">File Systems</li>
</ol></h1><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner">第一遍重写中</div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第一课 Peek into File System" dir="auto" class="heading" id="第一课_Peek_into_File_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课 Peek into File System</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">我们使用计算机，对文件并不陌生。文件有许多不同的格式。在完成程序设计实验中，我们就接触了 <code>.c/.cpp</code> 源代码文件，编译生成 <code>exe</code> 或 <code>elf</code> 格式的可执行文件格式，还有一般实验报告递交的 <code>doc</code> 文件格式。我们的生活离不开这些由文件系统管理的不同类别的文件。此外，文件系统还涉及文件的检索和保护，影响系统的性能和可靠性。对于操作系统，文件系统至关重要。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Persistent Storage" dir="auto" class="heading" id="1.1_Persistent_Storage"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Persistent Storage</h3><div class="heading-children"><div class="el-p"><p dir="auto">内存是计算机的核心部件之一，然而内存并不能提供持久性的存储，内存中的数据信息会由于系统的关闭或掉电而丢失掉。为了避免这种情况，我们需要一种能够在掉电后保证数据的完整性的存储介质。实际上，不易失的存储介质有很多，HDD、SSD、CD等。在文件系统的应用上，现多采用HDD和SSD作为文件系统的存储介质。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 HDD" dir="auto" class="heading" id="1.1.1_HDD"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 HDD</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 SSD" dir="auto" class="heading" id="1.1.2_SSD"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 SSD</h4><div class="heading-children"><div class="el-p"><p dir="auto"><span alt="ssd.jpg" src="ssd.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="ssd.jpg" src="congzhi's-os-series/pics/ssd.jpg"></span></p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.2 File Concept" dir="auto" class="heading" id="1.2_File_Concept"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 File Concept</h3><div class="heading-children"><div class="el-p"><p dir="auto">既然我们说到了文件系统，那我们的话题必然离不开文件。我们时时刻刻在使用着各种各样的文件，那文件是什么？<strong>文件是存储在永久性存储介质上相关数据的集合</strong>。文件可以是常见的文本、照片、视频，还可以是系统配置、代码等信息。文件的功能有：数据存储、数据交换和数据保护等。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241126212945.jpg" src="Pasted image 20241126212945.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241126212945.jpg" src="congzhi's-os-series/pics/pasted-image-20241126212945.jpg"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.2.1 File Metadata" dir="auto" class="heading" id="1.2.1_File_Metadata"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.1 File Metadata</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>文件元数据(File Metadata)</strong>，也被称为<strong>文件属性(File Attributes)</strong>，包含对文件特征的描述信息，文件元数据并不作为文件数据，而是存储在文件系统的目录结构中。常见的文件属性有：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>文件名</strong>：人类可读文件的标识符，区别于其他文件。</li>
<li data-line="1" dir="auto"><strong>文件标识符</strong>：唯一的文件id，与其他文件进行区分。</li>
<li data-line="2" dir="auto"><strong>文件类型</strong>：操作系统需要文件类型信息才能提供相应的支持。</li>
<li data-line="3" dir="auto"><strong>文件路径</strong>：文件在文件系统中的位置。</li>
<li data-line="4" dir="auto"><strong>文件大小</strong>：文件占用存储空间的大小。</li>
<li data-line="5" dir="auto"><strong>时间戳</strong>：记录创建、修改的时间等。</li>
<li data-line="6" dir="auto"><strong>链接计数</strong></li>
<li data-line="7" dir="auto"><strong>文件权限</strong></li>
<li data-line="8" dir="auto"><strong>文件所有者和用户组</strong></li>
<li data-line="9" dir="auto"><strong>访问次数</strong>等。</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.2.2 File Types" dir="auto" class="heading" id="1.2.2_File_Types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2 File Types</h4><div class="heading-children"><div class="el-p"><p dir="auto">通过对文件的类型进行分类，文件可以被分为<strong>普通文件</strong>、<strong>目录文件</strong>、<strong>符号链接文件</strong>、<strong>特殊文件</strong>、<strong>套接字文件</strong>和<strong>管道文件</strong>。</p></div><div class="el-p"><p dir="auto">文件类型是无穷多的，而操作系统并不能直接识别和解析所有类型的文件。虽然操作系统可以识别文件的基本类型（例如，通过文件扩展名或文件头信息），但要打开和正确显示特定类型的文件就需要安装相应的软件。典型的有Java的可执行字节流，这是一种二进制程序文件，但要是系统上没有安装 JVM，操作系统就无法直接运行这些Java字节码文件。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.1 Regular Files" dir="auto" class="heading" id="1.2.2.1_Regular_Files"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.1 Regular Files</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>常规文件</strong>是文件系统中标准的文件类型，也是最常见到的文件类型。常规文件类型包括文本文件、二进制文件、图像文件、音频文件、视频文件等。为了操作系统能够加载并执行程序，所以操作系统必须至少完全支持一种可执行文件类型。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.2 Directories" dir="auto" class="heading" id="1.2.2.2_Directories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.2 Directories</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>目录文件(directory files)</strong> 是一类特殊的文件，它记录着<strong>文件目录(file directories)</strong> 的信息。文件目录不仅仅包含数据，也包括对其他文件和子目录的引用。在 Linux 中，目录文件会被标注<code>d</code>属性，说明这个文件的内容实则是一个目录项清单，可用<code>ls "directory file name"</code>命令查看这个清单。</p></div><div class="el-p"><p dir="auto">一般而言，目录文件中的内容我们一般是无法查看的，但我们可用通过<code>ls</code>命令来列出目录文件中引用的文件，也可用<code>cd</code>命令来进入目录文件记录的文件目录中。</p></div><div class="el-pre"><pre><code data-line="0">du@du-virtual-machine:~/Desktop/OS$ ls -alh
total 136K
drwxrwxr-x 3 du du 4.0K  8月 23 00:50 .
drwxr-xr-x 7 du du 4.0K  8月  8 05:09 ..
drwxrwxr-x 2 du du 4.0K  7月  1 00:51 a_file_dir
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>d</code>属性就表示这是一个目录文件。<strong>文件目录以目录文件的显示存储在磁盘上</strong>。我们可以通过<code>tree</code>命令以树状结构显示目标目录及其子目录中的所有文件和目录。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.3 Symbolic Links" dir="auto" class="heading" id="1.2.2.3_Symbolic_Links"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.3 Symbolic Links</h5><div class="heading-children"><div class="el-p"><p dir="auto">符号链接实际上就是软连接(soft link)，之后再介绍文件目录的时候会提到。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.4 Special Files" dir="auto" class="heading" id="1.2.2.4_Special_Files"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.4 Special Files</h5><div class="heading-children"></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.5 Sockets" dir="auto" class="heading" id="1.2.2.5_Sockets"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.5 Sockets</h5><div class="heading-children"><div class="el-p"><p dir="auto">套接字和FIFO文件在IPC的阶段<a data-href="7. Inter-Process Communication" href="congzhi's-os-series/7.-inter-process-communication.html" class="internal-link" target="_self" rel="noopener nofollow">7. Inter-Process Communication</a>里我们已经了解过了。虽然它们的地位较为显赫，但此处不做赘述。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2.2.6 FIFO(Named Pipes)" dir="auto" class="heading" id="1.2.2.6_FIFO(Named_Pipes)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2.6 FIFO(Named Pipes)</h5><div class="heading-children"></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.3 File System Structure Design" dir="auto" class="heading" id="1.3_File_System_Structure_Design"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 File System Structure Design</h3><div class="heading-children"><div class="el-p"><p dir="auto">在用户眼中，文件系统为我们提供了许多的便利，通过系统为我们提供的窗口（如：<code>open()</code>等的系统调用），用户并不需要了解这一切是怎么实现的。然而，负责文件系统结构设计的系统设计人员要做的可就多了。接下来，让我们从宏观的角度一层一层地了解下文件系统结构的设计。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240824180225.png" src="Pasted image 20240824180225.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240824180225.png" src="congzhi's-os-series/pics/pasted-image-20240824180225.png"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.1 I/O Control" dir="auto" class="heading" id="1.3.1_I/O_Control"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.1 I/O Control</h4><div class="heading-children"><div class="el-p"><p dir="auto">文件都是存放在磁盘上的，文件系统的职责是把各种各样的信息数据存放到非易失的存储介质上面。作为I/O设备，我们知道用户任何的请求都会转换成控制磁盘I/O的低级硬件指令交给I/O控制器处理。I/O控制层会收到basic file system layer的高级指令（如：read disk block 1），然后将其转换成磁盘能够理解的指令。又由于外设的低速性，我们对磁盘的操作一般是DMA的I/O控制方式。</p></div><div class="el-p"><p dir="auto">具体来说，应用程序先是发出读文件的请求，这些请求经过层次转换到磁盘驱动程序将转换后的磁盘控制器命令交给CPU，然后CPU下达DMA控制操作，DMA控制器直接在内存和磁盘之间传输数据，而不需要CPU的持续干预。这种方式大大提高了数据传输效率，减少了CPU的负担。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.2 Basic File System Layer" dir="auto" class="heading" id="1.3.2_Basic_File_System_Layer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2 Basic File System Layer</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>基本文件系统</strong>负责与硬件交互，是文件系统中开始与硬盘硬件对接的层次。它会向磁盘驱动程序发布指定扇区的读写命令，之后由磁盘控制器驱动程序将命令传给磁盘控制器，控制器执行并返回结果，最终将结果交给操作系统。在这一层次中，对文件的操作是在物理磁盘上的，类似于磁盘1、12号柱面、7号磁道、1号扇区这样精确的磁盘访问请求就发生在这个层次。</p></div><div class="el-p"><p dir="auto">由于磁盘访问的低速，在系统中实际上存在了许多buffers和caches来应对访问磁盘带来的开销。所以在这一层次，我们还需要考虑这些系统中存在的buffers和caches。只有当前要访问的数据不在这些buffers/caches中时，我们才需要考虑访问磁盘。也因此，我们需要承担突然断电时带来的数据丢失问题。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.3 File Organization Module" dir="auto" class="heading" id="1.3.3_File_Organization_Module"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.3 File Organization Module</h4><div class="heading-children"><div class="el-p"><p dir="auto">用户总希望自己的文件在系统中是连续存放的，正如我们之前学习虚拟存储技术时了解过的一样，即便我们看到的文件是连续的，但文件在磁盘上的存储块不一定是连续的。因此我们需要一个模块将逻辑块转换成底层硬件能够识别的物理块。</p></div><div class="el-p"><p dir="auto">这种逻辑到物理上的转换就是由<strong>文件组织模块(File organization module)</strong>，也叫<strong>块管理器</strong>提供的。它是一个映射器(mapper)，将逻辑块地址映射成物理块地址。文件组织模块维护一个映射表，将文件的逻辑块转换为磁盘上的物理块地址，同时它也管理空闲空间列表，用于跟踪为分配的物理块。</p></div><div class="el-p"><p dir="auto">除此，这一模块还负责空闲空间的管理，我们之后介绍。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.4 Logical File System Layer" dir="auto" class="heading" id="1.3.4_Logical_File_System_Layer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.4 Logical File System Layer</h4><div class="heading-children"><div class="el-p"><p dir="auto">对于用户而言，一个屏蔽底层硬件、简单、易操作的交互接口和能够对文件的属性进行方便管理的接口是ta们最想要的。而这个为用户提供方便接口的文件系统层次就由<strong>逻辑文件系统(Logical file system)</strong> 所提供。</p></div><div class="el-p"><p dir="auto">逻辑文件系统负责管理文件的元数据。管理文件路径解析、文件描述符、权限检查等，并提供文件的操作接口（打开、创建、读和写）为用户使用，用户可以用系统调用（open/read/write等）与该层次交互。该层次也支持对文件的逻辑访问（逻辑上的文件）。</p></div><div class="el-p"><p dir="auto">文件的元数据存放在一个叫<strong>文件控制块</strong>的东西里面，即<strong>FCB</strong>，在Unix中，文件控制块也叫<strong>inode</strong>。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.4 Disk Organization" dir="auto" class="heading" id="1.4_Disk_Organization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4 Disk Organization</h3><div class="heading-children"><div class="el-p"><p dir="auto">文件系统非常多，我们有UFS、AFS、ZFS、NTFS、ext2/3/4、FAT32/64等等。这些文件系统各有不同，但是总有一些共同点，比如跟踪磁盘块的个数，多少个空闲块，多少个已被占用的块；还要管理文件目录的结构和各种文件。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.1 Space Layout" dir="auto" class="heading" id="1.4.1_Space_Layout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.1 Space Layout</h4><div class="heading-children"><div class="el-p"><p dir="auto">在<a data-href="5. System Boots Up" href="congzhi's-os-series/5.-system-boots-up.html" class="internal-link" target="_self" rel="noopener nofollow">5. System Boots Up</a>阶段中，我们谈到了计算机上电启动的一些内容。要使计算机正常启动，我们至少需要一块磁盘分区(volume)来存放操作系统的相关数据。我们谈到了磁盘分区上的第一个扇区，也叫启动扇区(boot sector)。当我们将视线放宽到整个volume，我们会看到：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>引导区(Boot block)</strong>：包含启动代码和磁盘信息，有MBR和GPT的实现方式。</li>
<li data-line="1" dir="auto"><strong>目录区(Directory area, FCB)</strong>：一级、二级、树形等目录实现方式。</li>
<li data-line="2" dir="auto"><strong>空闲空间表(Free space table)</strong>：管理数据区，有位图、空闲链表、成组链接等实现方式。</li>
<li data-line="3" dir="auto"><strong>数据区(Data area)</strong>：连续、链接、索引等实现方式。</li>
</ul></div><div class="el-p"><p dir="auto">在FAT的课程中，我们会结合FAT文件系统来进行介绍。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.2 Disk Partitioning" dir="auto" class="heading" id="1.4.2_Disk_Partitioning"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.2 Disk Partitioning</h4><div class="heading-children"><div class="el-p"><p dir="auto">除了将一块磁盘一整块地使用，我们还可以逻辑上将磁盘分成若干个不同的区块来使用，这种方法也被称为磁盘分区。我们学习过 MBR 和 GPT 两种磁盘分区的方式。简单来说，磁盘分区就是在存储设备上创建一个或多个独立区域的过程，每个区域都可以作为独立的逻辑磁盘被管理使用。</p></div><div class="el-p"><p dir="auto">为了管理这些不同的分区，我们需要一个<strong>分区表(partition table)</strong>，有时也被称为<strong>超级块(super block)</strong> 或 <strong>master file table</strong>。分区的相关信息就记录在分区表中，这些信息有开始和结束位置、分区类型和大小等。</p></div><div class="el-p"><p dir="auto">在Windows中，磁盘分区常常与盘符相关联，每一个分区对应一个盘符（如 <code>C:</code> 、<code>D:</code>、<code>E:</code>等）。虽然一个物理磁盘可以分出多个盘符，但通常而言，一个物理磁盘我们当成一个分区使用。而在Linux系统中，磁盘通常会被分成多个分区，每个分区有不同的用途。例如，根分区（<code>/</code>）、引导分区（<code>/boot</code>）、交换分区（<code>swap</code>）等。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.3 Review: MBR &amp; GPT" dir="auto" class="heading" id="1.4.3_Review:_MBR_&amp;_GPT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.3 Review: MBR &amp; GPT</h4><div class="heading-children"><div class="el-p"><p dir="auto">磁盘分区表的位置和大小会随着分区方式的不同而不同。我们学习过 MBR 和 GPT 两种分区模式。我们下面介绍这两种方式分区表存放位置。</p></div><div class="el-p"><p dir="auto"><strong>主引导记录</strong>存放在磁盘的第一号扇区中，它包含了引导代码和分区表。MBR的大小通常为512字节，其中的bootloader占据446字节，分区表占据64字节。但如果系统采用 GPT 的分区方式，第一号扇区的大小就可能是 4KB 大小。</p></div><div class="el-p"><p dir="auto"><strong>GPT(GUID Partition Table)</strong>：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>LBA0</strong>：为了保证向下兼容，第一个扇区 LBA0 存放保护性 MBR。</li>
<li data-line="1" dir="auto"><strong>LBA1</strong>：存放 GPT header。</li>
<li data-line="2" dir="auto"><strong>LBA2-LBA34</strong>：存放GPT分区条目数组（即GPT分区表）。</li>
<li data-line="3" dir="auto"><strong>磁盘末尾</strong>：分区表的备份。</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.5 Virtual File System" dir="auto" class="heading" id="1.5_Virtual_File_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5 Virtual File System</h3><div class="heading-children"><div class="el-p"><p dir="auto">和我们在一台电脑上可以安装多个操作系统一样，我们同样可以在操作系统上安装多个文件系统。但是每个分区只能有一个文件系统。多个分区我们可以有很多文件系统的话，问题就来了。在用户程序中我们使用的是统一的系统调用。当我们用统一接口的系统调用接口访问不同分区（文件系统）中的文件时，如何保证文件的正确访问？</p></div><div class="el-p"><p dir="auto">我们的解决方案是：增加一层抽象：<strong>虚拟文件系统</strong>。我们将不同的文件系统统一交给VFS进行管理。VFS是文件系统之上的一层内核软件层，用于处理 POSIX 文件系统相关的系统调用，给各种不同的文件系统提供统一的操作接口，使得应用程序可以不必关心底层使用哪个文件系统。用户程序可以通过统一的接口来访问不同分区（文件系统）中的文件，而不会遇到兼容性问题。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240824184231.png" src="Pasted image 20240824184231.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240824184231.png" src="congzhi's-os-series/pics/pasted-image-20240824184231.png"></span></p></div><div class="el-p"><p dir="auto">VFS的作用有两个。一个是上面我们所提到的，无所谓下面文件系统是怎么实现的，我们都可以通过VFS提供的统一接口来对文件进行操作。另一个是将系统中全部的文件进行唯一化标识。VFS通过使用 vnode 数据结构来唯一标识系统中的所有文件。</p></div><div class="el-p"><p dir="auto">在传统文件系统中，FCB用于在分区内唯一标识文件，但在不同的分区中，FCB的唯一性无法得到保证。VFS通过 vnode 数据结构解决了这个问题，每个文件对应一个唯一的 vnode，使得即使在不同文件系统甚至在remote file system中，文件也能够被唯一标识。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 File System Operations" dir="auto" class="heading" id="第二课_File_System_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 File System Operations</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 Basic File Operations" dir="auto" class="heading" id="2.1_Basic_File_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 Basic File Operations</h3><div class="heading-children"><div class="el-p"><p dir="auto">对于文件，我们有很多操作，如创建文件、读文件、写文件、移动文件指针的位置(repositioning)、删除文件和文件的截断(truncation)。文件系统为我们提供了这些基本的文件操作的系统调用，下面我们来一起看一看。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.1 Opening and Closing Files" dir="auto" class="heading" id="2.1.1_Opening_and_Closing_Files"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1 Opening and Closing Files</h4><div class="heading-children"><div class="el-p"><p dir="auto">当你对文件进行操作，你需要使用文件描述符(file descriptor)来对文件进行操作。在POSIX系统调用<code>open()</code>中，<code>open()</code>会返回给我们一个fd。而在C标准库中，我们会使用<code>fopen()</code>，其会返回一个指向<code>FILE</code>结构的指针。你可以用<code>int fd = fileno(f);</code>将FILE转换成fd。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// Use C standard library opening a file.</span>
FILE<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to open the file %s.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* Read the file.*/</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>

<span class="token comment">/*
Mode options in fopen() function:
r  : Open the file for reading only.(File must exist, or return NULL.)
w  : Create the file for writing. If file exist, it's overwritten.
a  : Open the file, writing data at the end of the file.(a for append)
r+ : Open for read and update.(File must exist, or return NULL.)
w+ : Create the file for reading/writing. If file exist, it's overwritten.
a+ : Same as above, but in rw mode.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span> <span class="token comment">// For open(), O_RDONLY, O_WRONLY, O_RDWR, and file access modes</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span><span class="token comment">// For close(), read(), write(), fsync(), lseek(), and others.</span></span>

<span class="token comment">// Use POSIX system call opening a file.</span>
<span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Unable to open the file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* Read the file.*/</span>
<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">以上是两种打开文件的形式，第一种使用C标准库，提供了一种更高级易用的接口，而底下我们使用POSIX系统调用，相比之下更为直接，但是不够user friendly。因为，用户并不知情FILE实际上是一个整数。我们之后会了解到，文件描述符是一个表示打开文件的整数。</p></div><div class="el-p"><p dir="auto">以下是打开和关闭文件的POSIX系统调用原型函数：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span> <span class="token comment">// For open(), O_RDONLY, O_WRONLY, O_RDWR, and file access modes</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span><span class="token comment">// For close(), read(), write(), fsync(), lseek(), and others.</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> <span class="token comment">// For data types used in some system calls</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span>  <span class="token comment">// For file status and mode information</span></span>

<span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. pathname: Pointer to the name of the file to be opened.
2. flags: File access modes and other flags.
   Common flags:
   - O_RDONLY: Open for reading only.
   - O_WRONLY: Open for writing only.
   - O_RDWR: Open for reading and writing.
   - O_CREAT: Create the file if it does not exist.
   - O_EXCL: Ensure that this call creates the file (fails if the file exists).
   - O_NOCTTY: If the pathname refers to a terminal, do not make it the controlling terminal.
   - O_TRUNC: Truncate the file to zero length if it already exists and is opened for writing.
   - O_APPEND: Open the file in append mode.
   - O_NONBLOCK: Open the file in non-blocking mode.
   - O_DSYNC: Write operations will complete according to the requirements of synchronized I/O data integrity completion.
   - O_SYNC: Write operations will complete according to the requirements of synchronized I/O file integrity completion.
   - O_RSYNC: Synchronize read operations.
   - O_DIRECT: Minimize or eliminate cache effects of the I/O to and from this file.

Return value: Returns a file descriptor on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to be closed.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.2 Seek the Route" dir="auto" class="heading" id="2.1.2_Seek_the_Route"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.2 Seek the Route</h4><div class="heading-children"><div class="el-p"><p dir="auto">以下是读写文件和移动文件指针的 POSIX 系统调用。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file.
2. offset: Offset to set the file position to.
3. whence: Starting point for the offset (SEEK_SET, SEEK_CUR, SEEK_END).

Return value: Returns the resulting offset location on success, otherwise -1.
*/</span>

<span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to read from.
2. buf: Buffer where the read data will be stored.
3. count: Number of bytes to read.

Return value: Returns the number of bytes read on success, otherwise -1.
*/</span>

<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to write to.
2. buf: Buffer containing the data to be written.
3. count: Number of bytes to write.

Return value: Returns the number of bytes written on success, otherwise -1.
*/</span>

<span class="token keyword">int</span> <span class="token function">fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to be synchronized.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.3 Delete" dir="auto" class="heading" id="2.1.3_Delete"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.3 Delete</h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>remove</code> 函数和 <code>unlink</code> 函数在删除文件时的行为是相同的。当我们使用 <code>remove</code> 或 <code>unlink</code> 删除文件时，实际上是删除了文件系统中的一个硬链接。如果文件有多个硬链接，只有指定的那个链接会被删除，文件的内容仍然存在，直到所有的硬链接都被删除为止。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. filename: Pointer to a null-terminated string that specifies the name of the file to be deleted.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. pathname: Pointer to a null-terminated string that specifies the name of the file to be deleted.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.2 File Control Block" dir="auto" class="heading" id="2.2_File_Control_Block"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 File Control Block</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们用文件描述符来对文件进行操作。而fd只是一个整型数，实际上并不能唯一的标识一个文件。就相当于厕所隔间里面的人，在某一刻，你能够确定厕所里就是这个人，你用xx号厕所来标识这个人，但是当这个人离开厕所，这个文件描述符将会失效。即在不同时刻，不同的文件可能使用相同的fd。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.1 FCB" dir="auto" class="heading" id="2.2.1_FCB"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1 FCB</h4><div class="heading-children"><div class="el-p"><p dir="auto">在第一节课，我们提到了文件的元数据，相当于文件的各种信息，这些信息被存储在<strong>文件控制块</strong>中。操作这些文件的创建修改删除是logical file system layer的工作。当我们要创建一个新的文件，对应着的，一个文件控制块也会随之被创建。系统内，每个文件的文件控制块都是唯一的。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241127205724.jpg" src="Pasted image 20241127205724.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241127205724.jpg" src="congzhi's-os-series/pics/pasted-image-20241127205724.jpg"></span></p></div><div class="el-p"><p dir="auto">当用户想要读取系统中的某个文件时，操作系统就会把文件的文件控制块加载进内存。由于文件控制块中有文件的元数据，所以系统可以根据文件控制块中文件在磁盘上的位置来加载文件信息。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.2 Inode" dir="auto" class="heading" id="2.2.2_Inode"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.2 Inode</h4><div class="heading-children"><div class="el-p"><p dir="auto">Inode实际上就是类Unix系统中的文件控制块。我们将在后续ext文件系统的学习中进行介绍。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.3 Caching in File System" dir="auto" class="heading" id="2.3_Caching_in_File_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 Caching in File System</h3><div class="heading-children"><div class="el-p"><p dir="auto">由于文件系统要频繁地与磁盘进行交互，为了提升存储的性能，我们当然的会想到局部性原理，即caching来提升性能。实际上，文件系统的确有很多caching策略指导的结构。我们有：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Mount Table</li>
<li data-line="1" dir="auto">Cache</li>
<li data-line="2" dir="auto">Global Open File Table</li>
<li data-line="3" dir="auto">Process Open File Table</li>
<li data-line="4" dir="auto">Buffers</li>
</ul></div><div class="el-p"><p dir="auto">为了避免频繁的访问I/O，这些文件系统的结构会被加载进内存中。我们将用演示文件的操作过程演示打开文件表是如何提高系统的效率的。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.1 Open-File Table" dir="auto" class="heading" id="2.3.1_Open-File_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1 Open-File Table</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们之前说，进程想要操作文件，就需要FCB中的信息。FCB载入内存需要我们使用<code>open()</code>系统调用，但之前，我们看到<code>open</code>系统调用返回的是fd，和FCB有什么关系？我们接着看。当进程打开文件时，OS就会在<strong>进程打开文件表</strong>里添加一个新表项。之后，操作系统会检查<strong>系统级打开文件表</strong>，如果没有找到关于该文件的表项，OS就会创建新的系统打开文件表项来跟踪文件的FCB。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241128230955.jpg" src="Pasted image 20241128230955.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241128230955.jpg" src="congzhi's-os-series/pics/pasted-image-20241128230955.jpg"></span><br>
进程打开文件表中存放着系统打开文件表表项的一个索引（<code>fd</code>），便于进程可以通过这个索引找到全局的系统打开文件表里面的表项，进一步对文件进行操作。进程打开文件表每个进程都有一张，每一个条目都对应着进程打开的文件和指向系统级打开文件表的指针，一般而言，进程打开文件表项数为1024，当然你可以将其设置的更高。<code>include/linux/fdtable.h</code></p></div><div class="el-p"><p dir="auto">当FCB加载到内存中后，系统用系统打开文件表对FCBs进行管理，系统打开文件表整个系统只有一张。系统打开文件表项的数据有<strong>文件名</strong>、<strong>文件打开方式</strong>、<strong>文件偏移量</strong>、<strong>文件的引用计数</strong>和<strong>FCB指针</strong>等信息。<code>include/linux/fs.h</code></p></div><div class="el-p"><p dir="auto"><code>open</code>文件调用会返回一个指向进程打开文件表中一个特定表项的索引，我们称其为文件描述符/文件句柄（unix中叫做file descriptor，而在windows中叫file handle）。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.2 Where FCBs Went?" dir="auto" class="heading" id="2.3.2_Where_FCBs_Went?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.2 Where FCBs Went?</h4><div class="heading-children"><div class="el-p"><p dir="auto">当进程要访问文件时，系统会根据文件的目录在磁盘上找到该文件的文件控制块。之后，将所需要的FCB都缓存在内核内存的<strong>FCB表/Inode表</strong>。然后系统在系统打开文件表中由相关的系统调用信息和FCB信息创建新的表项，其中有文件的一些元数据和一些其他信息。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018011136.png" src="Pasted image 20241018011136.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018011136.png" src="congzhi's-os-series/pics/pasted-image-20241018011136.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.3 Open a File" dir="auto" class="heading" id="2.3.3_Open_a_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.3 Open a File</h4><div class="heading-children"><div class="el-p"><p dir="auto">当我们使用<code>open("example.txt", O_RDONLY);</code>时会发生以下情况：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">进程调用 <code>open("example.txt", O_RDONLY)</code>。<br>
2. 操作系统检查系统级打开文件表，发现 "example.txt" 已经被打开。<br>
3. 在进程级打开文件表中增加一个条目，指向系统级打开文件表中的 "example.txt" 条目，然后在全局的系统打开文件表中对文件的引用计数加一。<br>
4. 返回文件描述符 fd，指向进程级打开文件表中新增加的条目。</li>
<li data-line="4" dir="auto">操作系统检查系统级打开文件表，发现没有打开 "example.txt" 条目</li>
<li data-line="5" dir="auto">在磁盘目录中搜索 "example.txt"，如果找到了，那就在系统级打开文件表增加一个条目，将FCB加载到FCB表中，初始打开文件表项。最后将系统的打开文件表中对文件的引用计数设置为1。</li>
<li data-line="6" dir="auto">增加该进程级代开文件表的条目，用指针指向系统级打开文件表的对应条目。</li>
<li data-line="7" dir="auto">返回文件描述符 fd，指向进程级打开文件表中新增加的条目。</li>
</ol></div><div class="el-p"><p dir="auto">在打开文件表中，除了文件的一些元数据外，还要存储文件<strong>引用计数信息</strong>，即这个文件被系统内的进程打开了多少次。每当使用<code>open()</code>或<code>close()</code>系统调用时，这个数值就会发生改变。只要不为0，该文件的元数据就会一直保留在内存的内核区中。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.4 Relationship Between FDs and OFDs" dir="auto" class="heading" id="2.3.4_Relationship_Between_FDs_and_OFDs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.4 Relationship Between FDs and OFDs</h4><div class="heading-children"><div class="el-p"><p dir="auto">实际上，多个<strong>FD(file descriptor)</strong> 是可用指向相同的<strong>OFD(open file table descriptor)</strong>。像如下fd1和fd20都指向偏移为23的OFD（用<code>dup2()</code>复制文件描述符），还有两个进程的fd2都指向偏移为73的OFD（用<code>fork()</code>创建新的子进程）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018011136.png" src="Pasted image 20241018011136.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018011136.png" src="congzhi's-os-series/pics/pasted-image-20241018011136.png"></span></p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.4.1 Different Behaviors of Different FDs" dir="auto" class="heading" id="2.3.4.1_Different_Behaviors_of_Different_FDs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.4.1 Different Behaviors of Different FDs</h5><div class="heading-children"><div class="el-p"><p dir="auto">偏移为0的OFD和偏移为86的OFD指向的却是同一个Inode。为什么？这可能是因为<strong>两个进程都独立的打开同一个文件。当不同文件描述符的行为不同时，即使多个文件描述符指向同一个文件，每个文件描述符的行为可能因为其具体的使用方式和上下文而有所不同。</strong></p></div><div class="el-p"><p dir="auto">比如两个文件描述符维护不同的<strong>文件偏移量</strong>或是<strong>不同的文件状态标志</strong>，就会出现多个OFD却指向同一个inode的情况。（说的简单一点就是数据结构不再相同了）</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.4.2 Duplicating FDs (`dup(fd)` and `dup2(origfd, newfd)`)" dir="auto" class="heading" id="2.3.4.2_Duplicating_FDs_(`dup(fd)`_and_`dup2(origfd,_newfd)`)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.4.2 Duplicating FDs (<code>dup(fd)</code> and <code>dup2(origfd, newfd)</code>)</h5><div class="heading-children"></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.4.3 Retrieving and Modifing FDs using `fcntl()`" dir="auto" class="heading" id="2.3.4.3_Retrieving_and_Modifing_FDs_using_`fcntl()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.4.3 Retrieving and Modifing FDs using <code>fcntl()</code></h5><div class="heading-children"></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Directory" dir="auto" class="heading" id="第三课_Directory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Directory</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">提到目录，大家都不会陌生。在小学一年级，老师就教过我们用字典目录去查汉字，拿到新的语文课本，我们可能会翻阅目录寻找自己感兴趣的文章去阅读。和”目录“这么久的交情，我们不难给目录下一个定义：<strong>目录是一张对内容编排和组织的表，便于我们更好的找到特定的内容</strong>。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 File Directory" dir="auto" class="heading" id="3.1_File_Directory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 File Directory</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>文件目录</strong>就是一张编排组织文件的表（数据结构），便于用户查找相关的文件信息。文件目录容纳其他文件和目录（文件夹），将这些文件和文件夹用某种结构组织起来。有了这种组织，文件和目录管理起来就更加便捷。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.1 Directory Operations" dir="auto" class="heading" id="3.1.1_Directory_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 Directory Operations</h4><div class="heading-children"><div class="el-p"><p dir="auto">对于文件目录，文件系统需要支持关于目录的很多操作。最基础的就是用文件名来<strong>遍历查找文件</strong>，这是目录最基本的作用。此外，我们还想知道目录下有哪些文件，所以我们需要支持<strong>列出目录文件</strong>的功能。要查找文件，我们就得先创建文件，所以还需要支持文件的<strong>创建</strong>、<strong>删除</strong>和<strong>文件名的修改</strong>。</p></div><div class="el-p"><p dir="auto">在命令行下，我们能见到很多目录相关的命令，例如：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">查找文件<code>find</code>、<code>locate</code></li>
<li data-line="1" dir="auto">创建文件<code>touch</code></li>
<li data-line="2" dir="auto">删除文件<code>rm</code></li>
<li data-line="3" dir="auto">显示当前目录<code>pwd</code></li>
<li data-line="4" dir="auto">列出目录文件<code>ls</code></li>
<li data-line="5" dir="auto">文件重命名<code>mv</code>、<code>rename</code></li>
<li data-line="6" dir="auto">创建目录<code>mkdir</code></li>
<li data-line="7" dir="auto">删除目录<code>rmdir</code>、<code>rm -r</code></li>
<li data-line="8" dir="auto">切换目录<code>cd</code></li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.2 Directory and FCB" dir="auto" class="heading" id="3.1.2_Directory_and_FCB"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.2 Directory and FCB</h4><div class="heading-children"><div class="el-p"><p dir="auto">文件的元数据存放在FCB中，文件系统通过FCB来实际控制管理一个文件；而目录是编排组织文件的表，通过目录中对相关文件的指针索引，实际上让我们得以访问对应文件的FCB，从而获取文件的详细信息并进行操作。文件目录以目录文件的形式存储在磁盘上，目录文件存储着系统目录的数据结构信息。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.2 Directory Structure" dir="auto" class="heading" id="3.2_Directory_Structure"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 Directory Structure</h3><div class="heading-children"><div class="el-p"><p dir="auto">为了更好的组织、管理和访问文件，我们选用很多数据结构对文件目录进行记录。以下我们介绍几种构建文件目录时常见的目录形式。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.1 Single-Level Directories" dir="auto" class="heading" id="3.2.1_Single-Level_Directories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1 Single-Level Directories</h4><div class="heading-children"><div class="el-p"><p dir="auto">单级目录是最简单的目录结构，所有的文件都放在同一个根目录下。由于这种结构将所有文件放在一起，所以单级目录要求所有文件名必须是唯一的。这种结构是实现起来最简单的，但是文件的命名唯一而且对文件缺少归纳。导致这种目录管理文件就是一摊鸡毛。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202010255.jpg" src="Pasted image 20241202010255.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202010255.jpg" src="congzhi's-os-series/pics/pasted-image-20241202010255.jpg"></span></p></div><div class="el-p"><p dir="auto">在单级目录结构下，没有文件路径的概念。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.2 Two-Level Directories" dir="auto" class="heading" id="3.2.2_Two-Level_Directories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.2 Two-Level Directories</h4><div class="heading-children"><div class="el-p"><p dir="auto">在二级目录结构中，我们有一个主文件目录和子文件目录(sub-directories)。主文件目录可以向下级的用户文件目录提供索引。从而，每个用户可以拥有自己独立的目录来存储和管理文件。解决了一些单级目录中命名冲突问题，并为不同用户提供了文件隔离性。</p></div><div class="el-p"><p dir="auto">从二级目录结构开始，文件路径有了意义，每个文件的文件路径(file pathname)在系统中都是唯一的。在引用文件时，如果确定当前的工作目录（用户目录），我们检索不包括用户名的文件时，操作系统会假设文件位于当前的工作目录下。这种不包含文件路径的路径名就是文件相对路径。</p></div><div class="el-p"><p dir="auto">而绝对路径是指从根目录开始的完整路径，它包含了从根目录到目标文件或目录的所有目录名。例如，<code>/user1/cat</code> 就是一个绝对路径。无论当前工作目录是什么，通过绝对路径都可以唯一地定位到目标文件或目录。</p></div><div class="el-p"><p dir="auto">在用户的目录下，用户无法创建新的目录来对文件进行进一步的归类。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202010304.jpg" src="Pasted image 20241202010304.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202010304.jpg" src="congzhi's-os-series/pics/pasted-image-20241202010304.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.3 Tree-Structured Directories" dir="auto" class="heading" id="3.2.3_Tree-Structured_Directories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.3 Tree-Structured Directories</h4><div class="heading-children"><div class="el-p"><p dir="auto">树形目录是二级目录结构的升级版，树形结构目录允许子目录创建条目的子目录树，从而消除了文件不能归类的问题。整个目录树有一个根目录，所有的文件或目录都会有包含root的唯一路径名。树形结构为系统带来了更好的灵活性和可变性，在树型结构中，进程可以从一个目录下“跳跃”到另一个目录，也因而，相对目录通常上性能更好（减少了“跳跃”的动作）。在Linux下，我们用"<code>.</code>"来指代当前目录（如.<code>/hello</code>）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202010310.jpg" src="Pasted image 20241202010310.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202010310.jpg" src="congzhi's-os-series/pics/pasted-image-20241202010310.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.4 Acyclic-Graph Directories" dir="auto" class="heading" id="3.2.4_Acyclic-Graph_Directories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.4 Acyclic-Graph Directories</h4><div class="heading-children"><div class="el-p"><p dir="auto">上述的三种目录都不能够使得同一个文件/子目录在多个不同的目录下共享，用户访问其他用户的某些文件的愿望将无法得到满足。无环图目录允许一个文件/子目录同时存在于多个目录下，允许文件/子目录在用户多个间共享（不同目录访问同一个文件得到了实现）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202010318.jpg" src="Pasted image 20241202010318.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202010318.jpg" src="congzhi's-os-series/pics/pasted-image-20241202010318.jpg"></span></p></div><div class="el-p"><p dir="auto">这种共享性有时候会用<strong>符号链接</strong>，也就是<strong>软连接</strong>实现，有时候也会通过<strong>硬链接</strong>实现。这两种不同的链接形式我们马上就会了解到。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.5 &nbsp;General Graph Directory" dir="auto" class="heading" id="3.2.5_&nbsp;General_Graph_Directory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.5 &nbsp;General Graph Directory</h4><div class="heading-children"><div class="el-p"><p dir="auto">在无环图目录结构中，目录不可以成”环“。然而这种环状目录在通用图目录结构中是允许的。环状目录或者成环其实就是目录中包含循环到起点的路径，即在下级目录中包含上级目录。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202231218.jpg" src="Pasted image 20241202231218.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202231218.jpg" src="congzhi's-os-series/pics/pasted-image-20241202231218.jpg"></span></p></div><div class="el-p"><p dir="auto">由于这种环状的存在，所以设计检索和遍历算法时就更加困难。这种环状可能导致遍历算法的无限循环，为了避免这种情况，设计者干脆禁止在目录中允许上级目录的存在。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.3 Directory Implementation" dir="auto" class="heading" id="3.3_Directory_Implementation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3 Directory Implementation</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="3.3.1 AVL Tree" dir="auto" class="heading" id="3.3.1_AVL_Tree"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.1 AVL Tree</h4><div class="heading-children"><div class="el-p"><p dir="auto">AVL树(AVL Tree)是目录实现中常见的数据结构。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.3.2 B Tree" dir="auto" class="heading" id="3.3.2_B_Tree"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.2 B Tree</h4><div class="heading-children"><div class="el-p"><p dir="auto">B树(B-Tree)极其变种也是目录实现中常见的数据结构。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.4 Links" dir="auto" class="heading" id="3.4_Links"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4 Links</h3><div class="heading-children"><div class="el-p"><p dir="auto">在文件系统中，<strong>硬链接</strong>是一个指向数据块的直接引用，出现在inode中。硬链接使得多个文件名指向相同的inode，因此它们共享相同的数据内容。</p></div><div class="el-p"><p dir="auto"><strong>软链接</strong>是一种特殊的文件类型，出现在目录项中，它包含指向另一个文件路径的指针，而不是直接指向数据块。因此，软链接相当于文件的快捷方式。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240831003914.jpg" src="Pasted image 20240831003914.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240831003914.jpg" src="congzhi's-os-series/pics/pasted-image-20240831003914.jpg"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.4.1 Hard Links" dir="auto" class="heading" id="3.4.1_Hard_Links"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4.1 Hard Links</h4><div class="heading-children"><div class="el-p"><p dir="auto">在Linux中，我们用命令<code>ln</code>来创建一个硬链接，例如：</p></div><div class="el-pre"><pre class="language-shell" tabindex="0"><code data-line="0" class="language-shell is-loaded">du@du-virtual-machine:~/Desktop/OS$ ./Hello
Hello world
du@du-virtual-machine:~/Desktop/OS$ <span class="token function">ln</span> Hello Hard_Link
du@du-virtual-machine:~/Desktop/OS$ ./Hard_Link 
Hello world
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">创建硬链接之后，两个文件会共享相同的inode（如上面例子中的<code>Hello</code>和<code>Hard_Link</code>）。也就是说它们会指向相同的数据内容。我们用<code>stat</code>命令查看<code>Hello</code>文件的元数据，可得：</p></div><div class="el-pre"><pre><code data-line="0">du@du-virtual-machine:~/Desktop/OS$ stat Hello
  File: Hello
  Size: 15960     	Blocks: 32         IO Block: 4096   regular file
Device: 803h/2051d	Inode: 1049216     Links: 2
Access: (0775/-rwxrwxr-x)  Uid: ( 1000/      du)   Gid: ( 1000/      du)
Access: 2024-08-31 00:06:02.431095349 +0800
Modify: 2024-08-31 00:04:56.176093580 +0800
Change: 2024-08-31 00:05:46.451336108 +0800
 Birth: 2024-08-31 00:04:56.128094303 +0800

du@du-virtual-machine:~/Desktop/OS$ stat Hard_Link 
  File: Hard_Link
  Size: 15960     	Blocks: 32         IO Block: 4096   regular file
Device: 803h/2051d	Inode: 1049216     Links: 2
Access: (0775/-rwxrwxr-x)  Uid: ( 1000/      du)   Gid: ( 1000/      du)
Access: 2024-08-31 00:06:02.431095349 +0800
Modify: 2024-08-31 00:04:56.176093580 +0800
Change: 2024-08-31 00:05:46.451336108 +0800
 Birth: 2024-08-31 00:04:56.128094303 +0800
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们看到，这两个文件名所指向的数据都是一样的。我们看到<code>Links</code>字段为2，这表示当前有两个目录项指向这个文件，也是文件的硬链接数。<strong>当硬链接数为0时，文件系统就会释放并回收文件资源。</strong></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.4.2 Soft Links" dir="auto" class="heading" id="3.4.2_Soft_Links"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4.2 Soft Links</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们用<code>ln -s</code>命令来创建一个软链接：</p></div><div class="el-pre"><pre class="language-shell" tabindex="0"><code data-line="0" class="language-shell is-loaded">du@du-virtual-machine:~/Desktop/OS$ <span class="token function">ln</span> <span class="token parameter variable">-s</span> Hello Soft_Link 
du@du-virtual-machine:~/Desktop/OS$ ./Soft_Link 
Hello world
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">当软链接创建好后，软链接文件和源文件的inode并不相同。软链接本身是一个独立的文件，存储对源文件的路径引用。文件大小就是字符串的长度。我们用<code>ls</code>查看Soft_Link的大小，大小为5字节，正好是<code>Hello</code>文件名的长度。这里引用的是相对路径，但也可以引用绝对路径。</p></div><div class="el-pre"><pre><code data-line="0">du@du-virtual-machine:~/Desktop/OS$ stat Soft_Link 
  File: Soft_Link -&gt; Hello
  Size: 5         	Blocks: 0          IO Block: 4096   symbolic link
Device: 803h/2051d	Inode: 1049994     Links: 1
Access: (0777/lrwxrwxrwx)  Uid: ( 1000/      du)   Gid: ( 1000/      du)
Access: 2024-08-31 00:43:40.242348874 +0800
Modify: 2024-08-31 00:43:40.238349935 +0800
Change: 2024-08-31 00:43:40.238349935 +0800
 Birth: 2024-08-31 00:43:40.238349935 +0800
du@du-virtual-machine:~/Desktop/OS$ ls -l Soft_Link 
lrwxrwxrwx 1 du du 5  8月 31 00:43 Soft_Link -&gt; Hello
du@du-virtual-machine:~/Desktop/OS$ ls -l Hard_Link 
-rwxrwxr-x 2 du du 15960  8月 31 00:04 Hard_Link
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">当源文件被删除，软链接就会指向一个不存在的路径。这时，软链接会变为无效链接，这就是“断链”现象。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第四课 File Allocation Methods" dir="auto" class="heading" id="第四课_File_Allocation_Methods"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第四课 File Allocation Methods</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">和内存的分配策略一样，文件系统在磁盘空间的利用上也有不同的分配方法。这节课我们将学习三种不同的分配方法，分别是contiguous、linked和indexed。但在此之前，我们先了解一下用户视角上的文件。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.1 Logical Structure of a File" dir="auto" class="heading" id="4.1_Logical_Structure_of_a_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 Logical Structure of a File</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们生活中的文件类型有很多种。您现在所看的算是一种线性的顺序结构，而当你看到这个系列，你可以直接点击阶段的大标题从而进入你想了解的阶段笔记进行学习，这是一种类似索引的结构。而在这个笔记中，我们有很多大标题小标题，这又可以看作是一种层次式的结构。在我们学习ELF文件时，文件中的数据又可以分段处理，这是一种分段式结构的文件。</p></div><div class="el-p"><p dir="auto">文件的逻辑结构关注的是文件内容在用户视角下是如何组织的。即如何从软件层面组织和访问文件内容。上面提到过的四种逻辑结构有：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>线性顺序结构/流式文件(Sequential Structure)</strong>：文件内容按顺序存储和访问，一般用纯 ASCII、Unicode 编写的字符文档的内容是按线性顺序存储的(能够<code>cat</code>的文件)。</li>
<li data-line="1" dir="auto"><strong>索引结构(Indexed Structure)</strong>：文件内容按索引表进行组织（如字典），索引表再指向实际数据的位置。索引结构允许快速定位到文件中某个特定数据上，常用于数据库文件或大型文件中，页表就是最常见的索引结构。</li>
<li data-line="2" dir="auto"><strong>层次式结构(Hierarchical Structure)</strong>：文件内部被组织成多级结构，每一级可以包含不同的数据段或子文件。层次化的逻辑结构有文件树形目录等。</li>
<li data-line="3" dir="auto"><strong>分段结构(Segmented Structure)</strong>：ELF 可执行文件就是这样分段的结构，文件中的内容被划分到各个独立的段中，每个段设置单独的属性分别管理。</li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.1 Sequential and Direct Access" dir="auto" class="heading" id="4.1.1_Sequential_and_Direct_Access"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1 Sequential and Direct Access</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们看到的文件（即逻辑上的文件）主要有两种访问方式：<strong>顺序访问</strong>和<strong>随机访问（直接访问）</strong>。还有其他的访问方式都是在这两种访问方式的基础上建立的。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.1.1 Sequential Access" dir="auto" class="heading" id="4.1.1.1_Sequential_Access"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1.1 Sequential Access</h5><div class="heading-children"><div class="el-p"><p dir="auto">顺序访问要求数据按照存储顺序从文件开头到结尾逐步读取或写入，你想看笔记的最有一小节时，你需要将笔记前面的内容全部加载到内存中。即便你只想要知道最后的内容，你也需要将文件整个加载。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202002753.jpg" src="Pasted image 20241202002753.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202002753.jpg" src="congzhi's-os-series/pics/pasted-image-20241202002753.jpg"></span></p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.1.2 Direct Access" dir="auto" class="heading" id="4.1.1.2_Direct_Access"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1.2 Direct Access</h5><div class="heading-children"><div class="el-p"><p dir="auto">随机访问则允许直接跳转到文件中的任意位置进行读取或写入。由于文件内容可以非顺序处理，不需要将不需要的文件部分加载进内存，所以访问速度相较顺序访问要快。由于程序的局部性原理，在我们加载一些大型程序到内存中时，可能并不会将文件整个的加载进内存，这就是一种随机访问的文件访问方式。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241202002801.jpg" src="Pasted image 20241202002801.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241202002801.jpg" src="congzhi's-os-series/pics/pasted-image-20241202002801.jpg"></span></p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.2 Access Way of Different Logical File" dir="auto" class="heading" id="4.1.2_Access_Way_of_Different_Logical_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.2 Access Way of Different Logical File</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们前面提到了四种文件结构，对于这四种不太文件结构的文件而言，它们会遵循不同的访问方式。对于线性顺序结构的文件来说，由于要读取访问下一个字符数据必须先访问上一个字符数据。所以文件的访问必须是连续的，这不难理解。</p></div><div class="el-p"><p dir="auto">对于索引结构的文件来说，索引表可以让我们访问文件的不同位置。然而，通过索引表跳转之后，文件的访问转而变成线性顺序的访问（宏观上跳转，微观上连续）。类似的，由于层次化的结构相当于多级索引，我们可以跳转到我们想要数据的最小目录下访问，这个访问是线性连续的。</p></div><div class="el-p"><p dir="auto">对于分段结构的文件，我们可以将其理解成类索引的顺序结构文件。在 ELF 中，我们将文件中不同的内容划分到各个节中，这些段相当于独立的线性顺序结构的文件，但我们通过节头表定义并索引了文件中各个节的位置及属性。在 ELF 文件中，文件访问同样是节外跳转、节内连续。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.2 Physical Allocation of a File" dir="auto" class="heading" id="4.2_Physical_Allocation_of_a_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 Physical Allocation of a File</h3><div class="heading-children"><div class="el-p"><p dir="auto">文件存放在持久性的存储设备上，文件的物理结构关注文件在硬盘、SSD等持久存储设备上的实际布局方式。文件的物理结构对于存储介质的特性、文件系统的实现密切相关（SSD可以随机存取；硬盘是随机存取+顺序存取；磁带只能顺序存取），主要包括以下几种形式：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>连续分配(Contiguous Allocation)</strong></li>
<li data-line="1" dir="auto"><strong>链式分配(Linked Allocation)</strong></li>
<li data-line="2" dir="auto"><strong>索引分配(Indexed Allocation)</strong></li>
<li data-line="3" dir="auto"><strong>多级索引(Multilevel Index)</strong></li>
<li data-line="4" dir="auto"><strong>混合分配(Hybrid Allocation)</strong></li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.1 Contiguous Allocation" dir="auto" class="heading" id="4.2.1_Contiguous_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 Contiguous Allocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">连续分配就是指文件占用一组连续的磁盘块。逻辑上相连的块在物理上也相邻。所以这种分配方式带来的好处就是当磁头读到的文件位于磁盘块b时，读取下一个文件块b+1时，磁头并不需要怎么移动，也就不存在寻道时间了（最小的寻道时间）。在这种分配方式下，磁盘的目录项包括：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">文件名</li>
<li data-line="1" dir="auto">第一个块的起始地址，块地址 = 扇区id（块大小 = 扇区大小）</li>
<li data-line="2" dir="auto">文件长度（块长度）</li>
</ol></div><div class="el-p"><p dir="auto">即你只需要两个参数（起始块地址和文件长度）就能够keep track of this file。如果你需要读取 b+n 磁盘块中的内容，你只需要将磁头移动到相应的位置上，而不需要顺序一格一格地移动磁头，算是一种随机存取。这种方式可以轻易地实现对文件的顺序和直接访问。</p></div><div class="el-p"><p dir="auto">而且这种方式在检查文件访问是否有效时非常简单，假设文件长度是 n，文件的起始块地址是 b。如果访问的磁盘块地址&gt; b + n，那么就可以断定这个访问是不合法的。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240825132025.png" src="Pasted image 20240825132025.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825132025.png" src="congzhi's-os-series/pics/pasted-image-20240825132025.png"></span></p></div><div class="el-p"><p dir="auto">享受完顺序分配给我们带来的简单性，我们就需要来承担相应的缺点。在顺序分配方式中，我们如果有一个大小为 N 个磁盘块的文件，在存储这个文件时，我们需要考虑：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">磁盘分区中有没有这么大的空间能够被分配？</li>
<li data-line="1" dir="auto">如果有，我们应该选哪个空间？</li>
</ol></div><div class="el-p"><p dir="auto">在磁盘空间动态分配时也可以选用不同的分配策略（首次适应、最佳适应、最差适应）。显而易见的是，这种分配方式会造成不可避免的外部碎片(external fragmentation)，内部碎片(internal fragmentation)由于被控制在一个块的大小内，所以我们不需要注意。在这种分配方式下，如果文件很大，所有孔的容纳不下，那么文件将无法载入磁盘。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.1.1 Contiguous Allocation and Compaction" dir="auto" class="heading" id="4.2.1.1_Contiguous_Allocation_and_Compaction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1.1 Contiguous Allocation and Compaction</h5><div class="heading-children"><div class="el-p"><p dir="auto">除了要应对文件太大没有孔能够容纳这么大的文件之外，连续分配还给我们带来<strong>动态存储分配(dynamic storage allocation)</strong> 的问题。这是不可利用的外部碎片给连续分配方式带来的，这意味着大文件的扩展可能是很困难的。</p></div><div class="el-p"><p dir="auto">对于外部碎片的处理，我们在内存分配的时候介绍过紧凑技术(compaction)，那对于磁盘而言，通过移动磁盘块，将非空闲的磁盘块紧凑在一块，那将会为我们带来很大的一块空闲空间。然而，磁盘可比内存慢多了，这么做的代价将会非常大。（<em>Disk defragmentation</em> for more）</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.2 Linked Allocation" dir="auto" class="heading" id="4.2.2_Linked_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 Linked Allocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">好，既然我们不确定文件有多大，也不想任何外部碎片的产生，我们为何不将文件块链式地存放在磁盘上呢？将文件进行分割成块，分配在多个离散的磁盘块中，通过指针连接。不会产生任何的外部碎片，而且文件扩展较为容易。如何？</p></div><div class="el-p"><p dir="auto">顺序分配和链式分配的关系相当于数组和链表之间的关系。链式分配带来了诸多好处，其中最主要的就是避免了任何的外部碎片。但是由于需要指向下一个磁盘块的指针和不能随机访问的特性，使得链式分配方式会不可避免地占用一点空间用于存储指针，并且速度慢（存在寻道时间）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240825132044.png" src="Pasted image 20240825132044.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825132044.png" src="congzhi's-os-series/pics/pasted-image-20240825132044.png"></span></p></div><div class="el-p"><p dir="auto">链式分配方式的一大缺点就是当你要找一个文件块，你就必须得顺着指针链条往上找。所以一般的实现上，通常会结合连续分配和链式分配的优点。即以<strong>簇(clusters)</strong> 为单位进行连续分配，我们可以设置为4个块1个簇，然后将这些单位链接起来。这种方法可以提高访问速度，同时减少碎片问题。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.3 Indexed Allocation" dir="auto" class="heading" id="4.2.3_Indexed_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 Indexed Allocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果你是原始链式分配的原教旨主义者，你就会将自己困在无法随机访问带来的访问速度的困境中。然而，我们可以给每个文件建立索引表，把所有的指针都顺序地放在一个磁盘块中，记录文件各逻辑块对应的物理块。这样就可以实现随机访问文件了，吸收了顺序分配的优点；而且不会产生任何的外部碎片，同样结合了链式分配的优点。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240825132254.png" src="Pasted image 20240825132254.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825132254.png" src="congzhi's-os-series/pics/pasted-image-20240825132254.png"></span></p></div><div class="el-p"><p dir="auto">这种分配方式真不错，既保留了顺序连续分配的优点，也保留了链式分配的优点。但是有一点不足，即当文件变得很大，我们就没有办法对文件进行分配了，因为一个块能够索引的大小很有限。对于这种窘境，人们想出来很多办法。如：将index block最后一个index entry作为下一个index block的entry（linked scheme）；加入上级的index对index block进行索引（multilevel index）；将上述的方法结合起来，这也是inode所使用的方式（combined scheme）。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.4 The Unix Inode" dir="auto" class="heading" id="4.2.4_The_Unix_Inode"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.4 The Unix Inode</h4><div class="heading-children"><div class="el-p"><p dir="auto">下图展示了unix inode的multilevel indexing，在本阶段后续的课程中我们会详细介绍。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241128030948.jpg" src="Pasted image 20241128030948.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241128030948.jpg" src="congzhi's-os-series/pics/pasted-image-20241128030948.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.5 Pre-Allocation" dir="auto" class="heading" id="4.2.5_Pre-Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.5 Pre-Allocation</h4><div class="heading-children"></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第五课 Disk Free Space Management" dir="auto" class="heading" id="第五课_Disk_Free_Space_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第五课 Disk Free Space Management</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.1 Free Space Management" dir="auto" class="heading" id="5.1_Free_Space_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 Free Space Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们学习了文件系统的设计。其中负责空闲空间管理的是<strong>文件组织模块/文件组织层</strong>。这个层次不单单负责逻辑块到物理块的转换，也负责逻辑上对磁盘存储块的管理，之后对逻辑块的管理进一步映射到物理块上。为了确保对磁盘的空闲空间能得到有效的利用，我们有许多对空闲空间管理的方法。我们接下来一个一个地介绍。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.2 Bitmap/Bit Vector" dir="auto" class="heading" id="5.2_Bitmap/Bit_Vector"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 Bitmap/Bit Vector</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>位图</strong>是一连串比特位的集合。在位图法中，我们用一位bit代表一块磁盘块。Bit可以取0和1，因而我们用0表示空磁盘块，用1表示已使用磁盘块。如下的磁盘空间就可以用16bits的位图：<strong>1111 0001 1111 1001</strong> 来表示。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240826135306.png" src="Pasted image 20240826135306.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826135306.png" src="congzhi's-os-series/pics/pasted-image-20240826135306.png"></span></p></div><div class="el-p"><p dir="auto">这种方式无论是理解还是实现都非常的简单。一个bit表示一个磁盘块，空间上也很划得来，利用率肯定不低。然而，如果我们暂时只能用磁盘很小一部分区域，位图法就会占有不该占有的内存空间。而且位图的大小是固定的，如果磁盘扩展，就需要重新初始化位图。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.3 Linked List" dir="auto" class="heading" id="5.3_Linked_List"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.3 Linked List</h3><div class="heading-children"><div class="el-p"><p dir="auto">为了扩充磁盘的便利，我们可以使用链表。空闲链表法的实现方式就是将所有空闲块用链表链接起来。空闲块中包含指向下一个空闲块的指针，在下图的实现中，空闲空间链接头指向 Block5，然后 Block5 的指针域指向 Block6 以此类推。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240826135310.png" src="Pasted image 20240826135310.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826135310.png" src="congzhi's-os-series/pics/pasted-image-20240826135310.png"></span></p></div><div class="el-p"><p dir="auto">相比于位图法，空闲链表法的空间利用效率不会浪费其不该占用的内存空间。而且动态分配很容易，因而也可以动态的增加磁盘空间。但是指针动态分配的便利性也会造成该方法的指针维护很复杂，而且并不适合遍历。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.4 Grouping" dir="auto" class="heading" id="5.4_Grouping"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4 Grouping</h3><div class="heading-children"><div class="el-p"><p dir="auto">这是空闲链表法的变种。不同于空闲链表，在分块成组法中，每一个空闲块的地址存放在 n 个磁盘块中，通过将这 n 个磁盘块链接起来，我们就能够轻松的找到那些未分配的磁盘块了（相当于索引+链接）。这种方式看起来很不错，因为我们可以很轻松的分配一大片空闲磁盘块。但是缺点也很明显，每一次的分配都会使得整个列表重新修正整个list。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240826173012.png" src="Pasted image 20240826173012.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826173012.png" src="congzhi's-os-series/pics/pasted-image-20240826173012.png"></span></p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.5 Counting" dir="auto" class="heading" id="5.5_Counting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5 Counting</h3><div class="heading-children"><div class="el-p"><p dir="auto">在counting的方法中，系统会用特定的格式（start base address, # numbers of free blocks）记录这些连续的空闲块。如果大多数连续空间块的长度超过了1块，那么这个列表将会非常紧凑。为了保证搜索、插入和删除的高效性，系统通常会用一个平衡树中存储这些记录。保证操作的效率。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.6 Space Maps" dir="auto" class="heading" id="5.6_Space_Maps"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.6 Space Maps</h3><div class="heading-children"></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.7 TRIMing Unused Blocks" dir="auto" class="heading" id="5.7_TRIMing_Unused_Blocks"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.7 TRIMing Unused Blocks</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第六课 Different File Systems" dir="auto" class="heading" id="第六课_Different_File_Systems"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第六课 Different File Systems</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.1 FAT" dir="auto" class="heading" id="6.1_FAT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1 FAT</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>文件分配表(File Allocation Table, FAT)</strong> 是链式分配的变种。最早由微软在1970年代为MS-DOS操作系统开发。由于简单的设计，FAT适用于各种各样的存储设备如软盘、硬盘、移动存储设备等。FAT采用簇链式存储分配，但簇中不再存放下一个簇的指针信息了，FAT会额外使用一块空间专门记录这些簇指针的信息，也就是FAT表，这也是FAT文件系统的特点和命名由来。</p></div><div class="el-p"><p dir="auto">FAT早期版本包括 FAT12 和 FAT16，应用于存储容量较小的设备上，随着存储设备容量的不断增加，FAT32 被引入，用于支持更大的分区和文件大小。今天，NTFS代替了FAT作为Windows系统上应用的文件系统，但FAT32仍广泛应用在U盘上（兼容性佳）。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.1.1 FAT Volume Structure Layout" dir="auto" class="heading" id="6.1.1_FAT_Volume_Structure_Layout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1 FAT Volume Structure Layout</h4><div class="heading-children"><div class="el-p"><p dir="auto">FAT文件系统下，磁盘结构被划分成引导扇区、文件分配表FAT、根目录区和数据区域。我们接下来逐步介绍。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.1.1 Boot Sector" dir="auto" class="heading" id="6.1.1.1_Boot_Sector"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1.1 Boot Sector</h5><div class="heading-children"><div class="el-p"><p dir="auto">作为磁盘分区的开始，为了保证计算机的正常启动，传统的，我们将第一个扇区作为<strong>引导扇区</strong>使用（第二个扇区可能会作为冗余对引导扇区进行备份）。引导扇区包括我们介绍过的启动代码和磁盘参数块(disk parameter block)，在磁盘参数块中包含磁盘的信息和文件系统的基本信息。</p></div><div class="el-p"><p dir="auto">磁盘信息有：每个扇区多少字节、每个track几个扇区、磁头信息等。文件系统的信息有：<strong>FAT表数量</strong>、<strong>每个FAT表的扇区数</strong>、<strong>根目录项的数量</strong>、<strong>簇的信息</strong>等。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.1.2 FAT" dir="auto" class="heading" id="6.1.1.2_FAT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1.2 FAT</h5><div class="heading-children"><div class="el-p"><p dir="auto">在引导扇区之后，作为FAT的重中之重，我们通常会看到两个相同的FAT表用于冗余和数据的恢复。每个FAT表都记录了磁盘上所有簇的状态和链表信息。FAT表是一个数组，其中的每个元素对应磁盘中的一个簇，元素的数值代表了该簇的状态：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>值为0</strong>：簇空闲（空闲空间管理）</li>
<li data-line="1" dir="auto"><strong>值为正整数</strong>：簇已被占用，其中的数字指示下一个簇的编号</li>
<li data-line="2" dir="auto"><strong>值为EOF(-1)</strong>：文件结尾</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240825132134.png" src="Pasted image 20240825132134.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825132134.png" src="congzhi's-os-series/pics/pasted-image-20240825132134.png"></span></p></div><div class="el-p"><p dir="auto">通过把这些指针信息整合到一块，实际上FAT会比传统的簇链式方式要快很多。因为操作系统可以将整个FAT都加入到内存中（FAT不会很大），避免了对I/O的重复访问。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.1.3 Root Directory" dir="auto" class="heading" id="6.1.1.3_Root_Directory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1.3 Root Directory</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>根目录区域(Root Directory)</strong>：存储文件和目录的目录项信息，包含文件名、扩展名、属性、创建时间、起始簇号等。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.1.4 File and Directiory Area" dir="auto" class="heading" id="6.1.1.4_File_and_Directiory_Area"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1.4 File and Directiory Area</h5><div class="heading-children"><div class="el-p"><p dir="auto">之后的一大片空闲的磁盘块就都用来作为<strong>数据区域(File and Directory Area)</strong>。这个区域存放文件和目录的数据内容。文件的数据被分配到多个簇中，簇之间通过FAT表链接。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.1.2 File Maxium Capacity in FAT" dir="auto" class="heading" id="6.1.2_File_Maxium_Capacity_in_FAT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.2 File Maxium Capacity in FAT</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们常常会看到FAT16/FAT32，FAT后面的数字代表什么呢？这代表着FAT表中表项的位数，即FAT能够寻址的簇数。通过这个信息和簇大小信息，我们就可以得到最大分区大小是多大了。文件大小根据目录表项（FCB）中文件大小字段的位数决定。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.2.1 FAT16" dir="auto" class="heading" id="6.1.2.1_FAT16"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.2.1 FAT16</h5><div class="heading-children"><div class="el-p"><p dir="auto">FAT16的<strong>FAT表项是16bits</strong>，代表着每个表项可以表示 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup></mjx-math></mjx-container></span> 个不同的值，即65536个簇。FAT16通常使用<strong>32KB大小的簇</strong>。所以最大分区大小是：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">最</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">分</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">区</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">小</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="4"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">最</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">簇</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">数</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">簇</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">小</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>而目录项有32Bytes，其中<strong>文件大小属性占4Bytes（也就是32位）</strong>。所以单个文件大小为：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c46"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c7A"></mjx-c><mjx-c class="mjx-c65"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c79"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c73"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>虽然单个文件大小能达到4GB，但受限于最大分区大小，FAT16的单个文件最大为2GB。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.2.2 FAT32" dir="auto" class="heading" id="6.1.2.2_FAT32"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.2.2 FAT32</h5><div class="heading-children"><div class="el-p"><p dir="auto">同样，在FAT32中，FAT表项是32bits，但是实际上用于表示簇的有效位只有28位，其余的位数用来标记EOF和保留位。其余部分和FAT16相同的情况下，最大分区大小为：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">最</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">分</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">区</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">小</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="4"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">最</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">簇</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">数</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">簇</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">大</mjx-utext><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">小</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>这可比4GB大多了，所以在FAT32中单个文件最大是4GB，和文件系统支持的最大文件大小相同。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.1.2.3 We've Got a lot of FAT" dir="auto" class="heading" id="6.1.2.3_We've_Got_a_lot_of_FAT"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.2.3 We've Got a lot of FAT</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们现在能够明白FAT文件系统分区大小和单文件大小限制的因素有哪些，并且是如何影响FAT最大分区大小和最大文件大小的。然而FAT变种有很多，因此FAT16/32的最大文件大小或最大分区大小并不是固定的。根据不同的实现方式，所得出来的结果也是不一样的。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.2 The Second Extended File System ([ext2](https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h))" dir="auto" class="heading" id="6.2_The_Second_Extended_File_System_([ext2](https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h))"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2 The Second Extended File System (<a data-tooltip-position="top" aria-label="https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h" rel="noopener nofollow" class="external-link" href="https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h" target="_blank">ext2</a>)</h3><div class="heading-children"><div class="el-p"><p dir="auto">扩展文件系统是Linux系统中常见的文件系统，ext系统算是一种类UNIX文件系统的文件系统，ext的出现就是为了克服MINIX文件系统的一些缺点。在ext文件系统中的<strong>块(blocks)</strong>、<strong>索引节点(inodes)</strong> 和<strong>目录</strong>和一些<strong>文件所有权/访问权限(ownership/access)</strong>、<strong>链接(symbolic/hard links)</strong> 等都是继承传统UNIX文件系统的概念。</p></div><div class="el-p"><p dir="auto">ext2是原始版本ext的重写，这些类UNIX文件系统的ext特点就是作为核心地位的“inode”。Ext2文件系统在1990年代初到2000年代初的近十年间，作为Linux的文件系统被广泛使用。后来，它被支持日志功能的文件系统ext3和ReiserFS所取代。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.1 Blocks" dir="auto" class="heading" id="6.2.1_Blocks"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.1 Blocks</h4><div class="heading-children"><div class="el-p"><p dir="auto">在ext2文件系统中，磁盘空间被划分为连续的逻辑块(blocks)。块大小并不需要与磁盘的物理扇区大小相同，因此块的大小还能更大，以便优化文件系统的性能和数据管理效率。在ext文件系统中，超级块负责卷空间信息的记录和管理。块大小由超级块中特定的字段所设置。</p></div><div class="el-p"><p dir="auto">块大小一般会设置为是1024字节、2048字节或4096字节（ext2中块最大可以设置为65536个字节）。一旦文件系统初始化完成，块大小就将固定。块大小越小，存储文件产生的存储碎片就越少，但是相应地就会带来额外的管理开销（而且文件大小和文件系统大小就越小）。当前，主流的默认块大小是4KB。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.2 Block Groups" dir="auto" class="heading" id="6.2.2_Block_Groups"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.2 Block Groups</h4><div class="heading-children"><div class="el-p"><p dir="auto">块组是许多个块聚合在一起所构成的。磁盘空间被划分成了若干个块组，这样组织有效的避免了文件分散在磁盘的各个位置，从而减小了磁头的寻道时间；同时，也对碎片化有重要的影响。除此之外，块组中包含有一些重要数据的备份（如超级块等），使得文件系统能够在必要的时刻重建。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241205203358.png" src="Pasted image 20241205203358.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241205203358.png" src="congzhi's-os-series/pics/pasted-image-20241205203358.png"></span></p></div><div class="el-p"><p dir="auto">磁盘被划分为若干个块组。每个块组由一定数量的块(Blocks)构成，包含：<strong>超级区块(Super Block)</strong>、<strong>组描述符表(Group Descriptor Table)</strong>、<strong>区块位图(Block Bitmap)</strong>、<strong>索引节点位图(Inode Bitmap)</strong>、<strong>索引节点表(Inode Table)</strong>、<strong>数据块区(Data Blocks)</strong>。</p></div><div class="el-p"><p dir="auto">当一个文件的数据量超过一个块组的容量时，文件的数据块会分布在多个块组中。inode中的块指针可以指向不同块组中的数据块，从而实现跨块组的存储。一般而言，块组描述符表还会有一个备份，一个标准的<strong>块组0</strong>磁盘布局如下（N&gt;&gt;n）：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">Group 0 Padding</th>
<th align="center" dir="ltr">Super Block</th>
<th align="center" dir="ltr">Group Descriptors</th>
<th align="center" dir="ltr">Reserved GDT Blocks</th>
<th align="center" dir="ltr">Data Block Bitmap</th>
<th align="center" dir="ltr">inode Bitmap</th>
<th align="center" dir="ltr">inode Table</th>
<th align="center" dir="ltr">Data Blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr">1024 字节</td>
<td align="center" dir="ltr">1 个块</td>
<td align="center" dir="ltr">n 个块</td>
<td align="center" dir="ltr">n 个块</td>
<td align="center" dir="ltr">1 个块</td>
<td align="center" dir="ltr">1 个块</td>
<td align="center" dir="ltr">n 个块</td>
<td align="center" dir="ltr">N 个块</td>
</tr>
</tbody>
</table></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.2.1 Group Descriptor Table" dir="auto" class="heading" id="6.2.2.1_Group_Descriptor_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.2.1 Group Descriptor Table</h5><div class="heading-children"><div class="el-p"><p dir="auto">块组描述符表存储每个块组的基本信息，如inode表的起始块号、空闲块位图的起始块号等。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.2.2 inode Table and Data Blocks" dir="auto" class="heading" id="6.2.2.2_inode_Table_and_Data_Blocks"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.2.2 inode Table and Data Blocks</h5><div class="heading-children"><div class="el-p"><p dir="auto">如果块大小是4KB，那么数据块位图和inode位图就能够表示 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c></mjx-mtext></mjx-math></mjx-container></span> 个的数据块和inode。在ext2/3中，inode占128B，那么inode表就需要占用 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span> 的磁盘空间。剩余数据块理论大小可达 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span> 。</p></div><div class="el-p"><p dir="auto">上面这些是理论值的计算，实际上，我们可以设置inode和块数存在一定的对应关系。比方说一个块组中最多存放32个文件，那么inode表就只需要4KB的磁盘空间。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.3 The Superblock" dir="auto" class="heading" id="6.2.3_The_Superblock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.3 The Superblock</h4><div class="heading-children"><div class="el-p"><p dir="auto">ext2文件系统所有核心配置信息都存储在超级块中，它包含了如文件系统中的inode总数、块总数、块大小、空闲块和空闲inode数量等信息，对于文件系统的正常运行和管理至关重要。超级块位于卷偏移1024字节后（boot loader之后），由于超级块的重要性，在最初的ext2版本中，每个块组中都会留有超级块的备份。之后的版本将组号为0、1还有奇数的平方作为超级块的备份块组使用。</p></div><div class="el-p"><p dir="auto">ext2文件系统的超级块以小端方式存放在磁盘上，所以文件系统在不同机器上是可移植的。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.3.1 Superblock Data Structure" dir="auto" class="heading" id="6.2.3.1_Superblock_Data_Structure"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.3.1 Superblock Data Structure</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">ext2_super_block</span> <span class="token punctuation">{</span>
	__le32	s_inodes_count<span class="token punctuation">;</span>		<span class="token comment">/* Inodes count */</span>
	__le32	s_blocks_count<span class="token punctuation">;</span>		<span class="token comment">/* Blocks count */</span>
	__le32	s_r_blocks_count<span class="token punctuation">;</span>	<span class="token comment">/* Reserved blocks count */</span>
	__le32	s_free_blocks_count<span class="token punctuation">;</span>	<span class="token comment">/* Free blocks count */</span>
	__le32	s_free_inodes_count<span class="token punctuation">;</span>	<span class="token comment">/* Free inodes count */</span>
	__le32	s_first_data_block<span class="token punctuation">;</span>	<span class="token comment">/* First Data Block */</span>
	__le32	s_log_block_size<span class="token punctuation">;</span>	<span class="token comment">/* Block size */</span>
	__le32	s_log_frag_size<span class="token punctuation">;</span>	<span class="token comment">/* Fragment size */</span>
	__le32	s_blocks_per_group<span class="token punctuation">;</span>	<span class="token comment">/* # Blocks per group */</span>
	__le32	s_frags_per_group<span class="token punctuation">;</span>	<span class="token comment">/* # Fragments per group */</span>
	__le32	s_inodes_per_group<span class="token punctuation">;</span>	<span class="token comment">/* # Inodes per group */</span>
	__le32	s_mtime<span class="token punctuation">;</span>		<span class="token comment">/* Mount time */</span>
	__le32	s_wtime<span class="token punctuation">;</span>		<span class="token comment">/* Write time */</span>
	__le16	s_mnt_count<span class="token punctuation">;</span>		<span class="token comment">/* Mount count */</span>
	__le16	s_max_mnt_count<span class="token punctuation">;</span>	<span class="token comment">/* Maximal mount count */</span>
	__le16	s_magic<span class="token punctuation">;</span>		<span class="token comment">/* Magic signature */</span>
	__le16	s_state<span class="token punctuation">;</span>		<span class="token comment">/* File system state */</span>
	__le16	s_errors<span class="token punctuation">;</span>		<span class="token comment">/* Behaviour when detecting errors */</span>
	__le16	s_minor_rev_level<span class="token punctuation">;</span> 	<span class="token comment">/* minor revision level */</span>
	__le32	s_lastcheck<span class="token punctuation">;</span>		<span class="token comment">/* time of last check */</span>
	__le32	s_checkinterval<span class="token punctuation">;</span>	<span class="token comment">/* max. time between checks */</span>
	__le32	s_creator_os<span class="token punctuation">;</span>		<span class="token comment">/* OS */</span>
	__le32	s_rev_level<span class="token punctuation">;</span>		<span class="token comment">/* Revision level */</span>
	__le16	s_def_resuid<span class="token punctuation">;</span>		<span class="token comment">/* Default uid for reserved blocks */</span>
	__le16	s_def_resgid<span class="token punctuation">;</span>		<span class="token comment">/* Default gid for reserved blocks */</span>
	<span class="token comment">/*
	 * These fields are for EXT2_DYNAMIC_REV superblocks only.
	 *
	 * Note: the difference between the compatible feature set and
	 * the incompatible feature set is that if there is a bit set
	 * in the incompatible feature set that the kernel doesn't
	 * know about, it should refuse to mount the filesystem.
	 * 
	 * e2fsck's requirements are more strict; if it doesn't know
	 * about a feature in either the compatible or incompatible
	 * feature set, it must abort and not try to meddle with
	 * things it doesn't understand...
	 */</span>
	__le32	s_first_ino<span class="token punctuation">;</span> 		<span class="token comment">/* First non-reserved inode */</span>
	__le16   s_inode_size<span class="token punctuation">;</span> 		<span class="token comment">/* size of inode structure */</span>
	__le16	s_block_group_nr<span class="token punctuation">;</span> 	<span class="token comment">/* block group # of this superblock */</span>
	__le32	s_feature_compat<span class="token punctuation">;</span> 	<span class="token comment">/* compatible feature set */</span>
	__le32	s_feature_incompat<span class="token punctuation">;</span> 	<span class="token comment">/* incompatible feature set */</span>
	__le32	s_feature_ro_compat<span class="token punctuation">;</span> 	<span class="token comment">/* readonly-compatible feature set */</span>
	__u8	s_uuid<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">/* 128-bit uuid for volume */</span>
	<span class="token keyword">char</span>	s_volume_name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 	<span class="token comment">/* volume name */</span>
	<span class="token keyword">char</span>	s_last_mounted<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 	<span class="token comment">/* directory where last mounted */</span>
	__le32	s_algorithm_usage_bitmap<span class="token punctuation">;</span> <span class="token comment">/* For compression */</span>
	<span class="token comment">/*
	 * Performance hints.  Directory preallocation should only
	 * happen if the EXT2_COMPAT_PREALLOC flag is on.
	 */</span>
	__u8	s_prealloc_blocks<span class="token punctuation">;</span>	<span class="token comment">/* Nr of blocks to try to preallocate*/</span>
	__u8	s_prealloc_dir_blocks<span class="token punctuation">;</span>	<span class="token comment">/* Nr to preallocate for dirs */</span>
	__u16	s_padding1<span class="token punctuation">;</span>
	<span class="token comment">/*
	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.
	 */</span>
	__u8	s_journal_uuid<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* uuid of journal superblock */</span>
	__u32	s_journal_inum<span class="token punctuation">;</span>		<span class="token comment">/* inode number of journal file */</span>
	__u32	s_journal_dev<span class="token punctuation">;</span>		<span class="token comment">/* device number of journal file */</span>
	__u32	s_last_orphan<span class="token punctuation">;</span>		<span class="token comment">/* start of list of inodes to delete */</span>
	__u32	s_hash_seed<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">/* HTREE hash seed */</span>
	__u8	s_def_hash_version<span class="token punctuation">;</span>	<span class="token comment">/* Default hash version to use */</span>
	__u8	s_reserved_char_pad<span class="token punctuation">;</span>
	__u16	s_reserved_word_pad<span class="token punctuation">;</span>
	__le32	s_default_mount_opts<span class="token punctuation">;</span>
 	__le32	s_first_meta_bg<span class="token punctuation">;</span> 	<span class="token comment">/* First metablock block group */</span>
	__u32	s_reserved<span class="token punctuation">[</span><span class="token number">190</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* Padding to the end of the block */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.4 Index Nodes" dir="auto" class="heading" id="6.2.4_Index_Nodes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.4 Index Nodes</h4><div class="heading-children"><div class="el-p"><p dir="auto">Inode是ext2文件系统中的一个重要概念。Inode本质上是文件控制块，任何在ext2文件系统上的对象都需要用inode来表示，如文件、目录、符号链接等。inode中包含着除了文件名以外的所有文件元数据，如文件的权限(permissions)、所有者、组、flags、大小、使用的块数、访问创建修改删除时间、链接数、ACLs等。</p></div><div class="el-p"><p dir="auto">每个块组都有一个线性数组来存储inode节点数据，这个数组被称为 <strong>inode table</strong>。在ext2/3中，每个inode需要128KB的存储。每个inode都属于一个特定的块组，并存储在相应的 inode table 中。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.4.1 inode Data Structure" dir="auto" class="heading" id="6.2.4.1_inode_Data_Structure"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.4.1 inode Data Structure</h5><div class="heading-children"><div class="el-p"><p dir="auto">ext2/3的inode数据结构占用128个字节，ext4扩展为256个字节。以下是ext2/3的inode数据结构：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">Offset</th>
<th align="center" dir="ltr">Size</th>
<th align="center" dir="ltr">Field Name</th>
<th align="center" dir="ltr">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="auto">0</td>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">i_mode</td>
<td align="center" dir="ltr">文件类型和权限</td>
</tr>
<tr>
<td align="center" dir="auto">2</td>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">i_uid</td>
<td align="center" dir="ltr">低16位的用户ID</td>
</tr>
<tr>
<td align="center" dir="auto">4</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_size</td>
<td align="center" dir="ltr">文件大小（字节）</td>
</tr>
<tr>
<td align="center" dir="auto">8</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_atime</td>
<td align="center" dir="ltr">最后访问时间</td>
</tr>
<tr>
<td align="center" dir="auto">12</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_ctime</td>
<td align="center" dir="ltr">inode创建时间</td>
</tr>
<tr>
<td align="center" dir="auto">16</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_mtime</td>
<td align="center" dir="ltr">最后修改时间</td>
</tr>
<tr>
<td align="center" dir="auto">20</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_dtime</td>
<td align="center" dir="ltr">删除时间</td>
</tr>
<tr>
<td align="center" dir="auto">24</td>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">i_gid</td>
<td align="center" dir="ltr">低16位的组ID</td>
</tr>
<tr>
<td align="center" dir="auto">26</td>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">i_links_count</td>
<td align="center" dir="ltr">硬链接计数</td>
</tr>
<tr>
<td align="center" dir="auto">28</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_blocks</td>
<td align="center" dir="ltr">文件占用的块数</td>
</tr>
<tr>
<td align="center" dir="auto">32</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_flags</td>
<td align="center" dir="ltr">文件标志</td>
</tr>
<tr>
<td align="center" dir="auto">36</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">osd1</td>
<td align="center" dir="ltr">操作系统依赖字段1</td>
</tr>
<tr>
<td align="center" dir="auto">40</td>
<td align="center" dir="auto">60</td>
<td align="center" dir="ltr">i_block[EXT2_N_BLOCKS]</td>
<td align="center" dir="ltr">数据块指针（直接、间接、双级间接、三级间接）</td>
</tr>
<tr>
<td align="center" dir="auto">100</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_generation</td>
<td align="center" dir="ltr">文件版本（用于NFS）</td>
</tr>
<tr>
<td align="center" dir="auto">104</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_file_acl</td>
<td align="center" dir="ltr">文件访问控制列表</td>
</tr>
<tr>
<td align="center" dir="auto">108</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_dir_acl</td>
<td align="center" dir="ltr">目录访问控制列表</td>
</tr>
<tr>
<td align="center" dir="auto">112</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">i_faddr</td>
<td align="center" dir="ltr">碎片地址</td>
</tr>
<tr>
<td align="center" dir="auto">116</td>
<td align="center" dir="auto">12</td>
<td align="center" dir="ltr">osd2</td>
<td align="center" dir="ltr">操作系统依赖字段2</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">在ext2/3的inode数据结构中，最高的16bits数据用来表示类型和权限(Type and Permission)。其中 higher 4 bits 用来表示文件的类型，如：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Type value in hex</th>
<th dir="ltr">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">0x1000</td>
<td dir="ltr">FIFO</td>
</tr>
<tr>
<td dir="ltr">0x2000</td>
<td dir="ltr">Character device</td>
</tr>
<tr>
<td dir="ltr">0x4000</td>
<td dir="ltr">Directory</td>
</tr>
<tr>
<td dir="ltr">0x6000</td>
<td dir="ltr">Block device</td>
</tr>
<tr>
<td dir="ltr">0x8000</td>
<td dir="ltr">Regular file</td>
</tr>
<tr>
<td dir="ltr">0xA000</td>
<td dir="ltr">Symbolic link</td>
</tr>
<tr>
<td dir="ltr">0xC000</td>
<td dir="ltr">Unix socket</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">Lower 12 bits are used to present file permission as following below：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Type value in binary</th>
<th dir="ltr">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="auto">000  000  000  001</td>
<td dir="ltr">Execute (Others)</td>
</tr>
<tr>
<td dir="auto">000  000  000  010</td>
<td dir="ltr">Write (Others)</td>
</tr>
<tr>
<td dir="auto">000  000  000  100</td>
<td dir="ltr">Read (Others)</td>
</tr>
<tr>
<td dir="auto">000  000  001  000</td>
<td dir="ltr">Execute (Group)</td>
</tr>
<tr>
<td dir="auto">000  000  010  000</td>
<td dir="ltr">Write (Group)</td>
</tr>
<tr>
<td dir="auto">000  000  100  000</td>
<td dir="ltr">Read (Group)</td>
</tr>
<tr>
<td dir="auto">000  001  000  000</td>
<td dir="ltr">Execute (Owner)</td>
</tr>
<tr>
<td dir="auto">000  010  000  000</td>
<td dir="ltr">Write (Owner)</td>
</tr>
<tr>
<td dir="auto">000  100  000  000</td>
<td dir="ltr">Read (Owner)</td>
</tr>
<tr>
<td dir="auto">001  000  000  000</td>
<td dir="ltr">Sticky bit</td>
</tr>
<tr>
<td dir="auto">010  000  000  000</td>
<td dir="ltr">Set GID</td>
</tr>
<tr>
<td dir="auto">100  000  000  000</td>
<td dir="ltr">Set UID</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">我们用<code>ls -alh</code>命令就会看到相关的<code>i_mode</code>信息，如：</p></div><div class="el-pre"><pre><code data-line="0">du@du-virtual-machine:~/Desktop/OS$ ls -alh
total 136K
drwxrwxr-x 3 du du 4.0K  8月 30 02:05 .
drwxr-xr-x 7 du du 4.0K  8月  8 05:09 ..
drwxrwxr-x 2 du du 4.0K  7月  1 00:51 critical_section
-rwxrwxr-x 1 du du  17K  7月  2 13:50 mutex
-rw-rw-r-- 1 du du 1.2K  7月  2 13:50 Mutex_locks.c
......
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.4.2 Indexing Inode" dir="auto" class="heading" id="6.2.4.2_Indexing_Inode"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.4.2 Indexing Inode</h5><div class="heading-children"><div class="el-p"><p dir="auto">inode本身并不存储数据信息，其会通过存放指向数据块的<strong>索引表</strong>来引用文件的实际内容。通常情况下，一个inode对应一个文件或目录，但通过硬链接，可以有多个文件名指向同一个inode。</p></div><div class="el-p"><p dir="auto">索引文件数据块是inode最重要的功能，inode也因此得名（<strong>i</strong>ndex-<strong>node</strong>）。inode通过一张索引表来索引文件文件块，这个索引表有15个字段，每个字段4字节，共60字节。记录了指向一个数据块的指针。其中有<strong>直接块(direct block)</strong>、<strong>单级间接块(single indirect)</strong>、<strong>双级间接块(double indirect)</strong>、<strong>三级间接块(triple indirect)</strong>。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240825181709.png" src="Pasted image 20240825181709.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825181709.png" src="congzhi's-os-series/pics/pasted-image-20240825181709.png"></span></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>直接块指针</strong>：每个inode包含12个直接块指针，直接块指针直接指向一个数据块。</li>
<li data-line="2" dir="auto"><strong>单级间接块指针</strong>：一个单级间接块指针指向一个间接块表，间接块表中包含指向数据块的指针。若一个块4KB，每个指针大小为4字节，那么一个间接块表可以包含1024个直接块指针。</li>
<li data-line="4" dir="auto"><strong>双级间接块指针</strong>：一个双级间接块指针指向一个间接块表，间接块表中的每个指针又指向另一个间接块表。这样可以寻址更多的数据块。</li>
<li data-line="6" dir="auto"><strong>三级间接块指针</strong>：一个三级间接块指针指向一个间接块表，间接块表中的每个指针指向另一个间接块表，依次类推，直到最终指向数据块。</li>
</ol></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.4.3 Calculating Maximum File Storage" dir="auto" class="heading" id="6.2.4.3_Calculating_Maximum_File_Storage"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.4.3 Calculating Maximum File Storage</h5><div class="heading-children"><div class="el-p"><p dir="auto">通过多级间接寻址方式，ext2文件系统理论上能够在32位系统上支持高达4TB的文件大小。具体计算如下，假如一个块的大小为4KB：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">直接块：12个块</li>
<li data-line="1" dir="auto">单级间接块：1024个块</li>
<li data-line="2" dir="auto">双级间接块：1024 * 1024个块</li>
<li data-line="3" dir="auto">三级间接块：1024 <em> 1024 </em> 1024个块</li>
</ul></div><div class="el-p"><p dir="auto">总共可以寻址的块数为：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>总共可以寻址的文件大小为:<br>
<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-cD7"></mjx-c></mjx-mi><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4B"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span></p></div><div class="el-p"><p dir="auto">然而，实际上文件大小限制还要收到文件系统实现和内核的限制。根据<a data-tooltip-position="top" aria-label="https://docs.kernel.org/filesystems/ext2.html" rel="noopener nofollow" class="external-link" href="https://docs.kernel.org/filesystems/ext2.html" target="_blank">相关的Linux文档</a>，当块大小为1KB时，单个文件大小限制在16GB，2KB的块为256GB的文件大小限制，块大小更大时，单个文件最大大小为2TB。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.5 Dirctories" dir="auto" class="heading" id="6.2.5_Dirctories"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.5 Dirctories</h4><div class="heading-children"><div class="el-p"><p dir="auto">在ext2文件系统中，目录也是以文件的形式存储在磁盘上的，目录文件的文件控制块（FCB）也是一个inode。在目录文件中包括许多<strong>目录项(Entry)</strong>，<strong>文件名和其inode编号</strong>就存放在目录项中，通过这一对文件信息可以检索到某一个文件。这些目录项使得操作系统可以通过文件名查找到对于文件的inode，进而访问文件的元数据和实际内容。目录项包含以下内容：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">Size in Bytes</th>
<th align="center" dir="ltr">Field Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">Inode</td>
</tr>
<tr>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">Total size of this entry</td>
</tr>
<tr>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">Name length</td>
</tr>
<tr>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">Type indicator</td>
</tr>
<tr>
<td align="center" dir="ltr">N</td>
<td align="center" dir="ltr">Name character</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">其中<strong>文件类型</strong>有以下几种：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">Value</th>
<th align="center" dir="ltr">Type Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">Reserved</td>
</tr>
<tr>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">Regular file</td>
</tr>
<tr>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">Directory</td>
</tr>
<tr>
<td align="center" dir="auto">3</td>
<td align="center" dir="ltr">Character device</td>
</tr>
<tr>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">Block device</td>
</tr>
<tr>
<td align="center" dir="auto">5</td>
<td align="center" dir="ltr">FIFO pipe file</td>
</tr>
<tr>
<td align="center" dir="auto">6</td>
<td align="center" dir="ltr">Socket</td>
</tr>
<tr>
<td align="center" dir="auto">7</td>
<td align="center" dir="ltr">Symbolic link(Soft link)</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">ext2文件系统用单链表来存储目录中的文件名；在改进后的版本中，使用文件名的哈希值来进行查找，免去了对整个文件目录的扫描。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="6.2.5.1 How Do You Get a inode" dir="auto" class="heading" id="6.2.5.1_How_Do_You_Get_a_inode"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.5.1 How Do You Get a inode</h5><div class="heading-children"><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>通过文件名获取inode编号</strong>：使用目录项（directory entry）查找文件名对应的inode编号。</li>
<li data-line="2" dir="auto"><strong>读取超级块</strong>：获取文件系统的基本信息，包括每个块的大小、每个块组中的块数量、每个块组中的inode数量以及块组描述符表的起始块位置。</li>
<li data-line="4" dir="auto"><strong>确定inode所属的块组</strong>：根据inode编号和每个块组中的inode数量，计算出inode所属的块组。</li>
<li data-line="6" dir="auto"><strong>读取块组描述符</strong>：读取对应块组的块组描述符，获取该块组的详细信息。</li>
<li data-line="8" dir="auto"><strong>提取inode表的位置</strong>：从块组描述符中提取该块组的inode表的起始位置。</li>
<li data-line="10" dir="auto"><strong>确定inode在inode表中的索引位置</strong>：根据inode编号和inode表的起始位置，计算出inode在inode表中的具体位置。</li>
<li data-line="12" dir="auto"><strong>读取指定的inode</strong>：通过索引inode表，读取出指定的inode，获取文件的元数据和指向数据块的指针。</li>
</ol></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.6 Consistency Check (e2fsck)" dir="auto" class="heading" id="6.2.6_Consistency_Check_(e2fsck)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.6 Consistency Check (e2fsck)</h4><div class="heading-children"></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第七课 Concurrency in File Systems" dir="auto" class="heading" id="第七课_Concurrency_in_File_Systems"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第七课 Concurrency in File Systems</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">通过第六课的学习，我们已经对inode有了一定的认识，inode是类Unix系统中用于表示文件的数据结构。Inode意为索引节点，通过inode，我们可以对文件数据进行索引，这是inode的两个最主要的作用。如果有多个进程想要并发地使用同一个文件，我们该怎么做？我们先从文件锁开始介绍。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="7.1 File Locking" dir="auto" class="heading" id="7.1_File_Locking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1 File Locking</h3><div class="heading-children"><div class="el-p"><p dir="auto">对一个文件的读写实际上就是我们在之前在同步问题中学到的读者写者问题。当文件打开时，程序会获得该文件的引用。如果你不想其他的应用程序使用文件，防止数据竞争和不一致问题，我们就可以将文件给锁起来。我们用<code>fcntl</code>系统调用来实现文件锁。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.1 This is All Mine" dir="auto" class="heading" id="7.1.1_This_is_All_Mine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.1 This is All Mine</h4><div class="heading-children"><div class="el-p"><p dir="auto">POSIX有个系统调用<code>flock()</code>，我们可以用它来对文件进行加锁。下面实现了一个对文件的互斥锁（一个写锁）。<code>flock()</code>有两个字段，第二个属性字段除了<code>LOCK_EX</code>之外，还有<code>LOCK_SH</code>用于设置一个共享的锁、<code>LOCK_UN</code>对锁进行解锁。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/file.h&gt;</span></span>
FILE<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"example.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">fileno</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">flock</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> LOCK_EX<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>flock()</code>的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/file.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">flock</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> operation<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to be locked.
2. operation: Operation to be performed (e.g., LOCK_SH for shared lock, LOCK_EX for exclusive lock, LOCK_UN for unlocking).

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这种写锁（<code>LOCK_EX</code>）只允许一个进程访问文件，对整个文件都进行了加锁。如此，其他进程不能读写该文件，如果我们想要对文件进行粒度更细的管理怎么办？我们可以使用POSIX提供的<code>fctnl</code>系统调用。 </p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.2 Me Get My Share" dir="auto" class="heading" id="7.1.2_Me_Get_My_Share"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2 Me Get My Share</h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>fcntl()</code> 提供了更复杂和灵活的文件锁定机制，支持对文件的部分区域进行锁定。通常情况下，部分锁定(partial locking)也会被称为记录锁定(record locking)。我们常常在data record中看到这种记录锁定。我们现在其实并不怎么使用这种部分锁定，因为有数据库在背后帮我们处理这些事情。</p></div><div class="el-p"><p dir="auto">通过将文件划分成多个部分，例如6个部分，我们最多可以同时有6个程序对文件进行读写操作。<code>fcntl()</code>是一个强大的系统调用，命令字段实际上有很多参数信息。我们在这里只讨论关于文件锁的部分信息。以下是 <code>fcntl()</code> 的原型：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* struct flock *lock */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Parameters:

1. fd: File descriptor of the file to be locked.
2. cmd: Command to be performed. Common file locking commands include:
   - F_GETLK: Get record locking information.
   - F_SETLK: Set record locking information (non-blocking).
   - F_SETLKW: Set record locking information (blocking).
3. lock: Pointer to a struct flock that specifies the lock parameters (used with F_GETLK, F_SETLK, and F_SETLKW).

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.2.1 Struct flock" dir="auto" class="heading" id="7.1.2.1_Struct_flock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2.1 Struct flock</h5><div class="heading-children"><div class="el-p"><p dir="auto">这个系统调用的第一个参数是文件描述符，第二个参数是一些关于文件锁的一些命令，第三个参数是一个指向<code>flock</code>结构体的指针，这个结构体如下，这些字段并不难理解：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">flock</span> <span class="token punctuation">{</span>
	<span class="token keyword">short</span> l_type<span class="token punctuation">;</span>    <span class="token comment">// F_RDLCK, F_WRLCK, F_UNLCK</span>
	<span class="token keyword">short</span> l_whence<span class="token punctuation">;</span>  <span class="token comment">// SEEK_SET, SEEK_CUR, SEEK_END</span>
	<span class="token class-name">off_t</span> l_start<span class="token punctuation">;</span>   <span class="token comment">// offsets in bytes, relative to l_whence</span>
	<span class="token class-name">off_t</span> l_len<span class="token punctuation">;</span>     <span class="token comment">// length in bytes; 0 means lock to EOF</span>
	<span class="token class-name">pid_t</span> l_pid<span class="token punctuation">;</span>     <span class="token comment">// returned lock owner's PID with F_GETLK, otherwise return 0</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过设置<code>l_len</code>字段，我们事实上可以将整个文件区域进行锁定，我们需要设置<code>l_len = 0;</code></p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.2.2 Да, Comrade!" dir="auto" class="heading" id="7.1.2.2_Да,_Comrade!"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2.2 Да, Comrade!</h5><div class="heading-children"><div class="el-p"><p dir="auto">下面，我们来看<code>fcntl</code>的第二个参数。和文件锁相关的有三个命令，第一个命令<code>F_GETLK</code>就是检查指定的区域是否被其他进程所锁定。如果被锁定，那将把<code>l_type</code>设置为不同的锁类型并在<code>l_pid</code>字段返回持有锁进程的ID，如果没有被锁定，那就会将<code>l_type</code>设置为<code>F_UNLCK</code>。但是这个命令作用并不大，因为<code>F_GETLK</code>的检查并不是原子化的（我们检查时可能发生状态变化）。</p></div><div class="el-p"><p dir="auto">下面的两个命令<code>F_SETLK</code>和<code>F_SETLKW</code>（set lock wait），两个命令的作用实际上非常相似，只是阻塞和非阻塞的区别。<code>F_SETLK</code>会尝试设置指定的锁定区域。如果锁定区域被其他进程锁定，调用将失败并返回 -1，并不会等待区域变为可用（和try_lock很像）；而<code>F_SETLKW</code>会在检查到区域锁定后阻塞并等待，直到锁定区域变为可用或接收到一个信号中断。</p></div><div class="el-p"><p dir="auto">在应用中，我们并不会先检查指定区域是否可用后将区域锁定，而是通过<code>F_SETLK</code>的方式设置锁，如果当前程序可以等，那就将其阻塞，使用<code>F_SETLKW</code>确保程序后续能够将区域锁定。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.2.3 Lock Unlock Example" dir="auto" class="heading" id="7.1.2.3_Lock_Unlock_Example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2.3 Lock Unlock Example</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">write_lock_file</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token keyword">struct</span> <span class="token class-name">flock</span> fl<span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_type <span class="token operator">=</span> F_WRLOCK<span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_whence <span class="token operator">=</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Lock the entire file due to l_len = 0</span>

	<span class="token keyword">return</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETLK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">unlock_file</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token keyword">struct</span> <span class="token class-name">flock</span> fl<span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_type <span class="token operator">=</span> F_UNLOCK<span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_whence <span class="token operator">=</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">;</span>
	fl<span class="token punctuation">.</span>l_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Unlock the entire file</span>

	<span class="token keyword">return</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETLK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Lock the part of the file:</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"example.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">flock</span> fl<span class="token punctuation">;</span>
fl<span class="token punctuation">.</span>l_type <span class="token operator">=</span> F_RDLOCK<span class="token punctuation">;</span>
fl<span class="token punctuation">.</span>l_start <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
fl<span class="token punctuation">.</span>l_whence <span class="token operator">=</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">;</span>
fl<span class="token punctuation">.</span>l_len <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>

<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETLK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>fl<span class="token punctuation">.</span>l_type <span class="token operator">==</span> F_UNLCK<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// Lock is unlocked, we may proceed.</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fl<span class="token punctuation">.</span>l_type <span class="token operator">==</span> F_WRLOCK<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"File is locked by process ID %d.\n"</span><span class="token punctuation">,</span> fl<span class="token punctuation">.</span>l_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.3.4 Be Aware" dir="auto" class="heading" id="7.1.3.4_Be_Aware"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.3.4 Be Aware</h5><div class="heading-children"><div class="el-p"><p dir="auto">使用<code>fcntl</code>有两个缺点，那就是你要用重用结构体的话那就需要将结构体reset，你还需要确保字段的正确设置；此外，代码的逻辑需要额外地注意，当<code>F_SETLK</code>返回-1时，后续的逻辑流就不能够再出现相关<code>F_UNLOCK</code>的操作。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.3 lockf IS NOT flock" dir="auto" class="heading" id="7.1.3_lockf_IS_NOT_flock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.3 lockf IS NOT flock</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果你不想让文件锁定操作那样复杂，那你可以使用<code>lockf</code>系统调用。在一些系统上，<code>lockf</code>是由<code>fcntl</code>系统调用封装而来的，但有的系统可能使用其他的机制。所以当你lock a file时，确保使用同样的系统调用来lock and unlock，避免可能出现的一些未定义行为。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">lockf</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token class-name">off_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:

1. fd: File descriptor of the file to be locked.
2. command: Command to be performed. Common commands include:
   - F_LOCK: Lock a section of the file.(blocking)
   - F_TLOCK: Try to lock a section of the file (non-blocking).
   - F_ULOCK: Unlock a section of the file.
   - F_TEST: Test a section of the file for locks held by other processes.
3. length: Length of the section to be locked, in bytes. A value of 0 means to lock from the current position to the end of the file.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.4 Advisor Locks and Mandatory Locks" dir="auto" class="heading" id="7.1.4_Advisor_Locks_and_Mandatory_Locks"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.4 Advisor Locks and Mandatory Locks</h4><div class="heading-children"><div class="el-p"><p dir="auto">mandatory locks do exist,but are hard to use and not recommended</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.5 Using File as a Lock" dir="auto" class="heading" id="7.1.5_Using_File_as_a_Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.5 Using File as a Lock</h4><div class="heading-children"><div class="el-p"><p dir="auto">除了上述我们学习过的这些文件锁，我们可以用文件来控制文件的并发访问。将一个文件的存在当作一把锁，如果文件存在，则说明区域已被锁定。Git会通过在特定的目录处放置一个<code>index.lock</code>的文件来指示进行中的操作。通过这个文件，git就能避免多个git客户端同时操作一个repo。</p></div><div class="el-p"><p dir="auto">为了实现这种机制，我们可以使用以下的系统调用：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> old_filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> new_filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>open</code>系统调用有许多选项，在这种情形下，我们并不想使用”如果文件存在，则打开文件“的<code>open</code>系统调用。我们想要系统告诉我们：”如果文件存在，则创建失败并返回错误码“。所以我们要用<code>O_CREAT</code>和<code>O_EXCL</code>这两个flags。前者是创建文件，后者是exclusive的缩写，当两个一起使用时，就会在文件存时返回失败并设置<code>errno</code>为<code>EEXIST</code>。</p></div><div class="el-p"><p dir="auto">用于<code>open</code>系统调用是原子化的，所以实际上避免了多个进程的并发问题。在操作完成后，我们用<code>remove</code>系统调用来删除文件，让下一个用户进程对文件或repo进行操作。</p></div><div class="el-p"><p dir="auto">那<code>rename</code>系统调用是做什么的？<code>rename</code>系统调用和<code>open</code>一样，也是原子化的。这样，我们其实可以单单用<code>rename</code>来进行lock和unlock操作。改名就是锁定，解锁呢，就是将文件名改回来。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="7.2 Concurrency in VCS" dir="auto" class="heading" id="7.2_Concurrency_in_VCS"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.2 Concurrency in VCS</h3><div class="heading-children"><div class="el-p"><p dir="auto">前面我们介绍了如何用文件作为锁来控制并发。在版本控制系统中，我们常常会看到两种不同的并发控制策略，分别是<code>Lock-Modify-Unlock</code> 和 <code>Copy-Modify-Merge</code>（也称为 <code>Lock-Modify-Merge</code>），它们在不同的场景下被使用。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.2.1 Lock-Modify-Unlock" dir="auto" class="heading" id="7.2.1_Lock-Modify-Unlock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.2.1 Lock-Modify-Unlock</h4><div class="heading-children"><div class="el-p"><p dir="auto">Lock-Modify-Unlock常会用在集中式的版本控制系统中。在开发者修改文件之前，首先锁定文件，防止其他人同时修改（lock）；之后，开发者对文件进行修改（modify）；完成后解锁文件，运行其他人对文件进行修改（unlock）。以下是我们用文件作为锁对这种方式的简单实现：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token keyword">int</span> lock_fd<span class="token punctuation">;</span>
<span class="token keyword">int</span> shared <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span><span class="token string">"file.lock"</span><span class="token punctuation">,</span> <span class="token string">"file.unlock"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// Lock the lock</span>
        <span class="token comment">// thread is waiting.</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// thread in critical section</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d is in the critical section.\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Shared incremented from %d"</span><span class="token punctuation">,</span> shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" to %d.\n"</span><span class="token punctuation">,</span> shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rename</span><span class="token punctuation">(</span><span class="token string">"file.unlock"</span><span class="token punctuation">,</span> <span class="token string">"file.lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unlock the lock.</span>
    
    <span class="token function">free</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/* Write data implementation not shown*/</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>
    lock_fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"file.lock"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_EXCL<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lock_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"File creation failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>id <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> run<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>lock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"file.lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这种方法确保了在修改期间没有其他人可以修改同一个文件，从而避免了冲突。然而，它也可能导致开发效率降低，因为其他开发者在等待锁释放时无法进行修改。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241207162851.png" src="Pasted image 20241207162851.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241207162851.png" src="congzhi's-os-series/pics/pasted-image-20241207162851.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.2.2 Copy-Modify-Merge" dir="auto" class="heading" id="7.2.2_Copy-Modify-Merge"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.2.2 Copy-Modify-Merge</h4><div class="heading-children"><div class="el-p"><p dir="auto">而在分布式版本控制系统，如git中，有了分支的概念。多个开发者可以把代码从远程仓库复制到本地，每个开发者可以在自己的分支上独立开发，并行工作（copy-modify）；修改完成后，开发者可以将自己的分支合并到主分支，git会自动处理大部分的合并（merge）。</p></div><div class="el-p"><p dir="auto">对文件的这些修改会被记录到项目的提交记录中。如果两个分支修改了同一文件的同一部分，那么这些修改将不会被自动合并，我们称之为冲突（conflict）。如果出现冲突，合并操作将暂停，直到冲突被手动解决。</p></div><div class="el-p"><p dir="auto">为了避免不连续性，合并操作要么成功，要么失败，这是由事务机制实现的。<strong>事务(transaction)</strong> 相当于要一气呵成完成的一组操作，一个事务有两个开始事务和结束事务两个状态。在merge的过程中，对合并文件的一些检查会用一个log记录下来来进行检查，对事务的检查是不可中断的，如果发生冲突那么合并就会失败并回退到之前的状态（roll-back）并等待开发者的手动解决。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.3 Linux-Only inotify" dir="auto" class="heading" id="7.3_Linux-Only_inotify"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.3 Linux-Only inotify</h4><div class="heading-children"><div class="el-p"><p dir="auto">实际上，inotify应当被单拎出来。inotify是内核为我们提供的监视文件系统是否有事件发生的工具，它可以监控文件或目录的各种事件，如创建、删除、修改等。它本身并不是一个并发控制的工具，但一些情况下，inotify可以在并发控制中起到一些辅助的作用。</p></div><div class="el-p"><p dir="auto">利用inotify API，你可以让你的程序对一些事件做出反应，比方说当某个文件被打开，程序做出一些响应。要让inotify给你发消息，你需要遵循以下步骤：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">
<p><strong>初始化并创建一个管理结构</strong>：使用<code>inotify_init</code>函数初始化<code>inotify</code>实例，并获取一个文件描述符，用于管理这些事件。</p>
</li>
<li data-line="2" dir="auto">
<p><strong>添加监控事件</strong>：使用<code>inotify_add_watch</code>函数告诉内核你想监控哪些事件，并将这些事件加入到<code>inotify</code>实例中。</p>
</li>
<li data-line="4" dir="auto">
<p><strong>读取事件</strong>：内核会通过文件描述符通知进程事件发生的信息。你可以使用<code>read</code>函数读取这些事件，并根据需要进行处理。</p>
</li>
<li data-line="6" dir="auto">
<p><strong>关闭文件描述符</strong>：完成后，使用<code>close</code>函数关闭文件描述符，释放资源。</p>
</li>
</ol></div><div class="el-p"><p dir="auto">值得注意的是，这个过程不是递归的。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.3.1 inotify System Calls" dir="auto" class="heading" id="7.3.1_inotify_System_Calls"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.3.1 inotify System Calls</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们有以下系统调用，初始化inotify的系统调用很好理解，即初始化创建一个inotify实例，一旦实例被创建，内核就会设置必要的数据结构和资源来管理inotify子系统。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/inotify.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">inotify_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters: None

Return value: Returns a file descriptor for the inotify instance on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241207225739.png" src="Pasted image 20241207225739.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241207225739.png" src="congzhi's-os-series/pics/pasted-image-20241207225739.png"></span></p></div><div class="el-p"><p dir="auto">实例创建完之后，我们就要用<code>inotify_add_watch()</code>来指定你想要以监视的文件或目录。系统调用<code>inotify_add_watch()</code>会返回一个监视描述符，用于唯一标识的监视项（文件）。另一个系统调用<code>inotify_rm_watch()</code>是将特定的wd从inotify instance中删去。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">inotify_add_watch</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:

1. fd: File descriptor returned by inotify_init.
2. pathname: Path to the file or directory to be monitored.
3. mask: Bitmask of events to be monitored. Common events include:
   - IN_ACCESS: File was accessed.(Read/Execute)
   - IN_MODIFY: File was modified.(Write for example)
   - IN_ATTRIB: Metadata changed.
   - IN_CLOSE_WRITE: File opened for writing was closed.
   - IN_CLOSE_NOWRITE: File not opened for writing was closed.
   - IN_OPEN: File was opened.
   - IN_MOVED_FROM: File was moved out of the watched directory.
   - IN_MOVED_TO: File was moved into the watched directory.
   - IN_CREATE: File or directory was created.
   - IN_DELETE: File or directory was deleted.
   - IN_DELETE_SELF: Watched file or directory was deleted.

Return value: Returns a watch descriptor on success, otherwise -1.
*/</span>

<span class="token keyword">int</span> <span class="token function">inotify_rm_watch</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> wd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:
1. fd: File descriptor returned by inotify_init.
2. wd: Watch descriptor returned by inotify_add_watch.

Return value: Returns 0 on success, otherwise -1.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.3.2 Event Struct" dir="auto" class="heading" id="7.3.2_Event_Struct"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.3.2 Event Struct</h4><div class="heading-children"><div class="el-p"><p dir="auto">之后你可以<code>read(fd, buf, size)</code>，阻塞直到相应的事件发生。当你要监视的事件发生，inotify会将事件信息填充到 <code>inotify_event</code> 结构体中，并通过初始化得到的文件描述符返回给你。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span>         wd<span class="token punctuation">;</span>      <span class="token comment">// Watch descriptor</span>
    <span class="token class-name">uint32_t</span>    mask<span class="token punctuation">;</span>    <span class="token comment">// Bitmask of events that occurred</span>
    <span class="token class-name">uint32_t</span>    cookie<span class="token punctuation">;</span>  <span class="token comment">// Unique cookie associating related events</span>
    <span class="token class-name">uint32_t</span>    len<span class="token punctuation">;</span>     <span class="token comment">// Length of the name field</span>
    <span class="token keyword">char</span>        name<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Optional null-terminated name of the file</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">由于最有一个字段是可选的，因而<code>inotify_event</code>结构体大小为：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">event_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span><span class="token punctuation">)</span> <span class="token operator">+</span> inotify_event<span class="token punctuation">.</span>len<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">由于长度是不确定的，由此我们想要设置缓冲区时可能会设置的过大或过小。在设置缓冲区之前，我们可以用<code>ioctl(inotify_fd, FIONREAD, &amp;numbytes)</code>先获取文件当前可读取的长度。但一般情况下，我们会用空间换时间。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.3.2 An Example" dir="auto" class="heading" id="7.3.2_An_Example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.3.2 An Example</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/inotify.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>

<span class="token keyword">const</span> <span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"file.lock"</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> lockFD<span class="token punctuation">;</span>
    bool our_turn <span class="token operator">=</span> false<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>our_turn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lockFD <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_EXCL <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lockFD <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The lock file is existing, and process %ld will wait...\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> notifyFD <span class="token operator">=</span> <span class="token function">inotify_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">uint32_t</span> watch <span class="token operator">=</span> <span class="token function">inotify_add_watch</span><span class="token punctuation">(</span>notifyFD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> IN_DELETE_SELF<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> buf_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">char</span><span class="token operator">*</span> event_buffer <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Setup complete, waiting for event.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token comment">// Read the file descriptor while the event happens.(blocking)</span>
            <span class="token function">read</span><span class="token punctuation">(</span>notifyFD<span class="token punctuation">,</span> event_buffer<span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">struct</span> <span class="token class-name">inotify_event</span><span class="token operator">*</span> event <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span><span class="token operator">*</span><span class="token punctuation">)</span>event_buffer<span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Event occurred!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">free</span><span class="token punctuation">(</span>event_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">inotify_rm_watch</span><span class="token punctuation">(</span>notifyFD<span class="token punctuation">,</span> watch<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">close</span><span class="token punctuation">(</span>notifyFD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> namelen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">write</span><span class="token punctuation">(</span>lockFD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> namelen<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token function">close</span><span class="token punctuation">(</span>lockFD<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            our_turn <span class="token operator">=</span> true<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Process %ld is in the critical area.\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// remove(filename);</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第八课 Consistency Checking and Journalling" dir="auto" class="heading" id="第八课_Consistency_Checking_and_Journalling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第八课 Consistency Checking and Journalling</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.1 Data Consistency" dir="auto" class="heading" id="8.1_Data_Consistency"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1 Data Consistency</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们用文件系统管理磁盘来存储我们所需要的数据。然而，由于某些情况，文件系统中也可能会发生数据的丢失或数据的不连续（如系统掉电而文件还没有来得及写回磁盘）。为了发现文件系统中数据的不连续，我们可以周期性地检查系统中不连续的数据。</p></div><div class="el-p"><p dir="auto">但由于一个volume可能很大，而且磁盘又很慢，所以检查一个volume上是否有不连续性的数据会很耗费时间。因此，系统在运行时并不会主动扫描磁盘。一般而言，系统启动的时候或者用户下达命令时才会扫描volume。UNIX中，用户可以使用 <code>fsck</code> 系统调用来扫描磁盘；Windows中，则可以使用 <code>chkdsk/scandisk</code>。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.1.1 Inconsistent State" dir="auto" class="heading" id="8.1.1_Inconsistent_State"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.1 Inconsistent State</h4><div class="heading-children"><div class="el-p"><p dir="auto">那么，什么是不连续状态？文件不连续后操作系统会如何反应？我们提到了系统掉电而文件没有来得及写回磁盘的情况。当系统重新上电后，我们会发现一部分文件块由于掉电时在内存中而遗失掉了，这就是文件的不连续状态。不连续的文件可能会导致一些严重的问题。</p></div><div class="el-p"><p dir="auto">例如，我们本来要创建一个大小10个块的文件，在FCB中文件大小字段中就将其标识为10个磁盘块。然而，之后的文件链表中只包含有5个块。当使用这些系统调用工具检查出不连续状态时，我们希望系统能够把遗失的块找回来并链在一起，但文件系统可能并不能这么做，文件系统会修改相关的信息（如FCB的文件大小字段修改为5），从而保证文件的连续性。</p></div><div class="el-p"><p dir="auto">系统视角下的recovery和我们想象中的recovery好像并不太一样，但不论怎样，现在文件是连续的了，系统内没有错误了。任务完成！</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.1.2 Transaction" dir="auto" class="heading" id="8.1.2_Transaction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.2 Transaction</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们当然希望避免不连续问题的发生，以防因此出现严重的系统故障。避免因一些错误导致的数据不连续，你可能会想到原子操作。实际上，我们要使用避免数据不连续的方法<strong>事务</strong>其实我们可以看作原子操作的一种变种。事务使得操作要么完美地完成，要么就什么都不做。当今几乎所有的文件系统都会使用事务来避免data inconsistency的发生。</p></div><div class="el-p"><p dir="auto">在版本控制系统和数据库中，为了使每个版本的数据都是连续的，这些软件会在修改文件相关结构之前，先列出一个待办事项清单。当这个待办事项清单中的所有待做项都完成之后，我们才会认为这个事务结束了，系统随之修改相关的数据结构。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.1.3 Transaction in ZFS (Single-Atomic-Update)" dir="auto" class="heading" id="8.1.3_Transaction_in_ZFS_(Single-Atomic-Update)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.3 Transaction in ZFS (Single-Atomic-Update)</h4><div class="heading-children"><div class="el-p"><p dir="auto">ZFS使用single-atomic-update的事务机制来避免磁盘上的不连续性，这种机制类似于copy-modify-merge模型。数据先是从磁盘拷贝到内存，之后修改拷贝的磁盘块，最后将拷贝写回磁盘。这些修改后的新数据写回磁盘是并不会覆盖原旧数据块，而是将拷贝写到新磁盘块。这样其实为操作提供了冗余，如果写磁盘不连续，我们可以抛弃写回的数据块（即什么也不做）。如果操作一切顺利，那么我们就可以将旧磁盘块的引用用新的磁盘块所替代。</p></div><div class="el-p"><p dir="auto">如果磁盘空间满了怎么办呢？那就买一块更大的后备硬盘吧！</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.2 APFS(Apple File System)" dir="auto" class="heading" id="8.2_APFS(Apple_File_System)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2 APFS(Apple File System)</h3><div class="heading-children"><div class="el-p"><p dir="auto">APFS引入了文件系统快照(snapshots)，记录了某一时刻的文件系统状态。快照可以用于备份和恢复，确保在发生数据损坏或丢失时能够快速恢复到之前的状态。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.3 NTFS(Windows FS)" dir="auto" class="heading" id="8.3_NTFS(Windows_FS)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3 NTFS(Windows FS)</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.1 NTFS Volume Layout" dir="auto" class="heading" id="8.3.1_NTFS_Volume_Layout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.1 NTFS Volume Layout</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.2 Transaction in NTFS" dir="auto" class="heading" id="8.3.2_Transaction_in_NTFS"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.2 Transaction in NTFS</h4><div class="heading-children"><div class="el-p"><p dir="auto">在NTFS中，所有对文件元数据的修改都会顺序地放到一个日志文件(log文件)中，一旦修改写入日志文件后，系统才会实际修改文件的元数据。这种机制被称为日志记录(journaling)。当系统修改完文件的元数据后，系统会将日志文件中标记为“已完成”的日志记录（事务）进行相应的清理。</p></div><div class="el-p"><p dir="auto">之后，当系统崩溃，日志文件中就可能包括0个或多个事务待处理。0个当然最好，你不需要担心任何事；如果届时日志文件中有多个事务还没有处理，就意味着仍有事务没有完成。我们将有两种解决方案：前进和回退。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.3.2.1 Roll-Forward" dir="auto" class="heading" id="8.3.2.1_Roll-Forward"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.2.1 Roll-Forward</h5><div class="heading-children"><div class="el-p"><p dir="auto">当系统上电后，如果这个清单可以接着之前的做，那当然最好，我们实际上并没有损失什么。比如下载软件到一半之后，系统掉电，但是上电后我们可以接着之前的继续下载。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.3.2.2 Roll-Back" dir="auto" class="heading" id="8.3.2.2_Roll-Back"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.2.2 Roll-Back</h5><div class="heading-children"><div class="el-p"><p dir="auto">如果事务不能接着之前的做，系统就会回退到之前的版本，也就是在版本控制系统中常见的方式。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.4 NTFS Journalling" dir="auto" class="heading" id="8.3.4_NTFS_Journalling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.4 NTFS Journalling</h4><div class="heading-children"><div class="el-p"><p dir="auto">在NTFS中，日志记录的实现如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p>当需要对文件元数据进行修改时，首先将这些修改记录在缓存中的日志文件里。这一步确保了所有修改操作都有一个记录，以防在实际写入磁盘之前发生故障。</p>
</li>
<li data-line="2" dir="auto">
<p>在日志文件中记录修改后，系统会在缓存中进行实际的卷修改。这意味着这些修改还没有真正写入物理磁盘，但已经在内存中准备好了。</p>
</li>
<li data-line="4" dir="auto">
<p>缓存管理器（cache manager）负责将缓存中的日志文件写入到物理磁盘上。这一步非常关键，因为它确保了日志记录的持久性，即使系统在此后崩溃，日志文件中的修改记录也不会丢失。</p>
</li>
<li data-line="6" dir="auto">
<p>日志文件写入磁盘后，缓存管理器会开始将缓存中的卷修改写入到物理磁盘上。这一步确保了文件系统的一致性，因为即使在卷的实际修改过程中发生了系统故障，日志文件中的记录仍然可以用于恢复未完成的修改。</p>
</li>
</ul></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第九课 Reliability: RAID" dir="auto" class="heading" id="第九课_Reliability:_RAID"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第九课 Reliability: RAID</h2><div class="heading-children"><div class="el-hr"><hr></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第十课 Reliability: Fail-Soft Operations" dir="auto" class="heading" id="第十课_Reliability:_Fail-Soft_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第十课 Reliability: Fail-Soft Operations</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#15. File Systems"><div class="tree-item-contents heading-link" heading-name="
File Systems
"><span class="tree-item-title">File Systems</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第一课_Peek_into_File_System"><div class="tree-item-contents heading-link" heading-name="第一课 Peek into File System"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课 Peek into File System</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.1_Persistent_Storage"><div class="tree-item-contents heading-link" heading-name="1.1 Persistent Storage"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Persistent Storage</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.1.1_HDD"><div class="tree-item-contents heading-link" heading-name="1.1.1 HDD"><span class="tree-item-title">1.1.1 HDD</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.1.2_SSD"><div class="tree-item-contents heading-link" heading-name="1.1.2 SSD"><span class="tree-item-title">1.1.2 SSD</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2_File_Concept"><div class="tree-item-contents heading-link" heading-name="1.2 File Concept"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.2 File Concept</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.1_File_Metadata"><div class="tree-item-contents heading-link" heading-name="1.2.1 File Metadata"><span class="tree-item-title">1.2.1 File Metadata</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2_File_Types"><div class="tree-item-contents heading-link" heading-name="1.2.2 File Types"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.2.2 File Types</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.1_Regular_Files"><div class="tree-item-contents heading-link" heading-name="1.2.2.1 Regular Files"><span class="tree-item-title">1.2.2.1 Regular Files</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.2_Directories"><div class="tree-item-contents heading-link" heading-name="1.2.2.2 Directories"><span class="tree-item-title">1.2.2.2 Directories</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.3_Symbolic_Links"><div class="tree-item-contents heading-link" heading-name="1.2.2.3 Symbolic Links"><span class="tree-item-title">1.2.2.3 Symbolic Links</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.4_Special_Files"><div class="tree-item-contents heading-link" heading-name="1.2.2.4 Special Files"><span class="tree-item-title">1.2.2.4 Special Files</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.5_Sockets"><div class="tree-item-contents heading-link" heading-name="1.2.2.5 Sockets"><span class="tree-item-title">1.2.2.5 Sockets</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.2.2.6_FIFO(Named_Pipes)"><div class="tree-item-contents heading-link" heading-name="1.2.2.6 FIFO(Named Pipes)"><span class="tree-item-title">1.2.2.6 FIFO(Named Pipes)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.3_File_System_Structure_Design"><div class="tree-item-contents heading-link" heading-name="1.3 File System Structure Design"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3 File System Structure Design</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.3.1_I/O_Control"><div class="tree-item-contents heading-link" heading-name="1.3.1 I/O Control"><span class="tree-item-title">1.3.1 I/O Control</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.3.2_Basic_File_System_Layer"><div class="tree-item-contents heading-link" heading-name="1.3.2 Basic File System Layer"><span class="tree-item-title">1.3.2 Basic File System Layer</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.3.3_File_Organization_Module"><div class="tree-item-contents heading-link" heading-name="1.3.3 File Organization Module"><span class="tree-item-title">1.3.3 File Organization Module</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.3.4_Logical_File_System_Layer"><div class="tree-item-contents heading-link" heading-name="1.3.4 Logical File System Layer"><span class="tree-item-title">1.3.4 Logical File System Layer</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.4_Disk_Organization"><div class="tree-item-contents heading-link" heading-name="1.4 Disk Organization"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.4 Disk Organization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.4.1_Space_Layout"><div class="tree-item-contents heading-link" heading-name="1.4.1 Space Layout"><span class="tree-item-title">1.4.1 Space Layout</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.4.2_Disk_Partitioning"><div class="tree-item-contents heading-link" heading-name="1.4.2 Disk Partitioning"><span class="tree-item-title">1.4.2 Disk Partitioning</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.4.3_Review:_MBR_&amp;_GPT"><div class="tree-item-contents heading-link" heading-name="1.4.3 Review: MBR &amp; GPT"><span class="tree-item-title">1.4.3 Review: MBR &amp; GPT</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#1.5_Virtual_File_System"><div class="tree-item-contents heading-link" heading-name="1.5 Virtual File System"><span class="tree-item-title">1.5 Virtual File System</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第二课_File_System_Operations"><div class="tree-item-contents heading-link" heading-name="第二课 File System Operations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 File System Operations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.1_Basic_File_Operations"><div class="tree-item-contents heading-link" heading-name="2.1 Basic File Operations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.1 Basic File Operations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.1.1_Opening_and_Closing_Files"><div class="tree-item-contents heading-link" heading-name="2.1.1 Opening and Closing Files"><span class="tree-item-title">2.1.1 Opening and Closing Files</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.1.2_Seek_the_Route"><div class="tree-item-contents heading-link" heading-name="2.1.2 Seek the Route"><span class="tree-item-title">2.1.2 Seek the Route</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.1.3_Delete"><div class="tree-item-contents heading-link" heading-name="2.1.3 Delete"><span class="tree-item-title">2.1.3 Delete</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.2_File_Control_Block"><div class="tree-item-contents heading-link" heading-name="2.2 File Control Block"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2 File Control Block</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.2.1_FCB"><div class="tree-item-contents heading-link" heading-name="2.2.1 FCB"><span class="tree-item-title">2.2.1 FCB</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.2.2_Inode"><div class="tree-item-contents heading-link" heading-name="2.2.2 Inode"><span class="tree-item-title">2.2.2 Inode</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3_Caching_in_File_System"><div class="tree-item-contents heading-link" heading-name="2.3 Caching in File System"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3 Caching in File System</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.1_Open-File_Table"><div class="tree-item-contents heading-link" heading-name="2.3.1 Open-File Table"><span class="tree-item-title">2.3.1 Open-File Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.2_Where_FCBs_Went?"><div class="tree-item-contents heading-link" heading-name="2.3.2 Where FCBs Went?"><span class="tree-item-title">2.3.2 Where FCBs Went?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.3_Open_a_File"><div class="tree-item-contents heading-link" heading-name="2.3.3 Open a File"><span class="tree-item-title">2.3.3 Open a File</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.4_Relationship_Between_FDs_and_OFDs"><div class="tree-item-contents heading-link" heading-name="2.3.4 Relationship Between FDs and OFDs"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3.4 Relationship Between FDs and OFDs</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.4.1_Different_Behaviors_of_Different_FDs"><div class="tree-item-contents heading-link" heading-name="2.3.4.1 Different Behaviors of Different FDs"><span class="tree-item-title">2.3.4.1 Different Behaviors of Different FDs</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.4.2_Duplicating_FDs_(`dup(fd)`_and_`dup2(origfd,_newfd)`)"><div class="tree-item-contents heading-link" heading-name="2.3.4.2 Duplicating FDs (`dup(fd)` and `dup2(origfd, newfd)`)"><span class="tree-item-title">2.3.4.2 Duplicating FDs (<code>dup(fd)</code> and <code>dup2(origfd, newfd)</code>)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#2.3.4.3_Retrieving_and_Modifing_FDs_using_`fcntl()`"><div class="tree-item-contents heading-link" heading-name="2.3.4.3 Retrieving and Modifing FDs using `fcntl()`"><span class="tree-item-title">2.3.4.3 Retrieving and Modifing FDs using <code>fcntl()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第三课_Directory"><div class="tree-item-contents heading-link" heading-name="第三课 Directory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Directory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.1_File_Directory"><div class="tree-item-contents heading-link" heading-name="3.1 File Directory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 File Directory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.1.1_Directory_Operations"><div class="tree-item-contents heading-link" heading-name="3.1.1 Directory Operations"><span class="tree-item-title">3.1.1 Directory Operations</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.1.2_Directory_and_FCB"><div class="tree-item-contents heading-link" heading-name="3.1.2 Directory and FCB"><span class="tree-item-title">3.1.2 Directory and FCB</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2_Directory_Structure"><div class="tree-item-contents heading-link" heading-name="3.2 Directory Structure"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2 Directory Structure</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2.1_Single-Level_Directories"><div class="tree-item-contents heading-link" heading-name="3.2.1 Single-Level Directories"><span class="tree-item-title">3.2.1 Single-Level Directories</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2.2_Two-Level_Directories"><div class="tree-item-contents heading-link" heading-name="3.2.2 Two-Level Directories"><span class="tree-item-title">3.2.2 Two-Level Directories</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2.3_Tree-Structured_Directories"><div class="tree-item-contents heading-link" heading-name="3.2.3 Tree-Structured Directories"><span class="tree-item-title">3.2.3 Tree-Structured Directories</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2.4_Acyclic-Graph_Directories"><div class="tree-item-contents heading-link" heading-name="3.2.4 Acyclic-Graph Directories"><span class="tree-item-title">3.2.4 Acyclic-Graph Directories</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.2.5_&nbsp;General_Graph_Directory"><div class="tree-item-contents heading-link" heading-name="3.2.5 &nbsp;General Graph Directory"><span class="tree-item-title">3.2.5 &nbsp;General Graph Directory</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.3_Directory_Implementation"><div class="tree-item-contents heading-link" heading-name="3.3 Directory Implementation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.3 Directory Implementation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.3.1_AVL_Tree"><div class="tree-item-contents heading-link" heading-name="3.3.1 AVL Tree"><span class="tree-item-title">3.3.1 AVL Tree</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.3.2_B_Tree"><div class="tree-item-contents heading-link" heading-name="3.3.2 B Tree"><span class="tree-item-title">3.3.2 B Tree</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.4_Links"><div class="tree-item-contents heading-link" heading-name="3.4 Links"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.4 Links</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.4.1_Hard_Links"><div class="tree-item-contents heading-link" heading-name="3.4.1 Hard Links"><span class="tree-item-title">3.4.1 Hard Links</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#3.4.2_Soft_Links"><div class="tree-item-contents heading-link" heading-name="3.4.2 Soft Links"><span class="tree-item-title">3.4.2 Soft Links</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第四课_File_Allocation_Methods"><div class="tree-item-contents heading-link" heading-name="第四课 File Allocation Methods"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第四课 File Allocation Methods</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.1_Logical_Structure_of_a_File"><div class="tree-item-contents heading-link" heading-name="4.1 Logical Structure of a File"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1 Logical Structure of a File</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.1.1_Sequential_and_Direct_Access"><div class="tree-item-contents heading-link" heading-name="4.1.1 Sequential and Direct Access"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1.1 Sequential and Direct Access</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.1.1.1_Sequential_Access"><div class="tree-item-contents heading-link" heading-name="4.1.1.1 Sequential Access"><span class="tree-item-title">4.1.1.1 Sequential Access</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.1.1.2_Direct_Access"><div class="tree-item-contents heading-link" heading-name="4.1.1.2 Direct Access"><span class="tree-item-title">4.1.1.2 Direct Access</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.1.2_Access_Way_of_Different_Logical_File"><div class="tree-item-contents heading-link" heading-name="4.1.2 Access Way of Different Logical File"><span class="tree-item-title">4.1.2 Access Way of Different Logical File</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2_Physical_Allocation_of_a_File"><div class="tree-item-contents heading-link" heading-name="4.2 Physical Allocation of a File"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2 Physical Allocation of a File</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.1_Contiguous_Allocation"><div class="tree-item-contents heading-link" heading-name="4.2.1 Contiguous Allocation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2.1 Contiguous Allocation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.1.1_Contiguous_Allocation_and_Compaction"><div class="tree-item-contents heading-link" heading-name="4.2.1.1 Contiguous Allocation and Compaction"><span class="tree-item-title">4.2.1.1 Contiguous Allocation and Compaction</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.2_Linked_Allocation"><div class="tree-item-contents heading-link" heading-name="4.2.2 Linked Allocation"><span class="tree-item-title">4.2.2 Linked Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.3_Indexed_Allocation"><div class="tree-item-contents heading-link" heading-name="4.2.3 Indexed Allocation"><span class="tree-item-title">4.2.3 Indexed Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.4_The_Unix_Inode"><div class="tree-item-contents heading-link" heading-name="4.2.4 The Unix Inode"><span class="tree-item-title">4.2.4 The Unix Inode</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#4.2.5_Pre-Allocation"><div class="tree-item-contents heading-link" heading-name="4.2.5 Pre-Allocation"><span class="tree-item-title">4.2.5 Pre-Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第五课_Disk_Free_Space_Management"><div class="tree-item-contents heading-link" heading-name="第五课 Disk Free Space Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第五课 Disk Free Space Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.1_Free_Space_Management"><div class="tree-item-contents heading-link" heading-name="5.1 Free Space Management"><span class="tree-item-title">5.1 Free Space Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.2_Bitmap/Bit_Vector"><div class="tree-item-contents heading-link" heading-name="5.2 Bitmap/Bit Vector"><span class="tree-item-title">5.2 Bitmap/Bit Vector</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.3_Linked_List"><div class="tree-item-contents heading-link" heading-name="5.3 Linked List"><span class="tree-item-title">5.3 Linked List</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.4_Grouping"><div class="tree-item-contents heading-link" heading-name="5.4 Grouping"><span class="tree-item-title">5.4 Grouping</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.5_Counting"><div class="tree-item-contents heading-link" heading-name="5.5 Counting"><span class="tree-item-title">5.5 Counting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.6_Space_Maps"><div class="tree-item-contents heading-link" heading-name="5.6 Space Maps"><span class="tree-item-title">5.6 Space Maps</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#5.7_TRIMing_Unused_Blocks"><div class="tree-item-contents heading-link" heading-name="5.7 TRIMing Unused Blocks"><span class="tree-item-title">5.7 TRIMing Unused Blocks</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第六课_Different_File_Systems"><div class="tree-item-contents heading-link" heading-name="第六课 Different File Systems"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第六课 Different File Systems</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1_FAT"><div class="tree-item-contents heading-link" heading-name="6.1 FAT"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.1 FAT</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.1_FAT_Volume_Structure_Layout"><div class="tree-item-contents heading-link" heading-name="6.1.1 FAT Volume Structure Layout"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.1.1 FAT Volume Structure Layout</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.1.1_Boot_Sector"><div class="tree-item-contents heading-link" heading-name="6.1.1.1 Boot Sector"><span class="tree-item-title">6.1.1.1 Boot Sector</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.1.2_FAT"><div class="tree-item-contents heading-link" heading-name="6.1.1.2 FAT"><span class="tree-item-title">6.1.1.2 FAT</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.1.3_Root_Directory"><div class="tree-item-contents heading-link" heading-name="6.1.1.3 Root Directory"><span class="tree-item-title">6.1.1.3 Root Directory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.1.4_File_and_Directiory_Area"><div class="tree-item-contents heading-link" heading-name="6.1.1.4 File and Directiory Area"><span class="tree-item-title">6.1.1.4 File and Directiory Area</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.2_File_Maxium_Capacity_in_FAT"><div class="tree-item-contents heading-link" heading-name="6.1.2 File Maxium Capacity in FAT"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.1.2 File Maxium Capacity in FAT</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.2.1_FAT16"><div class="tree-item-contents heading-link" heading-name="6.1.2.1 FAT16"><span class="tree-item-title">6.1.2.1 FAT16</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.2.2_FAT32"><div class="tree-item-contents heading-link" heading-name="6.1.2.2 FAT32"><span class="tree-item-title">6.1.2.2 FAT32</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.1.2.3_We've_Got_a_lot_of_FAT"><div class="tree-item-contents heading-link" heading-name="6.1.2.3 We've Got a lot of FAT"><span class="tree-item-title">6.1.2.3 We've Got a lot of FAT</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2_The_Second_Extended_File_System_([ext2](https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h))"><div class="tree-item-contents heading-link" heading-name="6.2 The Second Extended File System ([ext2](https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h))"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2 The Second Extended File System (<a data-tooltip-position="top" aria-label="https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h" rel="noopener nofollow" class="external-link" href="https://github.com/torvalds/linux/blob/master/fs/ext2/ext2.h" target="_blank">ext2</a>)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.1_Blocks"><div class="tree-item-contents heading-link" heading-name="6.2.1 Blocks"><span class="tree-item-title">6.2.1 Blocks</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.2_Block_Groups"><div class="tree-item-contents heading-link" heading-name="6.2.2 Block Groups"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2.2 Block Groups</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.2.1_Group_Descriptor_Table"><div class="tree-item-contents heading-link" heading-name="6.2.2.1 Group Descriptor Table"><span class="tree-item-title">6.2.2.1 Group Descriptor Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.2.2_inode_Table_and_Data_Blocks"><div class="tree-item-contents heading-link" heading-name="6.2.2.2 inode Table and Data Blocks"><span class="tree-item-title">6.2.2.2 inode Table and Data Blocks</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.3_The_Superblock"><div class="tree-item-contents heading-link" heading-name="6.2.3 The Superblock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2.3 The Superblock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.3.1_Superblock_Data_Structure"><div class="tree-item-contents heading-link" heading-name="6.2.3.1 Superblock Data Structure"><span class="tree-item-title">6.2.3.1 Superblock Data Structure</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.4_Index_Nodes"><div class="tree-item-contents heading-link" heading-name="6.2.4 Index Nodes"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2.4 Index Nodes</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.4.1_inode_Data_Structure"><div class="tree-item-contents heading-link" heading-name="6.2.4.1 inode Data Structure"><span class="tree-item-title">6.2.4.1 inode Data Structure</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.4.2_Indexing_Inode"><div class="tree-item-contents heading-link" heading-name="6.2.4.2 Indexing Inode"><span class="tree-item-title">6.2.4.2 Indexing Inode</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.4.3_Calculating_Maximum_File_Storage"><div class="tree-item-contents heading-link" heading-name="6.2.4.3 Calculating Maximum File Storage"><span class="tree-item-title">6.2.4.3 Calculating Maximum File Storage</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.5_Dirctories"><div class="tree-item-contents heading-link" heading-name="6.2.5 Dirctories"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2.5 Dirctories</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.5.1_How_Do_You_Get_a_inode"><div class="tree-item-contents heading-link" heading-name="6.2.5.1 How Do You Get a inode"><span class="tree-item-title">6.2.5.1 How Do You Get a inode</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#6.2.6_Consistency_Check_(e2fsck)"><div class="tree-item-contents heading-link" heading-name="6.2.6 Consistency Check (e2fsck)"><span class="tree-item-title">6.2.6 Consistency Check (e2fsck)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第七课_Concurrency_in_File_Systems"><div class="tree-item-contents heading-link" heading-name="第七课 Concurrency in File Systems"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第七课 Concurrency in File Systems</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1_File_Locking"><div class="tree-item-contents heading-link" heading-name="7.1 File Locking"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1 File Locking</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.1_This_is_All_Mine"><div class="tree-item-contents heading-link" heading-name="7.1.1 This is All Mine"><span class="tree-item-title">7.1.1 This is All Mine</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.2_Me_Get_My_Share"><div class="tree-item-contents heading-link" heading-name="7.1.2 Me Get My Share"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1.2 Me Get My Share</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.2.1_Struct_flock"><div class="tree-item-contents heading-link" heading-name="7.1.2.1 Struct flock"><span class="tree-item-title">7.1.2.1 Struct flock</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.2.2_Да,_Comrade!"><div class="tree-item-contents heading-link" heading-name="7.1.2.2 Да, Comrade!"><span class="tree-item-title">7.1.2.2 Да, Comrade!</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.2.3_Lock_Unlock_Example"><div class="tree-item-contents heading-link" heading-name="7.1.2.3 Lock Unlock Example"><span class="tree-item-title">7.1.2.3 Lock Unlock Example</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.3.4_Be_Aware"><div class="tree-item-contents heading-link" heading-name="7.1.3.4 Be Aware"><span class="tree-item-title">7.1.3.4 Be Aware</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.3_lockf_IS_NOT_flock"><div class="tree-item-contents heading-link" heading-name="7.1.3 lockf IS NOT flock"><span class="tree-item-title">7.1.3 lockf IS NOT flock</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.4_Advisor_Locks_and_Mandatory_Locks"><div class="tree-item-contents heading-link" heading-name="7.1.4 Advisor Locks and Mandatory Locks"><span class="tree-item-title">7.1.4 Advisor Locks and Mandatory Locks</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.1.5_Using_File_as_a_Lock"><div class="tree-item-contents heading-link" heading-name="7.1.5 Using File as a Lock"><span class="tree-item-title">7.1.5 Using File as a Lock</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.2_Concurrency_in_VCS"><div class="tree-item-contents heading-link" heading-name="7.2 Concurrency in VCS"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.2 Concurrency in VCS</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.2.1_Lock-Modify-Unlock"><div class="tree-item-contents heading-link" heading-name="7.2.1 Lock-Modify-Unlock"><span class="tree-item-title">7.2.1 Lock-Modify-Unlock</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.2.2_Copy-Modify-Merge"><div class="tree-item-contents heading-link" heading-name="7.2.2 Copy-Modify-Merge"><span class="tree-item-title">7.2.2 Copy-Modify-Merge</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.3_Linux-Only_inotify"><div class="tree-item-contents heading-link" heading-name="7.3 Linux-Only inotify"><span class="tree-item-title">7.3 Linux-Only inotify</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.3.1_inotify_System_Calls"><div class="tree-item-contents heading-link" heading-name="7.3.1 inotify System Calls"><span class="tree-item-title">7.3.1 inotify System Calls</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.3.2_Event_Struct"><div class="tree-item-contents heading-link" heading-name="7.3.2 Event Struct"><span class="tree-item-title">7.3.2 Event Struct</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#7.3.2_An_Example"><div class="tree-item-contents heading-link" heading-name="7.3.2 An Example"><span class="tree-item-title">7.3.2 An Example</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第八课_Consistency_Checking_and_Journalling"><div class="tree-item-contents heading-link" heading-name="第八课 Consistency Checking and Journalling"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第八课 Consistency Checking and Journalling</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.1_Data_Consistency"><div class="tree-item-contents heading-link" heading-name="8.1 Data Consistency"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.1 Data Consistency</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.1.1_Inconsistent_State"><div class="tree-item-contents heading-link" heading-name="8.1.1 Inconsistent State"><span class="tree-item-title">8.1.1 Inconsistent State</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.1.2_Transaction"><div class="tree-item-contents heading-link" heading-name="8.1.2 Transaction"><span class="tree-item-title">8.1.2 Transaction</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.1.3_Transaction_in_ZFS_(Single-Atomic-Update)"><div class="tree-item-contents heading-link" heading-name="8.1.3 Transaction in ZFS (Single-Atomic-Update)"><span class="tree-item-title">8.1.3 Transaction in ZFS (Single-Atomic-Update)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.2_APFS(Apple_File_System)"><div class="tree-item-contents heading-link" heading-name="8.2 APFS(Apple File System)"><span class="tree-item-title">8.2 APFS(Apple File System)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3_NTFS(Windows_FS)"><div class="tree-item-contents heading-link" heading-name="8.3 NTFS(Windows FS)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.3 NTFS(Windows FS)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3.1_NTFS_Volume_Layout"><div class="tree-item-contents heading-link" heading-name="8.3.1 NTFS Volume Layout"><span class="tree-item-title">8.3.1 NTFS Volume Layout</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3.2_Transaction_in_NTFS"><div class="tree-item-contents heading-link" heading-name="8.3.2 Transaction in NTFS"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.3.2 Transaction in NTFS</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3.2.1_Roll-Forward"><div class="tree-item-contents heading-link" heading-name="8.3.2.1 Roll-Forward"><span class="tree-item-title">8.3.2.1 Roll-Forward</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3.2.2_Roll-Back"><div class="tree-item-contents heading-link" heading-name="8.3.2.2 Roll-Back"><span class="tree-item-title">8.3.2.2 Roll-Back</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#8.3.4_NTFS_Journalling"><div class="tree-item-contents heading-link" heading-name="8.3.4 NTFS Journalling"><span class="tree-item-title">8.3.4 NTFS Journalling</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第九课_Reliability:_RAID"><div class="tree-item-contents heading-link" heading-name="第九课 Reliability: RAID"><span class="tree-item-title">第九课 Reliability: RAID</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="congzhi's-os-series\15.-file-systems.html#第十课_Reliability:_Fail-Soft_Operations"><div class="tree-item-contents heading-link" heading-name="第十课 Reliability: Fail-Soft Operations"><span class="tree-item-title">第十课 Reliability: Fail-Soft Operations</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>