<!DOCTYPE html> <html><head>
		<title>1. Introduction to Operating Systems</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 1. Introduction to Operating Systems">
		<meta property="og:title" content="1. Introduction to Operating Systems">
		<meta property="og:description" content="Congzhi's Notes Vault - 1. Introduction to Operating Systems">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/1.-introduction-to-operating-systems.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/computer_hardware.png">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D457.TEX-I::before{padding:.661em .412em .204em 0;content:"j"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-mtext{display:inline-block;text-align:left}mjx-c.mjx-c44::before{padding:.683em .764em 0 0;content:"D"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c69::before{padding:.669em .278em 0 0;content:"i"}mjx-c.mjx-c6E::before{padding:.442em .556em 0 0;content:"n"}mjx-c.mjx-c20::before{padding:0 .25em 0 0;content:" "}mjx-c.mjx-c54::before{padding:.677em .722em 0 0;content:"T"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c2D::before{padding:.252em .333em 0 0;content:"-"}mjx-c.mjx-c43::before{padding:.705em .722em .021em 0;content:"C"}mjx-c.mjx-c75::before{padding:.442em .556em .011em 0;content:"u"}mjx-c.mjx-c72::before{padding:.442em .392em 0 0;content:"r"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c53::before{padding:.705em .556em .022em 0;content:"S"}mjx-c.mjx-c63::before{padding:.448em .444em .011em 0;content:"c"}mjx-c.mjx-c6B::before{padding:.694em .528em 0 0;content:"k"}mjx-c.mjx-c52::before{padding:.683em .736em .022em 0;content:"R"}mjx-c.mjx-c67::before{padding:.453em .5em .206em 0;content:"g"}mjx-c.mjx-c45::before{padding:.68em .681em 0 0;content:"E"}mjx-c.mjx-c78::before{padding:.431em .528em 0 0;content:"x"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c37::before{padding:.676em .5em .022em 0;content:"7"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c220F.TEX-S2::before{padding:.95em 1.278em .45em 0;content:"∏"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c2264::before{padding:.636em .778em .138em 0;content:"≤"}mjx-munderover{display:inline-block;text-align:left}mjx-munderover:not([limits=false]){padding-top:.1em}mjx-munderover:not([limits=false])>*{display:block}mjx-msubsup{display:inline-block;text-align:left}mjx-script{display:inline-block;padding-right:.05em;padding-left:.033em}mjx-script>mjx-spacer{display:block}mjx-c.mjx-c1D70F.TEX-I::before{padding:.431em .517em .013em 0;content:"τ"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c1D448.TEX-I::before{padding:.683em .767em .022em 0;content:"U"}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c3C::before{padding:.54em .778em .04em 0;content:"<"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msub{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D44A.TEX-I::before{padding:.683em 1.048em .022em 0;content:"W"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c1D444.TEX-I::before{padding:.704em .791em .194em 0;content:"Q"}mjx-c.mjx-c3E::before{padding:.54em .778em .04em 0;content:">"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="1. Introduction to Operating Systems"><ol>
<li dir="auto">Introduction to Operating Systems</li>
</ol></h1><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="success" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-check"><path d="M20 6 9 17l-5-5"></path></svg></div><div class="callout-title-inner">第一遍重写完成</div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第一课  Operating Systems: Fundamentals and Functions" dir="auto" class="heading" id="第一课__Operating_Systems:_Fundamentals_and_Functions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课  Operating Systems: Fundamentals and Functions</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">操作系统是计算机系统不可或缺的一部分，它是连接用户和硬件的桥梁，负责协调资源并优化计算机的使用体验。无论是个人电脑、手机还是现代的车机系统，操作系统都扮演着核心的角色。每当我们使用这些设备时，操作系统正在背后默默地完成资源调度和任务管理工作。</p></div><div class="el-p"><p dir="auto">那什么是操作系统？好像一时间很难回答出来，好像它们天然的存在在我们的手机/电脑上。如果你感到困惑，不用担心，因为这个问题就是我们本阶段要回答的问题。因为操作系统是计算机系统的一部分，所以，咱们先来看看什么是计算机系统。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Computing System" dir="auto" class="heading" id="1.1_Computing_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Computing System</h3><div class="heading-children"><div class="el-p"><p dir="auto">计算机系统是一个宏观的概念，由<strong>计算机硬件</strong>和<strong>计算机软件</strong>共同构成。硬件为计算机系统提供了基础设施 (infrastructure) ；软件赋予计算机系统功能，使其能够完成各种任务并满足用户需求。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 Computer Hardware" dir="auto" class="heading" id="1.1.1_Computer_Hardware"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 Computer Hardware</h4><div class="heading-children"><div class="el-p"><p dir="auto">当你的电脑或手机处于关机状态时，所能看到的就是计算机硬件啦。现代计算机主要遵循 John von Neumann 架构（指令和数据共享同一内存）或其变种 Harvard 架构（指令和数据分开存储）。这些架构定义了计算机由一组特定组件通过特定方式连接而成。这些内容在计算机组成原理中对此有详细介绍，我们这里简单地回顾一下。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Components of a Computer" dir="auto" class="heading" id="Components_of_a_Computer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Components of a Computer</h5><div class="heading-children"><div class="el-p"><p dir="auto">在计算机组成原理中，我们学到，von Neumann 计算机由五大核心部件构成。分别是：<strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器/内存</strong>、<strong>输入部件</strong>和<strong>输出部件</strong>构成。即要想组成一台计算机，我们就需要有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Central Processing Unit</strong>: 包括算术逻辑单元 (ALU)、控制单元 (Control Unit) 和一组寄存器。其中的控制单元负责协调 ALU 与其他部件。</li>
<li data-line="1" dir="auto"><strong>Memory</strong>: 由众多存储单元组成，用于保存指令和数据。</li>
<li data-line="2" dir="auto"><strong>Input/Output Devices</strong>: 输入输出设备，我们统称为外设，用于将数据和指令传递给 CPU 去运算或是接收 CPU 运算后的结果。鼠标、键盘、屏幕都是常见的外设。</li>
<li data-line="3" dir="auto"><strong>Bus</strong>: 总线用于连接上述组件并实现它们之间的通信。分为数据总线、地址总线和控制总线。</li>
</ol></div><div class="el-p"><p dir="auto">如下，我们展示了计算机硬件。我们把没有安装任何软件的计算机称为裸机，想一想，假设这台计算机没有安装任何软件，我们该如何使用裸机完成一些任务？</p></div><div class="el-p"><p dir="auto"><span alt="computer_hardware.png" src="computer_hardware.png" class="internal-embed media-embed image-embed is-loaded"><img alt="computer_hardware.png" src="congzhi's-os-series/pics/computer_hardware.png"></span></p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 Computer Workflow" dir="auto" class="heading" id="1.1.2_Computer_Workflow"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 Computer Workflow</h4><div class="heading-children"><div class="el-p"><p dir="auto">在使用裸机前，我们先来看看计算机的工作流。von Neumann 架构将计算机分为五大部件，其中，CU 负责协调和控制其他四个部件完成各自的任务。所以计算机的工作流程实际上是由控制器指挥其他部件按顺序执行指令。</p></div><div class="el-p"><p dir="auto">由于 von Neumann 架构的计算机是一种基于<strong>存储程序 (stored-program)</strong> 的设计思想的架构，即指令和数据存储在同一个存储器中。指令的处理流程通常包括以下四个步骤：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>输入</strong>：从外部设备接收数据或指令。</li>
<li data-line="1" dir="auto"><strong>存储</strong>：将接收到的数据或指令保存到存储器中。（涉及 memory architecture 我们将在 <a data-href="12. Memory Management" href="congzhi's-os-series/12.-memory-management.html" class="internal-link" target="_self" rel="noopener nofollow">12. Memory Management</a> 来介绍）</li>
<li data-line="2" dir="auto"><strong>计算</strong>：CPU 从存储器中读取数据并由 ALU 对当前指令进行逻辑或算术运算。</li>
<li data-line="3" dir="auto"><strong>输出</strong>：将运算结果传递给外部设备反馈给用户。</li>
</ol></div><div class="el-p"><p dir="auto">CPU 需要处理数据，输入设备就负责将外部信息输入到计算机系统中。常见的输入设备包括键盘、鼠标、扫描仪等。此外，现代计算机还包括触摸屏、语音识别系统和摄像头等高级输入设备，用于更加多样化和直观的用户交互。</p></div><div class="el-p"><p dir="auto">当 CPU 要处理某些数据时，它会从 cache 或内存中读取并处理这些数据。如果 cache 和内存没有相关的数据或指令，系统还可能会在硬盘中寻找相关的数据。在并行化计算时代，除了 CPU，系统在一些如图形处理、机器学习等并行计算的应用场景中还会依赖 GPU (Graphics Processing Unit)。</p></div><div class="el-p"><p dir="auto">当数据处理完成之后，我们想得到处理后的结果。这时，系统就会让输出设备将计算机处理后的信息输出给用户。常见的输出设备包括显示器、打印机、扬声器等。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.3 CPU Fetch-Decode-Execute Cycle" dir="auto" class="heading" id="1.1.3_CPU_Fetch-Decode-Execute_Cycle"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 CPU Fetch-Decode-Execute Cycle</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们现在知道了计算机工作流程，我们再来深入一下，看看 CPU 如何执行机器语言指令。如果你要做菜，第一步你需要从冰箱里面先拿原材料，然后处理原材料，烹制菜肴，最后装盘上桌。CPU 执行指令和做菜一样，你要先从内存里面取指令和数据，经过解码，CPU 执行指令，最后写回结果。</p></div><div class="el-p"><p dir="auto">这整个过程称为<strong>指令执行周期</strong>，也简称为指令周期。一般由<strong>取指令</strong>、<strong>指令解码</strong>、<strong>执行</strong>、<strong>结果写回</strong>四部分组成（有的还包括访存周期）。在指令周期中，你可能经常见到以下几个寄存器：PC 寄存器 (Program Counter, AKA Instruction Pointer)、MAR 寄存器 (Memory Address Register)、MDR 寄存器 (Memory Data Register, AKA Memory Buffer Register)、IR 寄存器 (Instruction Register)。</p></div><div class="el-p"><p dir="auto">我们以一个 X+Y 的加法指令做例子，其指令执行周期如下：<br>
<span alt="Pasted image 20240405005008.png" src="Pasted image 20240405005008.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240405005008.png" src="congzhi's-os-series/pics/pasted-image-20240405005008.png"></span></p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Instruction Fetch Cycle" dir="auto" class="heading" id="Instruction_Fetch_Cycle"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Instruction Fetch Cycle</h5><div class="heading-children"><div class="el-p"><p dir="auto">CU 负责从内存中获取下一条要执行的指令。它通过 PC 得到当前指令的地址，从内存中读取指令。MDR 的大小就决定了CPU 一次性能够 fetch 多少指令。之后，指令会被加载到 IR 中去处理（解码+执行）。完成这一系列操作后，CU 就会更新当前 PC 中的值（进行 PC+1 的操作），以指向下一条要取 fetch 的指令地址。</p></div><div class="el-p"><p dir="auto">取指令阶段顺序：PC (In charge of CU) -&gt; MAR -&gt; (MEMORY) -&gt; MDR -&gt; IR -&gt; (Instruction executes)</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Instruction Decode Cycle" dir="auto" class="heading" id="Instruction_Decode_Cycle"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Instruction Decode Cycle</h5><div class="heading-children"><div class="el-p"><p dir="auto">在指令被加载到 IR 后，控制单元就会解码指令，根据其操作码来确定它是一条什么类型的指令（本例中说加法指令，即需要两个操作数）。后识别出操作数位于寄存器 A 和寄存器 B。解码阶段确定了需要执行的具体操作及涉及的数据。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Instruction Execute Cycle" dir="auto" class="heading" id="Instruction_Execute_Cycle"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Instruction Execute Cycle</h5><div class="heading-children"><div class="el-p"><p dir="auto">指令解码后，根据 CU 的控制信号，ALU 执行实际加法操作。它从寄存器读取值，执行加法操作并将结果暂存。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Write-back Cycle" dir="auto" class="heading" id="Write-back_Cycle"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Write-back Cycle</h5><div class="heading-children"><div class="el-p"><p dir="auto">在操作完成后，CU 一般会指示将 ALU 的计算结果写回寄存器。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="User's Perspective" dir="auto" class="heading" id="User's_Perspective"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>User's Perspective</h5><div class="heading-children"><div class="el-p"><p dir="auto">至此，我们已经大致了解了一条计算机指令是如何执行的了，尽管这个过程涵盖了取指、解码、执行和写回等多个步骤，但在我们的视角下，这一切几乎透明不可见。所有的逻辑都被封装在一片微小的芯片中了，呈现在我们眼前的，仅仅是排列整齐的针脚们。</p></div><div class="el-p"><p dir="auto">我们将这种把复杂机制封装于内部，只暴露简洁接口的设计思想称为——<strong>抽象 (abstruction)</strong>，这是计算机科学中最核心的理念之一。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.4 CPU Hardware Abstractions" dir="auto" class="heading" id="1.1.4_CPU_Hardware_Abstractions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.4 CPU Hardware Abstractions</h4><div class="heading-children"><div class="el-p"><p dir="auto">作为计算机硬件的核心，CPU 通过众多封装的管脚与外界进行交互。假如我们想使用裸机（没有操作系统的计算机）进行一个加法运算，所需要的步骤看似简单：我们只要把被加数放到一个寄存器中，把加数放在另一个寄存器中，然后执行 CPU 的加法指令，等待一瞬间，我们可以在加数寄存器上观察到输出结果了。</p></div><div class="el-p"><p dir="auto">我们说过，这一看似轻而易举的过程的背后实际上是万亿计逻辑电路的协作。既然不用关心 CPU 内部到底发生了什么，我们来正式操作一台裸机。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Abstractions of Instruction Set Architecture" dir="auto" class="heading" id="Abstractions_of_Instruction_Set_Architecture"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Abstractions of Instruction Set Architecture</h5><div class="heading-children"><div class="el-p"><p dir="auto">如果你想在裸机环境中编程，你就必须使用机器语言，而且每次都要设置寄存器的值。机器语言是基于硬件的最低级别编程语言，是 CPU 唯一能够直接理解并执行的语言。</p></div><div class="el-p"><p dir="auto">作为使用裸机的用户，我们并不关心门电路怎么实现加法指令，我们只需要使用 CPU 提供的加法指令就好了。但我们确实需要关心一件事情：我们希望机器码在厂商后续的升级型号中也能继续使用，不然每次得到新的 CPU 我们都需要编写新的机器代码。为此，芯片厂商就会通过<strong>指令集体系结构 (ISA)</strong> 对底层晶体管电路进行规约抽象。</p></div><div class="el-p"><p dir="auto">例如，8086 及后续的芯片型号使用的架构就是 x86 ，由于 ISA 总是向下兼容的，因而你可以在后续任何版本的 x86 架构芯片上运行相同的机器语言代码。也就是说，ISA 封装了底层的硬件，为裸机程序员提供了一个统一的抽象接口。我们又看到了，封装和抽象的思想。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Use of a Bare Machine" dir="auto" class="heading" id="Use_of_a_Bare_Machine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Use of a Bare Machine</h5><div class="heading-children"><div class="el-p"><p dir="auto">光说不做假把式，我们来使用一下那个年代的裸机。假想我们有一颗诞生于 1978 年的 8086 微处理器芯片，得益于芯片内部对底层逻辑电路的封装，要完成一个加法运算（1+2），我们只需要想办法让芯片的 IR 寄存器先后呈现这样的电平状态：</p></div><div class="el-pre"><pre class="language-machine" tabindex="0"><code data-line="0" class="language-machine is-loaded">10111000 00000001 00000000
10111011 00000010 00000000
00000001 11011000
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这些指令代表的含义如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">第一行指令是将一个立即数 1 放到 AX 寄存器中；</li>
<li data-line="1" dir="auto">第二行指令是将一个立即数 2 放到 BX 寄存器中；</li>
<li data-line="2" dir="auto">第三行指令是加法指令，即 AX = AX+BX。</li>
</ul></div><div class="el-p"><p dir="auto">我们前面提到过，因为 von Neumann 架构的计算机都是存储程序方式工作的计算机。所以我们需要将这三条指令连续的放到内存中，然后想办法一步步地加载这三条指令。因为 PC 寄存器会自动地进行指令 + 1，所以我们只需要想办法让 CPU 取到第一条指令。虽然 CPU 对逻辑的封装固然方便，但是这样子还是好麻烦。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.5 Computer Software" dir="auto" class="heading" id="1.1.5_Computer_Software"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.5 Computer Software</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了让机器自动地帮我们做事，软件应运而生。<strong>计算机软件是运行在计算机硬件上的一系列程序和数据的集合</strong>。软件告诉计算机硬件需要先这样，在那样......，从而实现自动化操作。</p></div><div class="el-p"><p dir="auto">我们前面说，硬件提供了计算机系统的基础设施，但硬件裸机的使用体验很差，没有人会死板到直接与硬件打交道。通过编写软件，让 CPU 自动地执行软件中的一条条指令，并在适当的时刻与外部设备交互，如接收用户输入、控制输出设备等。有了这层抽象，计算机好像没那么难用了。根据其作用，计算机软件又可分为系统软件和应用软件。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Software of Operating Systems" dir="auto" class="heading" id="Software_of_Operating_Systems"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Software of Operating Systems</h5><div class="heading-children"><div class="el-p"><p dir="auto">操作系统就是一层软件，帮助我们管理抽象计算机的硬件资源并提供友好可靠的 API 和交互界面。作为用户，我们只要使用系统为我们提供的接口就好了。所以，我们可以说<strong>操作系统是封装硬件的软件，作用是为应用软件提供服务</strong>。操作系统提供了对硬件资源的抽象和管理，使用户不再需要直接与计算机硬件对接，替代了人工与裸机硬件的交互。</p></div><div class="el-p"><p dir="auto">由于屏蔽了硬件资源和硬件的复杂性，操作系统必须为应用程序提供特殊的 API 接口，以申请和管理硬件资源。我们把这些 API 叫做系统调用，使应用程序可以通过操作系统提供的标准化接口访问硬件资源。简化了应用程序开发，还通过权限管理和硬件抽象层提高了系统的安全性和稳定性。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Application Programs" dir="auto" class="heading" id="Application_Programs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Application Programs</h5><div class="heading-children"><div class="el-p"><p dir="auto">除了操作系统，应用程序也是计算机软件一大重要的组成部分。即使经过了系统的封装，计算机依然不算好用，但人们对于软件开发的热忱一点不减。各式各样的计算机软件层出不穷，我们的生活中充斥着让人感到新奇和让人兴奋的应用软件。</p></div><div class="el-p"><p dir="auto">我们利用软件来请求计算机为我们解决一些问题或获得一些需求，不同的软件定义着不同的解决用户问题或获取需求的方式。根据软件功能，我们还能够进一步地划分（办公、娱乐......）。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.2 Roles of Operating Systems: User and System Perspectives" dir="auto" class="heading" id="1.2_Roles_of_Operating_Systems:_User_and_System_Perspectives"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 Roles of Operating Systems: User and System Perspectives</h3><div class="heading-children"><div class="el-p"><p dir="auto">在上一节中，我们从一个整体视角简单地描述了计算机系统的构成与操作系统的地位。那么，操作系统究竟是什么？它具体扮演着怎样的角色？为了更清晰地回答这些问题，我们将从用户视角和系统视角两个角度进行探讨。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.2.1 User Perspective: Ease of Use" dir="auto" class="heading" id="1.2.1_User_Perspective:_Ease_of_Use"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.1 User Perspective: Ease of Use</h4><div class="heading-children"><div class="el-p"><p dir="auto">前面，我们尝试模拟使用二进制机器语言直接和计算机硬件进行交互，即便只是完成加法运算，也可见这种方式的复杂性和低效性。用户希望计算机的使用变得更加简单、直观，而有了操作系统对硬件功能的封装，机器的易用性和使用体验得以大幅提升。</p></div><div class="el-p"><p dir="auto"><span alt="os_user_view.jpg" src="os_user_view.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="os_user_view.jpg" src="congzhi's-os-series/pics/os_user_view.jpg"></span></p></div><div class="el-p"><p dir="auto">从<a data-tooltip-position="top" aria-label="2. Evolution of Operating Systems" data-href="2. Evolution of Operating Systems" href="congzhi's-os-series/2.-evolution-of-operating-systems.html" class="internal-link" target="_self" rel="noopener nofollow">计算机的发展史</a>可以看出，人机交互（用户和操作系统的接口）的方式随着科技的进步而不断演化。从最早的打孔纸带，到 CLI 命令行交互界面，再到 GUI 图形化的交互界面，直至如今的触屏交互方式，人机交互变得越来越便捷。未来，语音交互甚至脑机接口会成为新兴的交互方式么？</p></div><div class="el-p"><p dir="auto">在个人电脑 PC 的时代，一个人独享一台电脑。而在 1970s，计算机仍是稀缺货，同时被多个用户使用。所以计算机还需要为每个用户提供一种自己独占整个计算机的错觉。</p></div><div class="el-p"><p dir="auto">除了易用性，计算机的性能也是使用体验中很重要的一个部分。而裸机的 CPU 和硬件资源又改变不了，所以，操作系统还应通过优化资源调度策略来最大化 CPU 和硬件资源的利用率。为了提升用户的使用体验，现代操作系统中的调度算法一般会优先保障用户交互相关的任务，如图形界面的平滑操作，而将其他后台任务的优先级适当降低。</p></div><div class="el-p"><p dir="auto">需要注意的是，并非所有计算机系统都以用户体验为核心。比如说嵌入式计算机系统（如车机系统）可能更注重实时性需求，甚至会以牺牲一定的用户体验为代价，确保关键任务的按时完成。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.2.2 System Perspective: A Control Program" dir="auto" class="heading" id="1.2.2_System_Perspective:_A_Control_Program"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.2 System Perspective: A Control Program</h4><div class="heading-children"><div class="el-p"><p dir="auto">从系统的角度看，操作系统就是一组专门设计用于与硬件交互的软件，负责管理所有硬件资源。从而，任何的应用程序都需要通过操作系统提供的系统调用 API 来请求并使用硬件资源。通过这种抽象，操作系统屏蔽了硬件的复杂性，简化了应用程序的开发，同时提高系统的稳定性和安全性。</p></div><div class="el-p"><p dir="auto">从这种角度看，操作系统实际上就是计算机系统的资源管理器 (resource allocator)，协调系统内的各种资源，例如占用的CPU时间、内存空间、存储空间和I/O设备的分配等。操作系统需要最大化硬件资源的利用率，还要通过权限管理与访问控制，确保资源的安全共享并防止资源冲突。</p></div><div class="el-p"><p dir="auto">这种资源调度能力使操作系统成为计算机系统运行的核心，不仅仅需要协调控制 I/O 设备，还需要对用户程序的执行进行控制和管理，以防止用户程序出现错误或者对计算机资源的越界访问（防止应用程序直接操作硬件导致系统崩溃或数据损坏）。当应用程序真正想要访问系统资源时，应用程序就需要通过系统调用 API 想操作系统提出相关的请求，让操作系统代为完成。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.2.3 What is an Operating System" dir="auto" class="heading" id="1.2.3_What_is_an_Operating_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2.3 What is an Operating System</h4><div class="heading-children"><div class="el-p"><p dir="auto">所以我们如何去定义什么是操作系统？如何准确地定义它的角色和功能？上面我们已经看到，在不同的视角中，操作系统的定义也是不同的。在用户眼里，操作系统就是让机器易于使用的软件（通过 CLI 和 GUI）；而从系统的层面来看，操作系统就是封装硬件，通过系统调用为上层应用提供服务的抽象层。</p></div><div class="el-p"><p dir="auto">在许多教科书中，你会看到这样的定义：“<strong>操作系统是管理软硬件资源，为应用提供服务的系统软件</strong>”。这实际上也是从系统的层面上来定义的。而操作系统的核心目标是构建一个“用户友好”的计算机系统，使计算机能够高效地解决用户的问题和需求。</p></div><div class="el-p"><p dir="auto">虽然纯计算机硬件也能直接执行计算任务，但我们也看到硬件远远无法满足用户对易用性和便捷性的要求。因此，我们想要通过软件自动地来帮助实现这些目标。而你可以发现许多软件程序都有一些共性的操作，例如对内存的操作、I/O 的操作等。为了统一管理和实现这些功能，我们将它们集成到一个软件中，即内核 (Kernel) 。内核的出现把计算机软件划分成了系统软件和应用软件。</p></div><div class="el-p"><p dir="auto">有了操作系统提供的对下层硬件的抽象，不仅能够满足用户对易用性和便捷性的需求，而且通过在计算机系统中加入一层 indirection ，应用程序想要使用硬件资源必须经过过操作系统内核的管理。提高了整个系统的安全性。</p></div><div class="el-p"><p dir="auto">通过上面的学习，我们应该能够明白操作系统的职责之所在。OS最基本的职责就是为我们提供一些抽象，让系统方便使用（user perspective）。除此之外，操作系统还应该管理资源，让系统的性能得到最大的利用（system perspective）。 </p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 Bridging High-Level Language and Machine Code" dir="auto" class="heading" id="第二课_Bridging_High-Level_Language_and_Machine_Code"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 Bridging High-Level Language and Machine Code</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">当我们想要创建自己的软件时，我们就需要将想法告诉计算机。而计算机无法理解人类的语言，计算机能够理解的只有特定架构下的二进制 01 指令。所以我们就需要通过一些方式将我们的想法变成计算机能够理解的机器语言。这节课，我们来学习这一切如何实现。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 From Machine Code to Assembly" dir="auto" class="heading" id="2.1_From_Machine_Code_to_Assembly"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 From Machine Code to Assembly</h3><div class="heading-children"><div class="el-p"><p dir="auto">在之前的学习中，我们了解到，与硬件交互需要使用机器语言。机器语言以二进制（01）表示，是计算机中直接与高低电平对应的语言。虽然它可以直接控制 CPU 和硬件资源，但有些太过于反人类，每次使用都要查阅相关的手册，而且还十分容易出错。</p></div><div class="el-p"><p dir="auto">尽管能用二进制代码直接操纵包含数以亿计的晶体管已经可以称之为奇迹了（虽然 8086 只有大约 29000 个晶体管），但我们可能见到这种毫无章法的 01 二进制就烦。为了解决这一问题，人们发明了更易读、容易记忆的汇编语言。汇编使用助记符来表示不同的操作、寄存器等。比如说，你可以用 <code>ADD</code> 来指代加法操作。</p></div><div class="el-p"><p dir="auto">汇编如何和机器语言对应上的呢？咱们回到之前的加法运算程序中：</p></div><div class="el-pre"><pre class="language-machine" tabindex="0"><code data-line="0" class="language-machine is-loaded">10111000 00000001 00000000
10111011 00000010 00000000
00000001 11011000
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">机器语言的指令是具有一定的结构的，一般由操作码 (Opcode) 和操作数 (Operands) 构成。指示 CPU 应该执行的操作类型，例如“数据移动”或是“加法”等。操作数用于指定指令操作需要的数据或存储位置，如寄存器或内存地址。</p></div><div class="el-p"><p dir="auto">第一条指令是将一个立即数”移动到“特定的寄存器中，我们把称为 <code>AX</code> ，这是一个通用寄存器。其中，前五位表示移动指令，后三位用于指定移动到哪个寄存器。之后的 <code>00000001 00000000</code> 是用小端方式表示立即数 <code>1</code> 。也就是说，这一条指令的作用是把立即数 <code>1</code> 移动到 <code>AX</code> 寄存器中。</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">操作码</th>
<th align="center" dir="ltr">十六进制</th>
<th align="center" dir="ltr">目标寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="auto"><code>10111 000</code></td>
<td align="center" dir="ltr"><code>B8</code></td>
<td align="center" dir="ltr">AX</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 001</code></td>
<td align="center" dir="ltr"><code>B9</code></td>
<td align="center" dir="ltr">CX</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 010</code></td>
<td align="center" dir="ltr"><code>BA</code></td>
<td align="center" dir="ltr">DX</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 011</code></td>
<td align="center" dir="ltr"><code>BB</code></td>
<td align="center" dir="ltr">BX</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 100</code></td>
<td align="center" dir="ltr"><code>BC</code></td>
<td align="center" dir="ltr">SP</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 101</code></td>
<td align="center" dir="ltr"><code>BD</code></td>
<td align="center" dir="ltr">BP</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 110</code></td>
<td align="center" dir="ltr"><code>BE</code></td>
<td align="center" dir="ltr">SI</td>
</tr>
<tr>
<td align="center" dir="auto"><code>10111 111</code></td>
<td align="center" dir="ltr"><code>BF</code></td>
<td align="center" dir="ltr">DI</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">第二条指令和第一条指令差不多。</p></div><div class="el-p"><p dir="auto">第三条指令是一个加法指令，其中操作码是 <code>00000001</code> ，表示一个加法操作。后面的一个字节表示将两个寄存器中的数进行相加。即 <code>11 011 000</code> 。<code>11</code> 表示的就是操作数是两个寄存器。</p></div><div class="el-p"><p dir="auto">我们将上面的机器语言符号化，用 <code>MOV AX</code> 表示原来的 <code>10111 000</code>，用 <code>ADD</code> 来指代之前的加法指令操作码 <code>00000001</code>。不同的寄存器（<code>000</code> - <code>111</code>）也用字母，如 <code>AX</code> <code>BX</code>等来表示。这样，一一对应的，我们就得到了下面的汇编语言指令：</p></div><div class="el-pre"><pre class="language-asm" tabindex="0"><code data-line="0" class="language-asm is-loaded">MOV AX, 1      ; AX = 1
MOV BX, 2      ; BX = 2
ADD AX, BX     ; AX = AX + BX → AX = 3
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这样，是不是容易理解多了？</p></div><div class="el-p"><p dir="auto">从机器语言到汇编的转变是计算机语言发展中的重大节点。通过符号化的助记符，程序员可以更好更直观地编写代码了。但仍然，汇编还是不够好。因为计算机的架构不同，使用的机器语言和汇编语言仍然是不同的（汇编一一对应机器码）。这是由 ISA 所决定的（如 x86, ARM, RISC-V, MIPS等）。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.2 From Assembly to High Level Languages" dir="auto" class="heading" id="2.2_From_Assembly_to_High_Level_Languages"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 From Assembly to High Level Languages</h3><div class="heading-children"><div class="el-p"><p dir="auto">高级语言是汇编的封装和抽象。高级语言增加了代码在不同架构平台上的可移植性，屏蔽了底层细节，使得同一段代码可以在不同架构的机器下运行。这是通过高级语言编译器实现的，编译器会将高级语言程序编译成特定平台的汇编语言，再由汇编器将汇编代码转换成机器码供计算机读取。</p></div><div class="el-p"><p dir="auto">最初的 Unix 系统就是用汇编语言编写的，然而汇编语言是 machine-specific 的，不支持不同平台的移植。虽然第一个高级语言 FORTRAN 的出现代表着编程语言有了更高层次的抽象，但最开始仍未解决可移植性问题。即你可能需要在不同的平台上写不同的程序。</p></div><div class="el-p"><p dir="auto">C 语言的出现改变了这一局面。C 语言设计的初衷之一就是为了实现代码的可移植性。它通过提供一个接近底层硬件的抽象层，使得程序员可以编写在不同硬件平台上运行的代码，而不需要对每个平台进行大量的修改。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.3 Interpreted Language: Higher Level Abstractions" dir="auto" class="heading" id="2.3_Interpreted_Language:_Higher_Level_Abstractions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 Interpreted Language: Higher Level Abstractions</h3><div class="heading-children"></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.4 Human Language Complier, Any Chance?" dir="auto" class="heading" id="2.4_Human_Language_Complier,_Any_Chance?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4 Human Language Complier, Any Chance?</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Resource Management" dir="auto" class="heading" id="第三课_Resource_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Resource Management</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在前两节课中，我们初步介绍了抽象的概念——抽象是计算机科学发展的基石。CPU 通过暴露管脚，将晶体管的硬件封装为一个抽象的计算单元；操作系统则进一步对这些封装的硬件（如 CPU、内存、I/O 等）进行抽象，为应用程序提供接口。这种设计让开发者能够忽略硬件的复杂性，而将精力放在实现业务逻辑和用户交互上。</p></div><div class="el-p"><p dir="auto">随后，我们学习了汇编语言和高级语言。汇编语言对机器语言进行抽象，为开发者提供了更友好的编程接口。而高级语言则进一步抽象底层细节，大幅提升了代码在不同平台上的可移植性，让开发者能够更轻松地与硬件交互。</p></div><div class="el-p"><p dir="auto">通过抽象，复杂的底层细节得以简化，使得计算机系统能够更高效地工作，同时也让开发者能够专注于解决实际问题。在理解了抽象的概念后，本课将探讨操作系统需要管理的资源及其管理方式。简单来说，操作系统必须管理以下几大核心资源：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>处理器 (CPU)</strong></li>
<li data-line="1" dir="auto"><strong>内存空间 (Memory)</strong></li>
<li data-line="2" dir="auto"><strong>文件存储 (File Storage)</strong></li>
<li data-line="3" dir="auto"><strong>I/O 外设 (I/O Devices)</strong></li>
</ul></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 Process Management" dir="auto" class="heading" id="3.1_Process_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 Process Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">如果一段程序不能被 CPU 所执行，那即使这段程序功能在强大，它依旧没有任何意义。在操作系统中，<strong>进程</strong>指的是正在执行的程序。比如，你现在正在浏览的网页、运行的微信应用，以及正在播放的 QQ 音乐，都属于独立的进程。它们的共同点是：这些程序实例都在一台计算机上运行（即由 CPU 执行）。</p></div><div class="el-p"><p dir="auto">我们把可以在机器上运行的程序称为<strong>可执行程序</strong>，这些程序通常经过操作系统的封装（Windows 下的 <code>.exe</code> 格式，Linux 下的 <code>.elf</code> 格式）。在磁盘上存储的可执行程序需要被载入内存后，才能转化为<strong>进程</strong>并开始执行。</p></div><div class="el-p"><p dir="auto">简单来说，进程可以被理解为程序在 CPU 上运行的一个实例。静态存储在磁盘上的程序是“被动的静态实体”，而进程则是“主动的动态实体”，因为它代表了程序正在运行的状态。所以同样的程序载入两次内存，创建的是两个不同的进程。</p></div><div class="el-p"><p dir="auto">为了完成任务，运行中的程序——即进程需要操作系统分配必要的资源，例如：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>CPU 资源</strong>：用于执行程序中的指令。</li>
<li data-line="1" dir="auto"><strong>内存资源</strong>：用于载入程序代码段和数据段，以支持程序正常运行。此外，运行中的程序也会动态的申请和释放内存。</li>
<li data-line="2" dir="auto"><strong>I/O 设备资源</strong>：例如把内容显示到屏幕上或接收用户输入数据。</li>
<li data-line="3" dir="auto"><strong>文件资源</strong>：用于读取配置文件或持久化保存处理的数据。</li>
</ul></div><div class="el-p"><p dir="auto">当我们启动一个程序时，操作系统会将程序载入内存并为其分配所需的资源。在程序的运行过程中，进程也可能会动态向操作系统申请额外资源，确保任务能够持续完成。而当进程终止时，操作系统会需要回收该进程占用的所有资源，并重新分配给其他任务。</p></div><div class="el-p"><p dir="auto">在操作系统中，为了管理和调度进程的运行，操作系统需要支持以下功能：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>进程的创建和删除</strong>：动态地在系统中生成新的进程，同时支持对执行完毕进程的清理和删除。</li>
<li data-line="1" dir="auto"><strong>进程的挂起与恢复</strong>：提供暂停进程在 CPU 上运行的机制，并在需要时恢复进程的执行状态。</li>
<li data-line="2" dir="auto"><strong>CPU 上的进程调度</strong>：根据调度算法将进程分配到 CPU 上运行，实现对系统资源的高效利用。</li>
<li data-line="3" dir="auto"><strong>进程间通信的机制</strong>：提供进程之间的协同工作、资源共享和任务协调，完成更复杂的任务。</li>
<li data-line="4" dir="auto"><strong>进程间同步的机制</strong>：确保多个进程在共享资源时不会发生冲突（进程 A 读的同时进程 B 写）。</li>
</ul></div><div class="el-p"><p dir="auto">这些功能我们将会在 <strong>PROCESS MANAGEMENT</strong> 的部分进行介绍。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.2 Memory Management" dir="auto" class="heading" id="3.2_Memory_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 Memory Management</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.1 Main Memory" dir="auto" class="heading" id="3.2.1_Main_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1 Main Memory</h4><div class="heading-children"><div class="el-p"><p dir="auto">CPU 只能从内存中加载指令执行，所以任何需要运行的程序就需要首先加载到内存中。在大多数情况下，计算机都会从一块可读可写的内存中读取并运行程序，我们称之为<strong>主存</strong>，也叫<strong>随机存储器 (Random Access Memory, RAM)</strong>。主存一般采用<strong>动态随机存储器 (DRAM)</strong> 的半导体技术实现。</p></div><div class="el-p"><p dir="auto">RAM 是一种<strong>易失性 (volatile)</strong> 存储器，即一旦断电，RAM 中存储的数据就会消失。所以除了主存，计算机系统中还需要其他类型的存储器来保存关键数据，即使在断电时也不丢失。比如，计算机加电后运行的第一个程序，我们称之为<strong>启动程序 (bootstrap program)</strong>，一般存储在一块非易失性存储器中，如<strong>闪存 (Flash)</strong> 和电可擦写可编程只读存储器 (EEPROM) 。</p></div><div class="el-p"><p dir="auto">内存由一系列的字节构成，每个字节都拥有其唯一的地址。不同指令集架构下的 CPU 可能通过不同的汇编指令和内存进行交互。比如在 x86 汇编中，常常通过 <code>MOV</code> 指令来实现加载和存储操作。如：</p></div><div class="el-pre"><pre class="language-asm" tabindex="0"><code data-line="0" class="language-asm is-loaded">MOV AX, 10
MOV BX, [0x1000]
ADD AX, BX
MOV [0x1000], AX
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这段代码将一个立即数 <code>10</code> 赋予 <code>AX</code>，然后将内存地址 <code>0x1000</code> 的数据加载到寄存器 <code>BX</code> 中。相加两个寄存器并将结果存储在 <code>AX</code> 中，最后将结果写回 <code>0x1000</code> 中。</p></div><div class="el-p"><p dir="auto">而在 ARM 架构下的汇编中，CPU 通过 <code>LDR</code> 和 <code>STR</code> 指令和内存进行交互。<code>LDR</code> 就是将主存中的数据加载到 CPU 中的某个寄存器里面，<code>STR</code> 就是将寄存器中的内存存储到主存中。我们在上面看到，x86 是通过 <code>MOV</code> 指令来实现这两种操作的。ARM 汇编中，我们可以用下面的代码实现同样的功能：</p></div><div class="el-pre"><pre class="language-asm" tabindex="0"><code data-line="0" class="language-asm is-loaded">LDR R1, [0x1000]
ADD R1, R1, #10
STR R1, [0x1000]
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">其效果和 x86 汇编是一样的。</p></div><div class="el-p"><p dir="auto">之前，我们接触到了 CPU 指令周期，在 von Neumann 架构的机器下，CPU执行的每条指令都会经历这样的指令周期，包括：取指令周期，解码周期，执行周期和写回周期（可能没有）。在指令的取指令周期中，CPU就会从内存中加载指令。</p></div><div class="el-p"><p dir="auto">从上面的描述中，我们窥得在主存计算机系统中的核心地位，但是 DRAM 半导体的性质赋予了主存一些难言之隐。在大多数情况下，我们都希望自己的劳动成果能够永久地保存下来。但主存是易失性的存储器，只要断电，内容就会永久丢失掉。而且主存一般情况下都很小，不能够存储我们想要的所有程序和数据。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.2 Storage Hierarchy Structure" dir="auto" class="heading" id="3.2.2_Storage_Hierarchy_Structure"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.2 Storage Hierarchy Structure</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了解决主存的难言之隐，大部分的计算机系统都会提供一个多级的存储器结构来优化存储性能并扩展主存功能。比如，我们现在有<strong>二级存储 (secondary storage)</strong> 来作为主存的扩展。我们可以将需要永久保存的程序和数据放到二级存储器中进行永久保存。</p></div><div class="el-p"><p dir="auto"><span alt="Storage_Device_Hierarchy.png" src="Storage_Device_Hierarchy.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Storage_Device_Hierarchy.png" src="congzhi's-os-series/pics/storage_device_hierarchy.png"></span></p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Secondary Storage" dir="auto" class="heading" id="Secondary_Storage"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Secondary Storage</h5><div class="heading-children"><div class="el-p"><p dir="auto">二级存储器通常由 <strong>hard-disk drives (HDDs)</strong> 或 <strong>solid-state drives (SSDs)</strong> 这类<strong>非易失性的 (nonvolatile)</strong> 存储介质组成。大多数程序都会存储在二级存储器中等待加载进内存中执行。虽然二级存储器容量很大，而且具有非易失性，但二级存储器通常都很慢。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Tertiary Storage" dir="auto" class="heading" id="Tertiary_Storage"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tertiary Storage</h5><div class="heading-children"><div class="el-p"><p dir="auto">非易失性的存储器除了二级存储器之外还有三级存储器。三级存储器结构通常由光盘和磁带构成，你可以想象它们有多慢，所以三级存储器一般只用作程序或数据的备份。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.3 Memory Management" dir="auto" class="heading" id="3.2.3_Memory_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.3 Memory Management</h4><div class="heading-children"><div class="el-p"><p dir="auto">无论是计算机系统还是存储层次结构中，主存始终处于核心位置。主存就相当于一个共享的仓库，为 CPU 和 I/O 设备提供快速的访问。在取指令周期中，CPU 从主存中读取指令。我们先前提到程序和数据都是存储在二级存储器中的，但主存是 CPU 唯一能够直接访问的大容量存储器，如果 CPU 要执行某个程序，就必须首先被加载到主存中。</p></div><div class="el-p"><p dir="auto">在早期的计算机中，主存容量有限，这意味着内存可能只能确保一个程序的执行。为了让程序能够运行，操作系统会采用将程序加载到固定物理地址（绝对地址）。程序直接使用物理地址来访问内存。CPU 也通过物理地址取指令和数据。在程序执行结束后，操作系统会释放其占用的内存空间，供其他程序使用。</p></div><div class="el-p"><p dir="auto">之后，随着内存的扩大和 CPU 性能的提升，为了充分利用资源并支持多程序系统，降低计算机对用户的响应，使得计算机需要将好多个进程加载进内存中。也就诞生了最早的对内存管理的需求。为实现有效的内存管理，诞生了许多不同的内存管理模式，并且大多都并依赖特定硬件的支持。</p></div><div class="el-p"><p dir="auto">为了支持多程序并发，后续系统引入了<strong>静态重定位 (static relocation)</strong> ，通过依赖一些特殊的寄存器（如基址寄存器和界限寄存器）来实现地址的转换。这个时期的系统开始使用<strong>逻辑地址(Logical Address)</strong> 的概念。这时的内存管理仍然非常简单，操作系统只需要：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>跟踪物理内存状态</strong>：记录空闲/已用内存区域。</li>
<li data-line="1" dir="auto"><strong>动态分配/回收内存</strong>：通过一些内存分配算法来分配物理内存。</li>
<li data-line="2" dir="auto"><strong>进程隔离与保护</strong>：通过寄存器实现简单的进程隔离。</li>
<li data-line="3" dir="auto"><strong>交换技术 (Swapping)</strong>：将闲置进程换出到二级存储器上以便腾出更多的内存空间。</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="memory_layout_multiprogramming.png" src="memory_layout_multiprogramming.png" class="internal-embed media-embed image-embed is-loaded"><img alt="memory_layout_multiprogramming.png" src="congzhi's-os-series/pics/memory_layout_multiprogramming.png"></span></p></div><div class="el-p"><p dir="auto">为了进一步优化内存的使用效率，同时保障系统的稳定性和安全性。现代操作系统引入了更复杂的内存管理机制，例如，现代计算机系统都引入了<strong>内存管理单元 (MMU)</strong> 来实现如<strong>虚拟内存 (Virtual Memory)</strong> 和<strong>内存保护 (Memory Protection)</strong> 等更复杂的内存管理机制。此处略过。</p></div><div class="el-p"><p dir="auto">我们后续将在 <strong>Memory Management</strong> 部分详细介绍操作系统是如何进行内存管理的。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.3 CPU Cache" dir="auto" class="heading" id="3.3_CPU_Cache"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3 CPU Cache</h3><div class="heading-children"><div class="el-p"><p dir="auto">除了非易失性，主存还有一个问题，即相比较于 CPU 而言的速度太慢了。在 70-80 年代的早期计算机中，主存的速度和 CPU 较为匹配。但随着半导体技术的突破，主存和 CPU 性能开始扩大，逐渐落后于 CPU 的吞吐要求。</p></div><div class="el-p"><p dir="auto">（比如 1980 年 8086 CPU 主频 5MHz（200ns），DRAM 访问延迟约 200ns，基本匹配；而 2020 年的 i9-10900K 主频 5.3GHz（0.19ns），DDR4 内存延迟约 50ns，差距达&nbsp;263 倍。）</p></div><div class="el-p"><p dir="auto">这种速度差异就意味着 CPU 在等待主存响应时会浪费大量资源。为了弥补这一性能差距，我们需要一种速度能匹配 CPU 的存储介质。要这么多层的存储介质的好处就是让每次 CPU 在取指令/数据时，都优先从更快的存储介质中寻找，这就是<strong>缓存 (Caching)</strong> 所做的事情。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.3.1 Intro to CPU Cache" dir="auto" class="heading" id="3.3.1_Intro_to_CPU_Cache"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3.1 Intro to CPU Cache</h4><div class="heading-children"><div class="el-p"><p dir="auto">之前我们了解到了二级存储器的概念，在一定程度上解决了内存易失性的问题。我们会将程序和数据存放在二级存储器上，如果 CPU 在内存中找不到相关的信息，系统就会从二级存储器中寻找并将需要的信息全部或部分的加载到内存中。所以，你可以将内存理解为二级存储器的“缓存”。</p></div><div class="el-p"><p dir="auto">为了匹配 CPU 的速度，我们需要引入一种更快的存储介质，这样在 CPU 执行指令时，率先从这种更快的介质中寻找需要的数据或指令。如果未找到，则从内存中加载数据，并将数据存入这种告诉存储介质中方便后续使用。我们把这种介质称为<strong>缓存 (Cache)</strong> 。</p></div><div class="el-p"><p dir="auto">缓存是用一种叫 SRAM (Static Random Access Memory) 的技术实现的，它有以下特点：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>高速度</strong>：访问速度只需要约 5 个 CPU 时钟周期，相比之下，主存需要上百个时钟周期。</li>
<li data-line="1" dir="auto"><strong>小容量</strong>：大小通常在 MB 级别，相比之下，主存大小通常是 GB 级别的。</li>
</ul></div><div class="el-p"><p dir="auto">现代计算机系统中，缓存通常集成在 CPU 芯片上，并且采用分层设计，以进一步优化性能。</p></div><div class="el-p"><p dir="auto"><span alt="speed_of_storage_hierarchy.png" src="speed_of_storage_hierarchy.png" class="internal-embed media-embed image-embed is-loaded"><img alt="speed_of_storage_hierarchy.png" src="congzhi's-os-series/pics/speed_of_storage_hierarchy.png"></span></p></div><div class="el-p"><p dir="auto">缓存有 CPU 和内置的 MMU 单元进行管理，虽然这一层次对于操作系统而言不可见，但是系统程序员必须了解这一存储层次。比如，操作系统的调度策略就需要考虑到缓存这一层次的存储结构。在 <strong>CPU SCHEDULING</strong> 阶段和 <strong>MEMORY MANAGEMENT</strong> 阶段，我们还会接触到这一存储层次。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.4 I/O System Management" dir="auto" class="heading" id="3.4_I/O_System_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.4 I/O System Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">在操作系统中，I/O 管理是核心模块。在某种意义上，I/O 系统的运行效率和稳定性直接地决定了整个系统的可用性，因为 I/O 的管理涉及到于用户交互设备的工作（如键盘、鼠标、显示器等）。为了确保系统的可靠性和性能，操作系统需要对 IO 进行管理。</p></div><div class="el-p"><p dir="auto">此外，操作系统的一大职责就是对底层硬件的封装。这意味着操作系统需要封装并隐藏 I/O 设备的细节，为上层应用提供统一的接口，从而简化开发与使用。这些 I/O 设备的复杂细节由操作系统的 <strong>I/O 子系统</strong>负责管理。I/O 子系统主要包含以下部分：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>内存管理组件</strong>：包括<strong>缓冲 (Buffering)</strong>、<strong>缓存 (Caching)</strong> 和<strong>假脱机 (SPOOLing)</strong>。用于优化 I/O 的数据传输速度。</li>
<li data-line="1" dir="auto"><strong>统一接口</strong>：为不同的设备提供通用的设备驱动接口，使得上层软件无需关心硬件细节。</li>
<li data-line="2" dir="auto"><strong>设备管理</strong>：通过设备驱动程序管理和区分特定的硬件设备，屏蔽硬件差异。</li>
<li data-line="3" dir="auto"><strong>I/O 调度</strong>：优化设备请求处理的顺序，提高资源利用率和吞吐量。</li>
<li data-line="4" dir="auto"><strong>中断驱动</strong>：通过中断请求设备并通知操作系统设备完成任务，避免 CPU 的等待。</li>
</ul></div><div class="el-p"><p dir="auto">中断我们会在 <strong>INTERRUPTS AND SYSTEM CALLS</strong> 进行介绍，操作系统 I/O 子系统会和大存储管理、文件系统管理在 <strong>I/O SUBSYSTEM &amp; MASS STORAGE &amp; FILE-SYSTEMS</strong> 这三个阶段进行详细地介绍。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.5 Mass Storage Management" dir="auto" class="heading" id="3.5_Mass_Storage_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.5 Mass Storage Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">在学习内存管理的时候，我们穿插了一些层次化存储结构的内容。我们看到，在现代计算机中，计算机系统必须提供二级存储层次作为主存的后备。二级存储器是一类特殊的 I/O 设备，通常采用 HDDs 和 SSDs 这样的存储介质。它们的速度较主存慢得多，且数据的交互方式类似于 I/O 操作。</p></div><div class="el-p"><p dir="auto">为了高效管理二级存储，操作系统需要提供如下的管理功能：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>磁盘分区</strong>：将物理存储设备划分成多个逻辑分区。</li>
<li data-line="1" dir="auto"><strong>分区挂载</strong>：将分区与操作系统的目录结构连接，以便用户和程序可以访问分区中的数据。</li>
<li data-line="2" dir="auto"><strong>空闲空间管理</strong>：记录哪些磁盘区域是空闲的，并动态分配空闲空间以存储新数据。</li>
<li data-line="3" dir="auto"><strong>存储分配</strong>：根据文件或数据块的大小分配磁盘空间，尽量减少碎片化，提高存储效率。</li>
<li data-line="4" dir="auto"><strong>磁盘调度</strong>：多个请求同时发生时，决定磁盘访问的顺序，减少磁盘寻道时间。</li>
<li data-line="5" dir="auto"><strong>存储保护</strong>：确保文件和分区的安全性，防止未经授权的访问或数据损坏。</li>
</ul></div><div class="el-p"><p dir="auto">除了二级存储器，计算机系统中可能还存在三级存储结构（如磁带驱动器、光盘驱动器等），这一层次对于性能而言并不关键。但如果系统还包含这一层次的存储，操作系统也需要提供类似的管理功能，如：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>挂载和卸载</strong></li>
<li data-line="1" dir="auto"><strong>数据迁移</strong></li>
</ul></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.6 File-System Management" dir="auto" class="heading" id="3.6_File-System_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.6 File-System Management</h3><div class="heading-children"><div class="el-p"><p dir="auto">文件系统操作系统在大存储系统管理的基础上实现的核心模块。借助二级/三级存储器（也叫块设备）非易失性的特性，文件系统实现了对程序和数据的<strong>持久化保存 (Persistence)</strong>。文件系统一般会封装对二级存储器的大存储管理，为用户提供了更高级的接口，方便操作和管理。</p></div><div class="el-p"><p dir="auto">操作系统会将物理存储设备上存放的数据抽象为逻辑上的存储单元，也就是我们常见的<strong>文件 (File)</strong>，文件是一个包含相联信息的集合。通常而言，文件用于表示程序或数据（可能是数字、字母或二进制类型）。文件有很多类型，一般根据后缀名来区分不同类型格式的文件。</p></div><div class="el-p"><p dir="auto">为了更好地管理二级存储器上的文件，文件系统通常会用<strong>目录 (Directories)</strong> 来管理文件。此外，文件系统还会将逻辑上的文件与存储文件的底层的物理存储介质（如块设备）进行映射，管理其逻辑与物理结构。</p></div><div class="el-p"><p dir="auto">为了高效管理二级存储器上的文件，文件系统提供了以下核心功能：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>创建并删除文件</strong>：允许用户在文件系统中创建、删除文件，确保存储资源的动态管理。</li>
<li data-line="1" dir="auto"><strong>创建并删除目录</strong>：目录（文件夹）用于组织文件，形成层次化的结构以方便存储和检索。</li>
<li data-line="2" dir="auto"><strong>文件和目录操作</strong>：提供操作文件和目录的操作，如读取、写入、重命名、复制等。</li>
<li data-line="3" dir="auto"><strong>文件和存储设备的映射</strong>：负责将文件的逻辑地址映射到底层存储介质上的物理块。</li>
<li data-line="4" dir="auto"><strong>文件持久化备份</strong>：支持将内存中的数据备份到非易失性存储设备上，持久化存储数据。</li>
</ul></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第四课 Virtualization" dir="auto" class="heading" id="第四课_Virtualization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第四课 Virtualization</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">之前的学习中，我们明确指出了操作系统的核心作用，即<strong>封装底层硬件</strong>、为上层应用软件提供服务的系统程序。通过引入间接层，操作系统使得用户能够更方便地使用计算机，同时不需要关心复杂的硬件细节。此外，系统的安全性也得到了保障，因为每个程序必须通过系统调用来申请资源。</p></div><div class="el-p"><p dir="auto">在本节课中，我们将学习操作系统如何通过<strong>抽象与虚拟化</strong>为应用程序提供服务，并优化资源使用。同时，我们还会回答一个关键问题：操作系统为应用程序提供的资源在应用的视角下是怎么样的？</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.1 Abstraction and Interfaces" dir="auto" class="heading" id="4.1_Abstraction_and_Interfaces"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 Abstraction and Interfaces</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>抽象</strong>是操作系统设计中一个重要且核心的概念。前两课中，我们已经隐约地感受到抽象在不同层次的应用。在第一节课中，我们了解到 CPU 是对晶体管硬件的封装抽象、操作系统是对 CPU 内存及 I/O 等计算机硬件资源进行封装抽象。在第二节，我们又从编程语言的角度理解抽象。</p></div><div class="el-p"><p dir="auto">抽象的意义在于：<strong>隐藏底层的复杂性，只向上层暴露最关键的信息</strong>。抽象可以简化上层的开发过程，并为系统架构的扩展性提供了支持。抽象的结果就是<strong>接口</strong>，它可以连接不同层次的系统组件，支持更高级的应用。根据功能与连接对象的不同，接口可以划分为以下几类：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>硬件与硬件之间的接口</strong>：比如主板上的各种端口。用于连接内存、CPU和I/O设备。</li>
<li data-line="1" dir="auto"><strong>软件与软件之间的接口</strong>：比如程序之间用来交换数据的<strong>应用程序编程接口 (API)</strong> 。</li>
<li data-line="2" dir="auto"><strong>硬件和软件之间的接口</strong>：比如操作系统通过<strong>硬件抽象层 (HAL)</strong> 将底层硬件细节封装。</li>
</ul></div><div class="el-p"><p dir="auto">我们在这里关注的是应用-操作系统-硬件之间的抽象，所以我们下面先简单介绍一下经过操作系统硬件抽象层抽象后的硬件资源在操作系统眼中是怎么样的。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.1 Hardware Abstraction Layer" dir="auto" class="heading" id="4.1.1_Hardware_Abstraction_Layer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1 Hardware Abstraction Layer</h4><div class="heading-children"><div class="el-p"><p dir="auto">操作系统硬件抽象层是内核的一部分，主要提供针对底层硬件的标准化接口。操作系统的作用之一就是封装底层硬件，内核的 HAL 就是系统与硬件进行直接交互的部分。使操作系统能够通过硬件驱动程序与具体的 CPU、内存和外设交互，而无需关心硬件实现的差异。</p></div><div class="el-p"><p dir="auto">经过 HAL 的封装，操作系统的其他子模块（如调度器、内存管理、IO 子系统）可以使用统一的接口与下层的硬件进行交互，而不用担心平台架构的不同（ARM 还是 x86）。由此，HAL 的存在赋予了操作系统在不同架构平台上的可移植性。在不同的平台下，只需要更换相应的 HAL 模块就好了。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.2 Operating System API" dir="auto" class="heading" id="4.1.2_Operating_System_API"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.2 Operating System API</h4><div class="heading-children"><div class="el-p"><p dir="auto">在 HAL 屏蔽硬件的细节的基础上，操作系统的其他资源管理模块就可以无视硬件细节，将 HAL 封装的系统硬件资源进行二次抽象来为应用程序提供更高级的 API 接口。二次抽象的作用往往就是对资源进行统一管理并提升系统的安全性。</p></div><div class="el-p"><p dir="auto">以内存管理为例，内存管理模块会通过分页 (Paging) 机制将物理内存虚拟化成虚拟内存，为应用程序提供连续的虚拟地址空间。从而应用开发者就不需要关心实际物理内存的布局了。</p></div><div class="el-p"><p dir="auto">由于虚拟内存需要通过操作系统内存管理模块将虚拟内存转化成物理内存，之后由 HAL 进行实际的分配和管理。所以间接的确保了内存资源的安全性。此外，资源管理模块通常还会实现更为高级的功能，如写时复制、内存隔离等高级功能。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.3 Process' View of System Resources" dir="auto" class="heading" id="4.1.3_Process'_View_of_System_Resources"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.3 Process' View of System Resources</h4><div class="heading-children"><div class="el-p"><p dir="auto">在进程的视角下，操作系统通过<strong>虚拟化技术</strong>将物理资源转换为一致的虚拟资源供进程使用。尽管进程在运行时可以获得 CPU 资源、内存资源、I/O 资源，但经过资源管理模块的二次抽象，这些资源都将是虚拟的，什么意思呢？</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="Virtualized Memory" dir="auto" class="heading" id="Virtualized_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Virtualized Memory</h5><div class="heading-children"><div class="el-p"><p dir="auto">上面我们提到了虚拟内存，简单来说，进程的视角下，它自认为得到的是一个连续、完整的内存空间。而在实际的物理内存中，这些部分可能是分散存储的，甚至与其他进程共享。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Virtualized CPU" dir="auto" class="heading" id="Virtualized_CPU"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Virtualized CPU</h5><div class="heading-children"><div class="el-p"><p dir="auto">从进程的视角来看，每个进程也都认为自己独占 CPU。然而，这实际上是通过操作系统调度器实现的虚拟化。操作系统通过<strong>轮转调度 (Round-Robin)</strong> 等调度算法，将物理 CPU 的使用权在多个进程之间快速切换。</p></div><div class="el-p"><p dir="auto">这种调度策略称为<strong>分时策略 (time-sharing)</strong>，操作系统将 CPU 的运行时间划分为多个时间片，每个进程在一个时间片内运行，时间片耗尽后切换到下一个进程。通过这种方式，操作系统为每个进程提供了<strong>虚拟 CPU</strong> 的假象，使其感觉自己持续运行。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Virtualized I/O" dir="auto" class="heading" id="Virtualized_I/O"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Virtualized I/O</h5><div class="heading-children"><div class="el-p"><p dir="auto">此外，操作系统还会通过设备驱动程序和 HAL，将复杂的设备交互封装为标准化的系统调用接口。在进程的视角下，I/O 操作简单而直接（<code>read()</code>, <code>write</code> 系统调用），根本不需要了解 I/O 是怎么运作的。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="Virtualized Machine" dir="auto" class="heading" id="Virtualized_Machine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Virtualized Machine</h5><div class="heading-children"><div class="el-p"><p dir="auto">经过上面的学习，我们了解到应用程序使用的资源只是操作系统通过虚拟化为应用程序提供的一种“幻象”。这层“幻象”是操作系统将底层物理资源（如 CPU、内存和 I/O 设备）通过抽象与虚拟化技术封装后呈现的。</p></div><div class="el-p"><p dir="auto">作为使用计算机的用户，我们对机器的接触也停留在这一层“幻象”上。由于操作系统的封装和抽象，我们是看不到硬件的细节和物理资源是如何分配的。操作系统会帮我们将这一层“幻象”转换成机器上的物理资源。所以，我们可以说操作系统为应用程序和用户提供了一台“虚拟的机器”。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.2 Virtualization and Virtual Machine" dir="auto" class="heading" id="4.2_Virtualization_and_Virtual_Machine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 Virtualization and Virtual Machine</h3><div class="heading-children"><div class="el-p"><p dir="auto">在上小节，我们讨论了资源虚拟化的概念，通过操作系统各个资源管理模块对物理硬件进行抽象和封装，使得应用程序能够简化对底层硬件的使用。而除了资源虚拟化，操作系统一般还提供一种更高级的<strong>虚拟化技术 (Virtualization)</strong>，即提供在一个物理主机上运行多个操作系统的能力。</p></div><div class="el-p"><p dir="auto">这种虚拟化一般通过一层虚拟化软件来实现，一般称为<strong>虚拟机管理器 (Hypervisor)</strong>。Hypervisor 会抽象底层的硬件资源，为每个操作系统实例（虚拟机）提供独立的运行环境。这种虚拟化技术和资源虚拟化很类似，我们将在 <strong>ADVANCED TOPICS</strong> 中进行详细地介绍这种虚拟化技术。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第五课 Sharing and Asynchronous" dir="auto" class="heading" id="第五课_Sharing_and_Asynchronous"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第五课 Sharing and Asynchronous</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在考研 408 科目的参考书之一——《计算机操作系统》（汤小丹）中，将操作系统的特性归纳为“四大特征”（即并发、共享、虚拟和异步）。我们介绍过了虚拟（资源虚拟化），本节课我们就来介绍其他的三个特征。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.1 Sharing" dir="auto" class="heading" id="5.1_Sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 Sharing</h3><div class="heading-children"><div class="el-p"><p dir="auto">在操作系统中，<strong>共享</strong>是资源管理的核心目标之一。通过共享，我们期望多个应用程序可以<strong>同时使用有限的系统资源</strong>，以提升资源利用率。共享特性往往基于资源虚拟化技术。操作系统通过将物理硬件资源（如 CPU、内存和 I/O）虚拟化，为每个进程提供一个独占所有资源的“幻象”。然而，实际情况是，这些资源被多个应用程序所共享。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1.1 Shared Memory" dir="auto" class="heading" id="5.1.1_Shared_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.1 Shared Memory</h4><div class="heading-children"><div class="el-p"><p dir="auto">内存是程序运行的基础资源。在操作系统中，主存通过虚拟内存技术被抽象为一个独立、连续的地址空间，供每个进程使用。实际上，进程看到的虚拟内存可能与其他应用共享相同的物理内存页。在实际应用中，共享内存可以用于应用程序之间的通信，还有通过复用相同的代码段来实现内存共享的动态链接库。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1.2 Shared IO" dir="auto" class="heading" id="5.1.2_Shared_IO"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.2 Shared IO</h4><div class="heading-children"><div class="el-p"><p dir="auto">I/O 设备也是典型的共享资源。例如，多个任务可能需要使用同一个打印机，或者多个用户同时访问文件系统。操作系统就需要通过合理的 I/O 调度和资源管理，确保 I/O 的有序访问。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1.3 Concurrency: CPU Time-Sharing" dir="auto" class="heading" id="5.1.3_Concurrency:_CPU_Time-Sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.3 Concurrency: CPU Time-Sharing</h4><div class="heading-children"><div class="el-p"><p dir="auto">通过调度器的对物理 CPU 的虚拟化，每个进程会认为自己得到了独立的 CPU，但实际上得到的是一段 CPU 的时间片。操作系统的任务调度器通过快速切换任务，使得每个任务都能在极短的短时间内获得 CPU 的使用权。从而，在用户看来，多个任务似乎在同时进行。</p></div><div class="el-p"><p dir="auto">通过分时，一个物理的 CPU 核心可以被多个进程在逻辑上“同时”使用，实现一种在宏观上同时运行，但在微观上时间片轮流交替的效果，这就是<strong>并发 (Concurrency)</strong>。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.2 Asynchronous Operations" dir="auto" class="heading" id="5.2_Asynchronous_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 Asynchronous Operations</h3><div class="heading-children"><div class="el-p"><p dir="auto">异步操作指在执行某个操作时，不需要等待该操作完成，而是可以继续执行其他任务。操作完成后，会通过某种机制通知执行者。这种机制在操作系统中尤其重要，特别是用于管理慢速 I/O 操作。异步机制使得 CPU 不需要和慢速 I/O 一直打交道，提高了 CPU 的运行效率。</p></div><div class="el-p"><p dir="auto">操作系统通过中断和信号机制来实现异步操作。当某个 I/O 操作完成时，硬件会发送一个中断信号给 CPU，CPU 会暂停当前的任务，转而处理这个中断信号。处理完中断信号后，CPU会恢复之前的任务。这样，进程就不需要一直等待 I/O 操作的完成，而是可以在 I/O 操作完成时被通知。</p></div><div class="el-p"><p dir="auto">异步操作不仅限于 I/O 操作，还可以应用于其他需要等待的操作，比如网络通信、定时任务等。通过异步操作，操作系统能够更高效地利用资源，提高系统的响应速度和吞吐量。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第六课 Security and Protection" dir="auto" class="heading" id="第六课_Security_and_Protection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第六课 Security and Protection</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">多个<strong>特权级别</strong>用于区分程序的运行权限；<br>
通过<strong>用户帐户和权限管理</strong>隔离不同用户；<br>
使用<strong>虚拟地址空间</strong>隔离不同的应用程序；<br>
...</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1. Introduction to Operating Systems"><div class="tree-item-contents heading-link" heading-name="
Introduction to Operating Systems
"><span class="tree-item-title">Introduction to Operating Systems</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第一课__Operating_Systems:_Fundamentals_and_Functions"><div class="tree-item-contents heading-link" heading-name="第一课  Operating Systems: Fundamentals and Functions"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课  Operating Systems: Fundamentals and Functions</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1_Computing_System"><div class="tree-item-contents heading-link" heading-name="1.1 Computing System"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Computing System</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1.1_Computer_Hardware"><div class="tree-item-contents heading-link" heading-name="1.1.1 Computer Hardware"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.1 Computer Hardware</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Components_of_a_Computer"><div class="tree-item-contents heading-link" heading-name="Components of a Computer"><span class="tree-item-title">Components of a Computer</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1.2_Computer_Workflow"><div class="tree-item-contents heading-link" heading-name="1.1.2 Computer Workflow"><span class="tree-item-title">1.1.2 Computer Workflow</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1.3_CPU_Fetch-Decode-Execute_Cycle"><div class="tree-item-contents heading-link" heading-name="1.1.3 CPU Fetch-Decode-Execute Cycle"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.3 CPU Fetch-Decode-Execute Cycle</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Instruction_Fetch_Cycle"><div class="tree-item-contents heading-link" heading-name="Instruction Fetch Cycle"><span class="tree-item-title">Instruction Fetch Cycle</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Instruction_Decode_Cycle"><div class="tree-item-contents heading-link" heading-name="Instruction Decode Cycle"><span class="tree-item-title">Instruction Decode Cycle</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Instruction_Execute_Cycle"><div class="tree-item-contents heading-link" heading-name="Instruction Execute Cycle"><span class="tree-item-title">Instruction Execute Cycle</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Write-back_Cycle"><div class="tree-item-contents heading-link" heading-name="Write-back Cycle"><span class="tree-item-title">Write-back Cycle</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#User's_Perspective"><div class="tree-item-contents heading-link" heading-name="User's Perspective"><span class="tree-item-title">User's Perspective</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1.4_CPU_Hardware_Abstractions"><div class="tree-item-contents heading-link" heading-name="1.1.4 CPU Hardware Abstractions"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.4 CPU Hardware Abstractions</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Abstractions_of_Instruction_Set_Architecture"><div class="tree-item-contents heading-link" heading-name="Abstractions of Instruction Set Architecture"><span class="tree-item-title">Abstractions of Instruction Set Architecture</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Use_of_a_Bare_Machine"><div class="tree-item-contents heading-link" heading-name="Use of a Bare Machine"><span class="tree-item-title">Use of a Bare Machine</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.1.5_Computer_Software"><div class="tree-item-contents heading-link" heading-name="1.1.5 Computer Software"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.5 Computer Software</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Software_of_Operating_Systems"><div class="tree-item-contents heading-link" heading-name="Software of Operating Systems"><span class="tree-item-title">Software of Operating Systems</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Application_Programs"><div class="tree-item-contents heading-link" heading-name="Application Programs"><span class="tree-item-title">Application Programs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.2_Roles_of_Operating_Systems:_User_and_System_Perspectives"><div class="tree-item-contents heading-link" heading-name="1.2 Roles of Operating Systems: User and System Perspectives"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.2 Roles of Operating Systems: User and System Perspectives</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.2.1_User_Perspective:_Ease_of_Use"><div class="tree-item-contents heading-link" heading-name="1.2.1 User Perspective: Ease of Use"><span class="tree-item-title">1.2.1 User Perspective: Ease of Use</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.2.2_System_Perspective:_A_Control_Program"><div class="tree-item-contents heading-link" heading-name="1.2.2 System Perspective: A Control Program"><span class="tree-item-title">1.2.2 System Perspective: A Control Program</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#1.2.3_What_is_an_Operating_System"><div class="tree-item-contents heading-link" heading-name="1.2.3 What is an Operating System"><span class="tree-item-title">1.2.3 What is an Operating System</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第二课_Bridging_High-Level_Language_and_Machine_Code"><div class="tree-item-contents heading-link" heading-name="第二课 Bridging High-Level Language and Machine Code"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 Bridging High-Level Language and Machine Code</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#2.1_From_Machine_Code_to_Assembly"><div class="tree-item-contents heading-link" heading-name="2.1 From Machine Code to Assembly"><span class="tree-item-title">2.1 From Machine Code to Assembly</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#2.2_From_Assembly_to_High_Level_Languages"><div class="tree-item-contents heading-link" heading-name="2.2 From Assembly to High Level Languages"><span class="tree-item-title">2.2 From Assembly to High Level Languages</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#2.3_Interpreted_Language:_Higher_Level_Abstractions"><div class="tree-item-contents heading-link" heading-name="2.3 Interpreted Language: Higher Level Abstractions"><span class="tree-item-title">2.3 Interpreted Language: Higher Level Abstractions</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#2.4_Human_Language_Complier,_Any_Chance?"><div class="tree-item-contents heading-link" heading-name="2.4 Human Language Complier, Any Chance?"><span class="tree-item-title">2.4 Human Language Complier, Any Chance?</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第三课_Resource_Management"><div class="tree-item-contents heading-link" heading-name="第三课 Resource Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Resource Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.1_Process_Management"><div class="tree-item-contents heading-link" heading-name="3.1 Process Management"><span class="tree-item-title">3.1 Process Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.2_Memory_Management"><div class="tree-item-contents heading-link" heading-name="3.2 Memory Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2 Memory Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.2.1_Main_Memory"><div class="tree-item-contents heading-link" heading-name="3.2.1 Main Memory"><span class="tree-item-title">3.2.1 Main Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.2.2_Storage_Hierarchy_Structure"><div class="tree-item-contents heading-link" heading-name="3.2.2 Storage Hierarchy Structure"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2.2 Storage Hierarchy Structure</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Secondary_Storage"><div class="tree-item-contents heading-link" heading-name="Secondary Storage"><span class="tree-item-title">Secondary Storage</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Tertiary_Storage"><div class="tree-item-contents heading-link" heading-name="Tertiary Storage"><span class="tree-item-title">Tertiary Storage</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.2.3_Memory_Management"><div class="tree-item-contents heading-link" heading-name="3.2.3 Memory Management"><span class="tree-item-title">3.2.3 Memory Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.3_CPU_Cache"><div class="tree-item-contents heading-link" heading-name="3.3 CPU Cache"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.3 CPU Cache</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.3.1_Intro_to_CPU_Cache"><div class="tree-item-contents heading-link" heading-name="3.3.1 Intro to CPU Cache"><span class="tree-item-title">3.3.1 Intro to CPU Cache</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.4_I/O_System_Management"><div class="tree-item-contents heading-link" heading-name="3.4 I/O System Management"><span class="tree-item-title">3.4 I/O System Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.5_Mass_Storage_Management"><div class="tree-item-contents heading-link" heading-name="3.5 Mass Storage Management"><span class="tree-item-title">3.5 Mass Storage Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#3.6_File-System_Management"><div class="tree-item-contents heading-link" heading-name="3.6 File-System Management"><span class="tree-item-title">3.6 File-System Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第四课_Virtualization"><div class="tree-item-contents heading-link" heading-name="第四课 Virtualization"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第四课 Virtualization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#4.1_Abstraction_and_Interfaces"><div class="tree-item-contents heading-link" heading-name="4.1 Abstraction and Interfaces"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1 Abstraction and Interfaces</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#4.1.1_Hardware_Abstraction_Layer"><div class="tree-item-contents heading-link" heading-name="4.1.1 Hardware Abstraction Layer"><span class="tree-item-title">4.1.1 Hardware Abstraction Layer</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#4.1.2_Operating_System_API"><div class="tree-item-contents heading-link" heading-name="4.1.2 Operating System API"><span class="tree-item-title">4.1.2 Operating System API</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#4.1.3_Process'_View_of_System_Resources"><div class="tree-item-contents heading-link" heading-name="4.1.3 Process' View of System Resources"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1.3 Process' View of System Resources</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Virtualized_Memory"><div class="tree-item-contents heading-link" heading-name="Virtualized Memory"><span class="tree-item-title">Virtualized Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Virtualized_CPU"><div class="tree-item-contents heading-link" heading-name="Virtualized CPU"><span class="tree-item-title">Virtualized CPU</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Virtualized_I/O"><div class="tree-item-contents heading-link" heading-name="Virtualized I/O"><span class="tree-item-title">Virtualized I/O</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#Virtualized_Machine"><div class="tree-item-contents heading-link" heading-name="Virtualized Machine"><span class="tree-item-title">Virtualized Machine</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#4.2_Virtualization_and_Virtual_Machine"><div class="tree-item-contents heading-link" heading-name="4.2 Virtualization and Virtual Machine"><span class="tree-item-title">4.2 Virtualization and Virtual Machine</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第五课_Sharing_and_Asynchronous"><div class="tree-item-contents heading-link" heading-name="第五课 Sharing and Asynchronous"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第五课 Sharing and Asynchronous</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#5.1_Sharing"><div class="tree-item-contents heading-link" heading-name="5.1 Sharing"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.1 Sharing</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#5.1.1_Shared_Memory"><div class="tree-item-contents heading-link" heading-name="5.1.1 Shared Memory"><span class="tree-item-title">5.1.1 Shared Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#5.1.2_Shared_IO"><div class="tree-item-contents heading-link" heading-name="5.1.2 Shared IO"><span class="tree-item-title">5.1.2 Shared IO</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#5.1.3_Concurrency:_CPU_Time-Sharing"><div class="tree-item-contents heading-link" heading-name="5.1.3 Concurrency: CPU Time-Sharing"><span class="tree-item-title">5.1.3 Concurrency: CPU Time-Sharing</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#5.2_Asynchronous_Operations"><div class="tree-item-contents heading-link" heading-name="5.2 Asynchronous Operations"><span class="tree-item-title">5.2 Asynchronous Operations</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="congzhi's-os-series\1.-introduction-to-operating-systems.html#第六课_Security_and_Protection"><div class="tree-item-contents heading-link" heading-name="第六课 Security and Protection"><span class="tree-item-title">第六课 Security and Protection</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>