<!DOCTYPE html> <html><head>
		<title>12. Memory Management</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 12. Memory Management">
		<meta property="og:title" content="12. Memory Management">
		<meta property="og:description" content="Congzhi's Notes Vault - 12. Memory Management">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/12.-memory-management.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/pasted-image-20240728054403.png">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-msup { display: inline-block; text-align: left; }
mjx-c.mjx-c4D::before { padding: 0.683em 0.917em 0px 0px; content: "M"; }
mjx-c.mjx-c79::before { padding: 0.431em 0.528em 0.204em 0px; content: "y"; }
mjx-c.mjx-c42::before { padding: 0.683em 0.708em 0px 0px; content: "B"; }
mjx-c.mjx-c73::before { padding: 0.448em 0.394em 0.011em 0px; content: "s"; }
mjx-c.mjx-c38::before { padding: 0.666em 0.5em 0.022em 0px; content: "8"; }
mjx-c.mjx-c36::before { padding: 0.666em 0.5em 0.022em 0px; content: "6"; }
mjx-c.mjx-c1D43A.TEX-I::before { padding: 0.705em 0.786em 0.022em 0px; content: "G"; }
mjx-c.mjx-c1D43E.TEX-I::before { padding: 0.683em 0.889em 0px 0px; content: "K"; }
mjx-c.mjx-c47::before { padding: 0.705em 0.785em 0.022em 0px; content: "G"; }
mjx-c.mjx-c70::before { padding: 0.442em 0.556em 0.194em 0px; content: "p"; }
mjx-c.mjx-c2217::before { padding: 0.465em 0.5em 0px 0px; content: "∗"; }
mjx-c.mjx-c35::before { padding: 0.666em 0.5em 0.022em 0px; content: "5"; }
mjx-c.mjx-c1D45A.TEX-I::before { padding: 0.442em 0.878em 0.011em 0px; content: "m"; }
mjx-c.mjx-c1D45F.TEX-I::before { padding: 0.442em 0.451em 0.011em 0px; content: "r"; }
mjx-c.mjx-c1D460.TEX-I::before { padding: 0.442em 0.469em 0.01em 0px; content: "s"; }
mjx-c.mjx-c1D436.TEX-I::before { padding: 0.705em 0.76em 0.022em 0px; content: "C"; }
mjx-c.mjx-c1D457.TEX-I::before { padding: 0.661em 0.412em 0.204em 0px; content: "j"; }
mjx-c.mjx-c1D456.TEX-I::before { padding: 0.661em 0.345em 0.011em 0px; content: "i"; }
mjx-c.mjx-c1D435.TEX-I::before { padding: 0.683em 0.759em 0px 0px; content: "B"; }
mjx-c.mjx-c1D441.TEX-I::before { padding: 0.683em 0.888em 0px 0px; content: "N"; }
mjx-mtext { display: inline-block; text-align: left; }
mjx-c.mjx-c44::before { padding: 0.683em 0.764em 0px 0px; content: "D"; }
mjx-c.mjx-c65::before { padding: 0.448em 0.444em 0.011em 0px; content: "e"; }
mjx-c.mjx-c61::before { padding: 0.448em 0.5em 0.011em 0px; content: "a"; }
mjx-c.mjx-c64::before { padding: 0.694em 0.556em 0.011em 0px; content: "d"; }
mjx-c.mjx-c6C::before { padding: 0.694em 0.278em 0px 0px; content: "l"; }
mjx-c.mjx-c69::before { padding: 0.669em 0.278em 0px 0px; content: "i"; }
mjx-c.mjx-c6E::before { padding: 0.442em 0.556em 0px 0px; content: "n"; }
mjx-c.mjx-c20::before { padding: 0px 0.25em 0px 0px; content: " "; }
mjx-c.mjx-c54::before { padding: 0.677em 0.722em 0px 0px; content: "T"; }
mjx-c.mjx-c6D::before { padding: 0.442em 0.833em 0px 0px; content: "m"; }
mjx-c.mjx-c2D::before { padding: 0.252em 0.333em 0px 0px; content: "-"; }
mjx-c.mjx-c43::before { padding: 0.705em 0.722em 0.021em 0px; content: "C"; }
mjx-c.mjx-c75::before { padding: 0.442em 0.556em 0.011em 0px; content: "u"; }
mjx-c.mjx-c72::before { padding: 0.442em 0.392em 0px 0px; content: "r"; }
mjx-c.mjx-c74::before { padding: 0.615em 0.389em 0.01em 0px; content: "t"; }
mjx-c.mjx-c53::before { padding: 0.705em 0.556em 0.022em 0px; content: "S"; }
mjx-c.mjx-c63::before { padding: 0.448em 0.444em 0.011em 0px; content: "c"; }
mjx-c.mjx-c6B::before { padding: 0.694em 0.528em 0px 0px; content: "k"; }
mjx-c.mjx-c52::before { padding: 0.683em 0.736em 0.022em 0px; content: "R"; }
mjx-c.mjx-c67::before { padding: 0.453em 0.5em 0.206em 0px; content: "g"; }
mjx-c.mjx-c45::before { padding: 0.68em 0.681em 0px 0px; content: "E"; }
mjx-c.mjx-c78::before { padding: 0.431em 0.528em 0px 0px; content: "x"; }
mjx-c.mjx-c6F::before { padding: 0.448em 0.5em 0.01em 0px; content: "o"; }
mjx-c.mjx-c2C::before { padding: 0.121em 0.278em 0.194em 0px; content: ","; }
mjx-c.mjx-c34::before { padding: 0.677em 0.5em 0px 0px; content: "4"; }
mjx-c.mjx-c37::before { padding: 0.676em 0.5em 0.022em 0px; content: "7"; }
mjx-c.mjx-c30::before { padding: 0.666em 0.5em 0.022em 0px; content: "0"; }
mjx-c.mjx-c220F.TEX-S2::before { padding: 0.95em 1.278em 0.45em 0px; content: "∏"; }
mjx-c.mjx-c1D447.TEX-I::before { padding: 0.677em 0.704em 0px 0px; content: "T"; }
mjx-c.mjx-c2264::before { padding: 0.636em 0.778em 0.138em 0px; content: "≤"; }
mjx-munderover { display: inline-block; text-align: left; }
mjx-munderover:not([limits="false"]) { padding-top: 0.1em; }
mjx-munderover:not([limits="false"]) > * { display: block; }
mjx-msubsup { display: inline-block; text-align: left; }
mjx-script { display: inline-block; padding-right: 0.05em; padding-left: 0.033em; }
mjx-script > mjx-spacer { display: block; }
mjx-c.mjx-c1D70F.TEX-I::before { padding: 0.431em 0.517em 0.013em 0px; content: "τ"; }
mjx-c.mjx-c1D458.TEX-I::before { padding: 0.694em 0.521em 0.011em 0px; content: "k"; }
mjx-c.mjx-c1D450.TEX-I::before { padding: 0.442em 0.433em 0.011em 0px; content: "c"; }
mjx-c.mjx-c1D448.TEX-I::before { padding: 0.683em 0.767em 0.022em 0px; content: "U"; }
mjx-c.mjx-c2211.TEX-S2::before { padding: 0.95em 1.444em 0.45em 0px; content: "∑"; }
mjx-c.mjx-c3C::before { padding: 0.54em 0.778em 0.04em 0px; content: "<"; }
mjx-container[jax="CHTML"] { line-height: 0; }
mjx-container [space="1"] { margin-left: 0.111em; }
mjx-container [space="2"] { margin-left: 0.167em; }
mjx-container [space="3"] { margin-left: 0.222em; }
mjx-container [space="4"] { margin-left: 0.278em; }
mjx-container [space="5"] { margin-left: 0.333em; }
mjx-container [rspace="1"] { margin-right: 0.111em; }
mjx-container [rspace="2"] { margin-right: 0.167em; }
mjx-container [rspace="3"] { margin-right: 0.222em; }
mjx-container [rspace="4"] { margin-right: 0.278em; }
mjx-container [rspace="5"] { margin-right: 0.333em; }
mjx-container [size="s"] { font-size: 70.7%; }
mjx-container [size="ss"] { font-size: 50%; }
mjx-container [size="Tn"] { font-size: 60%; }
mjx-container [size="sm"] { font-size: 85%; }
mjx-container [size="lg"] { font-size: 120%; }
mjx-container [size="Lg"] { font-size: 144%; }
mjx-container [size="LG"] { font-size: 173%; }
mjx-container [size="hg"] { font-size: 207%; }
mjx-container [size="HG"] { font-size: 249%; }
mjx-container [width="full"] { width: 100%; }
mjx-box { display: inline-block; }
mjx-block { display: block; }
mjx-itable { display: inline-table; }
mjx-row { display: table-row; }
mjx-row > * { display: table-cell; }
mjx-mtext { display: inline-block; }
mjx-mstyle { display: inline-block; }
mjx-merror { display: inline-block; color: red; background-color: yellow; }
mjx-mphantom { visibility: hidden; }
mjx-assistive-mml { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; padding: 1px 0px 0px !important; border: 0px !important; display: block !important; width: auto !important; overflow: hidden !important; }
mjx-assistive-mml[display="block"] { width: 100% !important; }
mjx-math { display: inline-block; text-align: left; line-height: 0; text-indent: 0px; font-style: normal; font-weight: normal; font-size: 100%; letter-spacing: normal; border-collapse: collapse; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; direction: ltr; padding: 1px 0px; }
mjx-container[jax="CHTML"][display="true"] { display: block; text-align: center; margin: 1em 0px; }
mjx-container[jax="CHTML"][display="true"][width="full"] { display: flex; }
mjx-container[jax="CHTML"][display="true"] mjx-math { padding: 0px; }
mjx-container[jax="CHTML"][justify="left"] { text-align: left; }
mjx-container[jax="CHTML"][justify="right"] { text-align: right; }
mjx-mi { display: inline-block; text-align: left; }
mjx-c { display: inline-block; }
mjx-utext { display: inline-block; padding: 0.75em 0px 0.2em; }
mjx-mo { display: inline-block; text-align: left; }
mjx-stretchy-h { display: inline-table; width: 100%; }
mjx-stretchy-h > * { display: table-cell; width: 0px; }
mjx-stretchy-h > * > mjx-c { display: inline-block; transform: scaleX(1); }
mjx-stretchy-h > * > mjx-c::before { display: inline-block; width: initial; }
mjx-stretchy-h > mjx-ext { overflow: clip visible; width: 100%; }
mjx-stretchy-h > mjx-ext > mjx-c::before { transform: scaleX(500); }
mjx-stretchy-h > mjx-ext > mjx-c { width: 0px; }
mjx-stretchy-h > mjx-beg > mjx-c { margin-right: -0.1em; }
mjx-stretchy-h > mjx-end > mjx-c { margin-left: -0.1em; }
mjx-stretchy-v { display: inline-block; }
mjx-stretchy-v > * { display: block; }
mjx-stretchy-v > mjx-beg { height: 0px; }
mjx-stretchy-v > mjx-end > mjx-c { display: block; }
mjx-stretchy-v > * > mjx-c { transform: scaleY(1); transform-origin: left center; overflow: hidden; }
mjx-stretchy-v > mjx-ext { display: block; height: 100%; box-sizing: border-box; border: 0px solid transparent; overflow: visible clip; }
mjx-stretchy-v > mjx-ext > mjx-c::before { width: initial; box-sizing: border-box; }
mjx-stretchy-v > mjx-ext > mjx-c { transform: scaleY(500) translateY(0.075em); overflow: visible; }
mjx-mark { display: inline-block; height: 0px; }
mjx-mfrac { display: inline-block; text-align: left; }
mjx-frac { display: inline-block; vertical-align: 0.17em; padding: 0px 0.22em; }
mjx-frac[type="d"] { vertical-align: 0.04em; }
mjx-frac[delims] { padding: 0px 0.1em; }
mjx-frac[atop] { padding: 0px 0.12em; }
mjx-frac[atop][delims] { padding: 0px; }
mjx-dtable { display: inline-table; width: 100%; }
mjx-dtable > * { font-size: 2000%; }
mjx-dbox { display: block; font-size: 5%; }
mjx-num { display: block; text-align: center; }
mjx-den { display: block; text-align: center; }
mjx-mfrac[bevelled] > mjx-num { display: inline-block; }
mjx-mfrac[bevelled] > mjx-den { display: inline-block; }
mjx-den[align="right"], mjx-num[align="right"] { text-align: right; }
mjx-den[align="left"], mjx-num[align="left"] { text-align: left; }
mjx-nstrut { display: inline-block; height: 0.054em; width: 0px; vertical-align: -0.054em; }
mjx-nstrut[type="d"] { height: 0.217em; vertical-align: -0.217em; }
mjx-dstrut { display: inline-block; height: 0.505em; width: 0px; }
mjx-dstrut[type="d"] { height: 0.726em; }
mjx-line { display: block; box-sizing: border-box; min-height: 1px; height: 0.06em; border-top: 0.06em solid; margin: 0.06em -0.1em; overflow: hidden; }
mjx-line[type="d"] { margin: 0.18em -0.1em; }
mjx-mrow { display: inline-block; text-align: left; }
mjx-mn { display: inline-block; text-align: left; }
mjx-msub { display: inline-block; text-align: left; }
mjx-texatom { display: inline-block; text-align: left; }
mjx-c::before { display: block; width: 0px; }
.MJX-TEX { font-family: MJXZERO, MJXTEX; }
.TEX-B { font-family: MJXZERO, MJXTEX-B; }
.TEX-I { font-family: MJXZERO, MJXTEX-I; }
.TEX-MI { font-family: MJXZERO, MJXTEX-MI; }
.TEX-BI { font-family: MJXZERO, MJXTEX-BI; }
.TEX-S1 { font-family: MJXZERO, MJXTEX-S1; }
.TEX-S2 { font-family: MJXZERO, MJXTEX-S2; }
.TEX-S3 { font-family: MJXZERO, MJXTEX-S3; }
.TEX-S4 { font-family: MJXZERO, MJXTEX-S4; }
.TEX-A { font-family: MJXZERO, MJXTEX-A; }
.TEX-C { font-family: MJXZERO, MJXTEX-C; }
.TEX-CB { font-family: MJXZERO, MJXTEX-CB; }
.TEX-FR { font-family: MJXZERO, MJXTEX-FR; }
.TEX-FRB { font-family: MJXZERO, MJXTEX-FRB; }
.TEX-SS { font-family: MJXZERO, MJXTEX-SS; }
.TEX-SSB { font-family: MJXZERO, MJXTEX-SSB; }
.TEX-SSI { font-family: MJXZERO, MJXTEX-SSI; }
.TEX-SC { font-family: MJXZERO, MJXTEX-SC; }
.TEX-T { font-family: MJXZERO, MJXTEX-T; }
.TEX-V { font-family: MJXZERO, MJXTEX-V; }
.TEX-VB { font-family: MJXZERO, MJXTEX-VB; }
mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c { font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A !important; }
@font-face { font-family: MJXZERO; src: url("lib/fonts/mathjax_zero.woff") format("woff"); }
@font-face { font-family: MJXTEX; src: url("lib/fonts/mathjax_main-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-B; src: url("lib/fonts/mathjax_main-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-I; src: url("lib/fonts/mathjax_math-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-MI; src: url("lib/fonts/mathjax_main-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-BI; src: url("lib/fonts/mathjax_math-bolditalic.woff") format("woff"); }
@font-face { font-family: MJXTEX-S1; src: url("lib/fonts/mathjax_size1-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S2; src: url("lib/fonts/mathjax_size2-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S3; src: url("lib/fonts/mathjax_size3-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S4; src: url("lib/fonts/mathjax_size4-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-A; src: url("lib/fonts/mathjax_ams-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-C; src: url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-CB; src: url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-FR; src: url("lib/fonts/mathjax_fraktur-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-FRB; src: url("lib/fonts/mathjax_fraktur-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SS; src: url("lib/fonts/mathjax_sansserif-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSB; src: url("lib/fonts/mathjax_sansserif-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSI; src: url("lib/fonts/mathjax_sansserif-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-SC; src: url("lib/fonts/mathjax_script-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-T; src: url("lib/fonts/mathjax_typewriter-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-V; src: url("lib/fonts/mathjax_vector-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-VB; src: url("lib/fonts/mathjax_vector-bold.woff") format("woff"); }
mjx-c.mjx-c1D445.TEX-I::before { padding: 0.683em 0.759em 0.021em 0px; content: "R"; }
mjx-c.mjx-c3D::before { padding: 0.583em 0.778em 0.082em 0px; content: "="; }
mjx-c.mjx-c28::before { padding: 0.75em 0.389em 0.25em 0px; content: "("; }
mjx-c.mjx-c1D44A.TEX-I::before { padding: 0.683em 1.048em 0.022em 0px; content: "W"; }
mjx-c.mjx-c2B::before { padding: 0.583em 0.778em 0.082em 0px; content: "+"; }
mjx-c.mjx-c1D446.TEX-I::before { padding: 0.705em 0.645em 0.022em 0px; content: "S"; }
mjx-c.mjx-c29::before { padding: 0.75em 0.389em 0.25em 0px; content: ")"; }
mjx-c.mjx-c31::before { padding: 0.666em 0.5em 0px 0px; content: "1"; }
mjx-c.mjx-c1D444.TEX-I::before { padding: 0.704em 0.791em 0.194em 0px; content: "Q"; }
mjx-c.mjx-c3E::before { padding: 0.54em 0.778em 0.04em 0px; content: ">"; }
mjx-c.mjx-c32::before { padding: 0.666em 0.5em 0px 0px; content: "2"; }
mjx-c.mjx-c2E::before { padding: 0.12em 0.278em 0px 0px; content: "."; }
mjx-c.mjx-c1D45B.TEX-I::before { padding: 0.442em 0.6em 0.011em 0px; content: "n"; }
mjx-c.mjx-c2212::before { padding: 0.583em 0.778em 0.082em 0px; content: "−"; }
mjx-c.mjx-c1D443.TEX-I::before { padding: 0.683em 0.751em 0px 0px; content: "P"; }
mjx-c.mjx-c33::before { padding: 0.665em 0.5em 0.022em 0px; content: "3"; }
</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="12. Memory Management"><ol start="12">
<li dir="auto">Memory Management</li>
</ol></h1><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner">第一遍重写中</div></div></div></div><div class="el-p"><p dir="auto">page size is a trade-off, and a larger page size can improve TLB hit rate. Bigger page size means fewer entries(same TLB now can cache more memory addresses)</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="第零课 南大ICS先导课" dir="auto" class="heading" id="第零课_南大ICS先导课"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第零课 南大ICS先导课</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">操作系统的诞生源于人们为了更有效的操作裸机（硬件）和对操作高层次抽象的追求。为了更好的理解本阶段的内容，内存管理阶段开始前，我们需要先了解一点组成原理和体系结构的内容。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="0.1 Organization of Memory" dir="auto" class="heading" id="0.1_Organization_of_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.1 Organization of Memory</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们知道，冯诺依曼计算机是以存储器为中心的。不管是我们的操作系统还是应用都要跑在主存上。那内存和外存的关系是怎么样的？在我们执行某些程序时，程序和数据会从外存批量传送到内存上，在由 CPU 从内存中取指执行。CPU 执行完毕后结果写回到内存中，必要时再由内存成批传送到外存长久保存。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240728054403.png" src="Pasted image 20240728054403.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240728054403.png" src="congzhi's-os-series/pics/pasted-image-20240728054403.png"></span></p></div><div class="el-p"><p dir="auto">下图展示了主存的结构，我们假设系统按字节连续编址，那么每个存储单元就是一个字节。不难理解，地址线的条数和主存的最大字节数关系就等于：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c79"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">地</mjx-utext></mjx-mtext><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">址</mjx-utext></mjx-mi><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">线</mjx-utext></mjx-mi><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">条</mjx-utext></mjx-mi><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">数</mjx-utext></mjx-mi></mjx-texatom></mjx-script></mjx-msup><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c79"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c73"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>虽然地址线条数能够产生主存的访存空间有这么大，但由于各种限制，内存可能做不到这么大（首个32位机 Intel 80386 早在1985年就出现了，但是4GB的内存条知道2000年代初期才开始普及）。为了能够利用到这么大的访存空间，计算机系统引入了内存层次结构，这是理解虚拟存储器的关键技术之一。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="0.2 Memory Hierarchy" dir="auto" class="heading" id="0.2_Memory_Hierarchy"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.2 Memory Hierarchy</h3><div class="heading-children"><div class="el-p"><p dir="auto">早期人工操作计算机的过程繁琐而复杂。为了简化操作并提高效率，操作系统诞生了，操作系统为人们提供一个”虚拟的机器“，人们再也不用和底层电路打交道。但对于程序员，使用这样的计算机仍不知足，因为内存的发展和 CPU 的相比太慢了。程序员想要的是一种和 CPU 速度相匹配，容量   ”无限大“的存储器。存储器层次结构的思想就是处于这种情况下诞生的。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729010510.png" src="Pasted image 20240729010510.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729010510.png" src="congzhi's-os-series/pics/pasted-image-20240729010510.png"></span></p></div><div class="el-p"><p dir="auto">在存储器的层次结构中，只有寄存器和cache能够与 CPU 的速度相匹配，但败在容量小。主存相比 CPU 要慢上10多倍，容量相比cache可以大很多。辅助存储器更是能够提供几近无限的存储大小，但对于 CPU 而言太慢（<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>个时钟周期）。而通过组合这些不同层次的存储器并采取合理的映射方式和读写策略，存储结构就可以为程序员提供非常好的使用体验。这种多层次存储器结合起的、存储容量又大访问速度又快的“存储器”就是我们说的<strong>虚拟存储器</strong>。</p></div><div class="el-p"><p dir="auto">这样层次化的存储器结构中，相邻两个层次之间是一定要进行数据传送的。传送的最小单位是一个<strong>定长块 (block)</strong>，互为副本。在主存和磁盘之间，这种定长块被称为<strong>页 (page)</strong>。在cache和主存之间，就叫<strong>定长块</strong>（32/64/128字节），cache中最小传送单位叫<strong>槽 (slot)</strong>，定长块大小和槽大小相同。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="0.3 Virtual Memory" dir="auto" class="heading" id="0.3_Virtual_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3 Virtual Memory</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.1 Memory Management in Early Time" dir="auto" class="heading" id="0.3.1_Memory_Management_in_Early_Time"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.1 Memory Management in Early Time</h4><div class="heading-children"><div class="el-p"><p dir="auto">早期的操作系统并不提供内存管理机制。主存空间是需要程序员自己管理的，如果主存空间很小，每次只能在内存中运行一个程序，要运行另一个程序时就需要将上一个进程从内存中取出来，换到外存中先放着，再将外存中需要运行的进程加载到内存中。</p></div><div class="el-p"><p dir="auto">在1961年，曼彻斯特的研究人员提出一种自动执行(overlay)的方式，其思想是将地址空间和主存容量的概念区分开。程序员在虚拟地址空间中编写程序，而程序在真正的内存中运行。由一个专门的机制实现地址空间和实际主存之间的映射。</p></div><div class="el-p"><p dir="auto">在当时的一种典型计算机中，指令中主存地址是16位，但是主存容量只有4KB。地址空间有 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup></mjx-math></mjx-container></span> 这么大，我们要如何自动执行程序？可以将地址空间划分成4K大小的一个个区间，让内存空间的地址以4096（4K）取模，将区间内每位地址都能对应上4K的主存范围间。程序员可以在 16KB（0-65535）的范围内写程序，不用关心主存空间的大小。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729033616.png" src="Pasted image 20240729033616.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729033616.png" src="congzhi's-os-series/pics/pasted-image-20240729033616.png"></span></p></div><div class="el-p"><p dir="auto">这种可寻址的地址就是一种<strong>虚拟内存</strong>，区间后来也叫做<strong>页(page)</strong>，把主存中存放页的区域叫做<strong>页框(frame)</strong>。最早的主存只有一个页框。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.2 Paging Management" dir="auto" class="heading" id="0.3.2_Paging_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.2 Paging Management</h4><div class="heading-children"><div class="el-p"><p dir="auto">现代的分页方式和早期分页方式十分类似。其基本思想都是把内存分成固定长度的存储块（也叫页框、实页、物理页），每个进程也划分成固定长的程序块（又称为页，虚页、逻辑页）。</p></div><div class="el-p"><p dir="auto">在执行程序时，我们就可以把程序块装到可用的存储块中，不需要用连续页框存放一个进程。为此，操作系统会为每个进程分配一个<strong>页表(page table)</strong>。通过页表就可以实现<strong>逻辑地址</strong>向<strong>物理地址</strong>的转换(Address Mapping)。我们下面举例说明一下地址转换：<br>
<span alt="Pasted image 20240729035023.png" src="Pasted image 20240729035023.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729035023.png" src="congzhi's-os-series/pics/pasted-image-20240729035023.png"></span><br>
假如某个进程有四个页的大小。因为虚拟内存中的页和主存中的页框是一样大的，因此我们只需要在页表中描述虚拟页和物理页框之间的映射关系就行了。而且由于程序的局部性，只将活跃的页面留在主存并不会太多影响运行速度。这种”按需调页(Demand Paging)“方式分配主存就是虚拟存储管理的概念。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.3 Virtual Memory and Virtual Space" dir="auto" class="heading" id="0.3.3_Virtual_Memory_and_Virtual_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.3 Virtual Memory and Virtual Space</h4><div class="heading-children"><div class="el-p"><p dir="auto">人们引入虚拟存储技术是为了解决一对矛盾：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">由于技术成本等原因限制的主存容量；</li>
<li data-line="1" dir="auto">程序要求的主存容量越来越大。</li>
</ol></div><div class="el-p"><p dir="auto">有了虚拟内存，上面的矛盾迎刃而解。程序员可以在比主存大得多的空间内编写程序。当程序执行起来时，只把当前需要的程序段和相应数据块调入主存，不用的地方先放在磁盘上。只当发生<strong>缺页(page fault)</strong> 时，操作系统才需要介入并进行主存和磁盘之间的信息交换。</p></div><div class="el-p"><p dir="auto">虚拟存储器的机制由硬件和操作系统共同协作实现，涉及到操作系统中许多概念，如进程、上下文切换、存储器分配、虚拟地址空间和缺页处理等等。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729180635.png" src="Pasted image 20240729180635.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729180635.png" src="congzhi's-os-series/pics/pasted-image-20240729180635.png"></span></p></div><div class="el-p"><p dir="auto">在之前的学习中，我们学习了<strong>虚拟地址空间</strong>的概念。在32位机器中，每个进程都可以分配高达4GB的虚拟地址空间，不同的操作系统对用户空间和内核空间的大小有不同的规定。我们也可能会有疑问：如果每个进程都在磁盘中占4GB的虚拟空间，磁盘岂不是只能存放很少数量的用户程序？实际上当然不是这样！虽然每个进程都会分配4GB的虚拟内存空间，实际上在磁盘上每个进程可能只会用到很小的磁盘存储（空洞页面不占用磁盘）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729183709.png" src="Pasted image 20240729183709.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729183709.png" src="congzhi's-os-series/pics/pasted-image-20240729183709.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.4 Paging Management Implementation" dir="auto" class="heading" id="0.3.4_Paging_Management_Implementation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.4 Paging Management Implementation</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们想要实现虚拟存储器的管理，我们还要考虑：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">页大小应该为多大？</li>
<li data-line="1" dir="auto">主存与辅存的空间如何分区管理？</li>
<li data-line="2" dir="auto">程序块/存储块之间如和映像？</li>
<li data-line="3" dir="auto">逻辑地址和物理地址如何转换，转换速度怎么提高？</li>
<li data-line="4" dir="auto">主存和辅存之间如何进行替换？</li>
<li data-line="5" dir="auto">页表如何实现，页表项要记录那些信息？</li>
<li data-line="6" dir="auto">如何加快访问页表的速度？</li>
<li data-line="7" dir="auto">要找的内容不在主存怎么办？</li>
<li data-line="8" dir="auto">如何保护进程各自的存储区不被其他进程访问？</li>
</ol></div><div class="el-p"><p dir="auto">虚拟存储器的管理分为了三种方式：<mark>分页式</mark>、<mark>分段式</mark>、<mark>段页式</mark>。</p></div><div class="el-p"><p dir="auto">假定一个页有4KB，在32位机器上，页表的项数就会有：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mfrac><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.289em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mi class="mjx-n"><mjx-utext variant="normal" style="font-family: MJXZERO, serif;">项</mjx-utext></mjx-mi></mjx-math></mjx-container></span>页表有这么多项，假如一个页表项占4KB，那么页表会有4MB的大小，比页还大。因此页表也要分页管理。页表存放在虚拟地址空间中的内核区。每个进程有一个页表，其中有<mark>装入位、修改（Dirt）位、替换控制位、访问权限位、禁止缓存位、实页号</mark>。各个进程理论上有相同的虚拟空间，但是实际大小看具体的实现方式，如”空洞“页面如何处理等。</p></div><div class="el-p"><p dir="auto">我们将页分成了三类：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>未分配页</strong>：进程的虚拟地址空间中“空洞”对应的页（如VP0、VP4） </li>
<li data-line="1" dir="auto"><strong>已分配的缓存页</strong>：有内容对应的已装入主存的页（如VP1、VP2、VP5等） </li>
<li data-line="2" dir="auto"><strong>已分配的未缓存页</strong>：有内容对应但未装入主存的页（如VP3、VP6）</li>
</ol></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729201529.png" src="Pasted image 20240729201529.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729201529.png" src="congzhi's-os-series/pics/pasted-image-20240729201529.png"></span><br>
可执行文件的存储器映像如下图所示。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240729201908.png" src="Pasted image 20240729201908.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729201908.png" src="congzhi's-os-series/pics/pasted-image-20240729201908.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.5 Segmentation" dir="auto" class="heading" id="0.3.5_Segmentation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.5 Segmentation</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们已经了解了分页式虚拟存储器是怎么工作的。将虚拟存储空间划分成大小相等的一个个页，然后将主存空间划分成和页大小相同的一个个页框。然后用页表中的页表项对应每个页到页框的关系。但分页的方式会有一些问题，比如一个数据跨在两个不同的页中。</p></div><div class="el-p"><p dir="auto">将虚拟地址空间分段很好的解决了这种问题。通过程序数据的需求分配不同的段，按照程序逻辑结构将虚拟地址空间划分成多个相对独立的部分（代码段、只读数据段、课读写数据段等等）。而且相比分页，分段方式能更好地进行存储保护（数据和代码在同一个页中，地址越界、保护违例）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730015834.png" src="Pasted image 20240730015834.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730015834.png" src="congzhi's-os-series/pics/pasted-image-20240730015834.png"></span><br>
编译器优化和操作系统调度管理。分段系统将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，并附以“段长”项。段表由段表项组成，段表本身也是主存中的一个可再定位段。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="0.3.6 Segmented Paging Management" dir="auto" class="heading" id="0.3.6_Segmented_Paging_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0.3.6 Segmented Paging Management</h4><div class="heading-children"><div class="el-p"><p dir="auto">分段式的虚拟内存管理确确实实解决了分页式虚拟内存管理的痛点，但是它也走向了另一个极端。占空间多，段内存换进换出很难管理。因此我们折中，段页式存储器完美的迎合了我们的需求。</p></div><div class="el-p"><p dir="auto">程序的虚拟地址空间按模块先分段、段内再分页，但进入主存仍以页为基本单位。这一，逻辑地址就由<mark>段地址+段内页地址+页内偏移量</mark>三个字段构成。用段表和页表（每段一个）进行两级定位管理。根据段地址到段表中查阅与该段相应的页表首地址，转向页表，然后根据页地址从页表中查到该页在主存中的页框地址，由此再访问到页内某数据。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第一课 Main Memory Management" dir="auto" class="heading" id="第一课_Main_Memory_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课 Main Memory Management</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在第零课的学习后，我们应该对虚拟内存有了大概的理解。在操作系统中，内存管理涉及的是“内存-外存”这个层次的管理。外存（如磁盘）作为一个大仓库，为用户进程提供逻辑上无限大的编程空间。由于磁盘是一种外部设备，我们将这种磁盘提供的后备资源称为<strong>虚拟内存</strong>。因为这种逻辑上的关系，也被称为<strong>逻辑内存</strong>。在本阶段，我们需要额外关注以下的话题：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">内存的物理地址和进程的逻辑地址</li>
<li data-line="1" dir="auto">地址映射和内存保护</li>
<li data-line="2" dir="auto">内存分配和回收</li>
<li data-line="3" dir="auto">分页和分段</li>
<li data-line="4" dir="auto">虚拟内存</li>
</ul></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Physical Address and Logical Address" dir="auto" class="heading" id="1.1_Physical_Address_and_Logical_Address"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Physical Address and Logical Address</h3><div class="heading-children"><div class="el-p"><p dir="auto">当我们使用内存时，感受到的是一段连续的内存，这多亏了操作系统的抽象。而我们实际上使用的内存在物理上的地址可能并不连续。我们下面先来了解什么是物理内存地址，它是怎么得到的？</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 Main Memory" dir="auto" class="heading" id="1.1.1_Main_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 Main Memory</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们直接访问的数据无一例外都存放在主存中。由于主存采用随机存取方式，因此也称为随机存取存储器（Random Access Memory, RAM）。它是计算机系统中的关键硬件组件，用于临时存储和快速访问数据和指令。</p></div><div class="el-p"><p dir="auto">下面是RAM的一个组织图，每个bit数据存放在内存中一个个cell中。计算机通过字线和位线将这些cell编址成一个位平面(Bit plane)。由于大多机器按字节编址，所以一般的DRAM bank需要8个这样的位平面摞在一起。下图的例子并不确切，但对于理解地址译码来说是一个很好的例子。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730033638.png" src="Pasted image 20240730033638.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730033638.png" src="congzhi's-os-series/pics/pasted-image-20240730033638.png"></span></p></div><div class="el-p"><p dir="auto">物理地址和地址译码的关系很紧密。假设上图我们有8个位平面，我们可以通过物理地址来得到我们想要的byte。其中，我们就需要一个译码器将物理地址翻译成某个确切的byte信息。</p></div><div class="el-p"><p dir="auto">地址译码器有n个地址输入线和 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math></mjx-container></span> 个输出线。对于每一种输入组合，只有一条输出线会被选中（低电平），其他线保持高电平。因为32位机器上地址位数有32位（现代计算机通常有行缓存，行选中和列选中是分批次进行的），所以能够产生4GB的物理地址。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 Physical Address" dir="auto" class="heading" id="1.1.2_Physical_Address"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 Physical Address</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>物理地址</strong>是计算机内存中的实际地址。每个内存单元都有唯一的物理地址，通过这个地址，CPU可以直接访问内存中的数据。物理地址是由硬件直接管理的，因为它在硬件层面上是唯一且固定的，因此也被称为<strong>绝对地址(absolute address)</strong>。</p></div><div class="el-p"><p dir="auto">物理地址一般从0开始，而且一般以字节作为最小单位。至于物理地址的长度多大要取决于CPU的架构。32位架构就能访问4GB大小的物理内存。64位架构能访问的大小则是一个天文数字，有生之年也不知道能不能见到这么大的存储器。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.3 Logical Address" dir="auto" class="heading" id="1.1.3_Logical_Address"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 Logical Address</h4><div class="heading-children"><div class="el-p"><p dir="auto">在第零课的先导课中，我们提到了段页式虚拟内存管理。逻辑地址就等于段基址+偏移量（相对地址）实现的。这里的相对地址就是相对段基址而言的。将地址从一种形式（如逻辑地址）转换成另一种形式（如物理地址）的过程。在现代计算机中，一般使用<strong>MMU</strong>来完成地址转换的工作。</p></div><div class="el-p"><p dir="auto">在用户眼中连续的地址就是<strong>逻辑地址</strong>。逻辑地址是程序运行时CPU生成的，操作系统分配给进程使用的地址。每个进程都有各自的逻辑地址，通常从0开始。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.3.1 Relative Address" dir="auto" class="heading" id="1.1.3.1_Relative_Address"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3.1 Relative Address</h5><div class="heading-children"><div class="el-p"><p dir="auto">物理地址 = 绝对地址，但逻辑地址 != 相对地址。相对地址是相对于某个基准地址来说的。由编译器在编译时生成，通常用于指令中的跳转、调用等。也就是偏移量(offset)。</p></div></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 Address Conversion" dir="auto" class="heading" id="第二课_Address_Conversion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 Address Conversion</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 How Program is Loaded" dir="auto" class="heading" id="2.1_How_Program_is_Loaded"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 How Program is Loaded</h3><div class="heading-children"><div class="el-p"><p dir="auto">在我们用c程序编写了一个hello.c文件后，计算机是不能直接执行这个文件的。原因是计算机只能识别二进制的机器级代码，hello.c是源程序的文本文件。要让计算机识别并执行我们所编写的源程序，还需要做以下步骤：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>预处理(cpp)</strong><br>
预处理阶段，程序会处理以 '<code>#</code>' 开头的预编译指令并删除所有的代码注释。经过预编译的处理，我们得到预处理文件（hello.i），这时的文件仍然是一个可读的文本文件，不包含任何宏定义。</li>
<li data-line="2" dir="auto"><strong>编译(cc1)</strong><br>
编译过程就是将预处理后得到的预处理文件（如hello.i）进行 词法分析、语法分析、语义分析、优化后，生成汇编代码文件。经过编译后，得到的汇编代码文件（如hello.s）还是可读的文本文件，CPU无法理解和执行它。</li>
<li data-line="4" dir="auto"><strong>汇编(as)</strong><br>
程序经过编译后生成汇编语言源程序，在汇编阶段，汇编程序（汇编器）会用来将汇编语言源程序转换成机器指令序列（机器语言程序）。汇编指令和机器指令一一对应，前者是后者的符号表示，它们都属于机器级指令，所构成的程序称为机器级代码。汇编结果是一个可重定位目标文件（如，hello.o）。</li>
<li data-line="6" dir="auto"><strong>链接(ld)</strong><br>
链接过程将多个可重定位目标文件合并以生成可执行目标文件。<br>
<span alt="Pasted image 20240730092536.png" src="Pasted image 20240730092536.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730092536.png" src="congzhi's-os-series/pics/pasted-image-20240730092536.png"></span></li>
<li data-line="9" dir="auto"><strong>装入内存</strong><br>
<span alt="Pasted image 20240729201908.png" src="Pasted image 20240729201908.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240729201908.png" src="congzhi's-os-series/pics/pasted-image-20240729201908.png"></span></li>
</ol></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.1 Assembly Code Example" dir="auto" class="heading" id="2.1.1_Assembly_Code_Example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1 Assembly Code Example</h4><div class="heading-children"><div class="el-p"><p dir="auto">因为汇编代码和二进制机器代码都是机器级代码，因此我们能很明白地在汇编代码中，窥见一些程序加载前的要做的事。代码中<mark>CALL</mark>和<mark>PRINT</mark>两个标号代表了那一行指令的逻辑地址，这些标号会在链接过程中经过<mark>符号解析</mark>和<mark>重定位</mark>转换成相应的逻辑地址。而这些<mark>逻辑地址会在<em>不同时机</em> 中将逻辑地址转换成不同的物理地址。</mark></p></div><div class="el-pre"><pre class="language-assembly" tabindex="0"><code data-line="0" class="language-assembly is-loaded">Logical address          Assembly code
0000               START: MOV AX, 1234H
0003                      ADD AX, 5678H
0006                      JMP NEXT
0009                HERE: SUB AX, 1234H
000C                NEXT: MOV BX, AX
000F                      CALL PRINT
0012                      HLT
0013               PRINT: PUSH AX
0014                      POP AX
0015                      RET
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.2 When does Address Conversion Happen?" dir="auto" class="heading" id="2.2_When_does_Address_Conversion_Happen?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 When does Address Conversion Happen?</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.1 Link-Time Conversion" dir="auto" class="heading" id="2.2.1_Link-Time_Conversion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1 Link-Time Conversion</h4><div class="heading-children"><div class="el-p"><p dir="auto">源代码被编译成目标文件，生成的目标文件包含逻辑地址，逻辑地址从<code>0x000</code>开始。在链接阶段，决定程序将被加载到物理内存中的确切位置。之后链接器会将目标文件中的所有逻辑地址转换位相对于加载地址的物理地址。例如，假设决定程序将加载到物理位置<code>0x300</code>，随后，<code>0x300</code>就变成一个基地址，虚拟地址<code>0x003</code>就会被转换为物理地址<code>0x303</code>。</p></div><div class="el-p"><p dir="auto">这种链接时地址转换的好处就是简单，而且系统开销低。但是缺点也是显而易见的，那就是灵活性差，不适合多任务的环境。只用场景只有哪些简单的单任务系统。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.2 Load-Time Conversion" dir="auto" class="heading" id="2.2.2_Load-Time_Conversion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.2 Load-Time Conversion</h4><div class="heading-children"><div class="el-p"><p dir="auto">链接时转换的方案是在可执行文件加载进内存前就已经指定好在物理内存的哪个位置运行了。<mark>装载时转换</mark>指在可执行文件被加载到内存时，将程序中的逻辑地址转换成物理地址的过程。这种方法在程序加载时进程一次性转换，并将地址固定下来，也称为<mark>静态重定位</mark>。适用于内核模块和动态链接库(DLL)等场景。</p></div><div class="el-p"><p dir="auto">相比链接时转换，加载时转换的方式更为灵活，因为程序的逻辑地址在编译和链接时不需要是固定的，可以在加载时根据内存的实际情况进行调整。但是这种方式不可避免的导致加载时间增加，而且加载后不可在内存中移动。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.3 Run-time Conversion" dir="auto" class="heading" id="2.2.3_Run-time_Conversion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.3 Run-time Conversion</h4><div class="heading-children"><div class="el-p"><p dir="auto">加载进内存程序中的指令地址仍然保存逻辑地址，在执行过程中，将逻辑地址动态转换成物理地址。这个过程就是<mark>运行时地址转换</mark>，也叫<mark>动态重定位</mark>。动态重定位通常通过硬件和操作系统的支持，比如使用 MMU 实现逻辑地址到物理地址的映射。运行时转换是现代系统中广泛采用的方法。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>优点</strong>：高灵活性、内存保护、高效内存利用。</li>
<li data-line="1" dir="auto"><strong>缺点</strong>：性能开销大、复杂性高、对硬件要求。</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.4 Logic Address to Virtual Address" dir="auto" class="heading" id="2.2.4_Logic_Address_to_Virtual_Address"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.4 Logic Address to Virtual Address</h4><div class="heading-children"><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>编译阶段</strong>：源代码转成目标代码，每个目标文件中的地址称为<mark>逻辑地址</mark>。</li>
<li data-line="1" dir="auto"><strong>链接阶段</strong>：将多个目标文件链接合成可执行文件，该阶段会分配每个段的<mark>虚拟地址</mark>，在根据目标文件的逻辑地址和加载段生成全局虚拟地址。此时<mark>虚拟地址空间</mark>就构建完毕，构建信息就是ELF的头部信息。</li>
<li data-line="2" dir="auto"><strong>加载阶段</strong>：OS 会先读取ELF头部信息，根据虚拟地址空间的信息加载必要的段到物理内存中，其他部分留在虚拟内存。</li>
<li data-line="3" dir="auto"><strong>运行阶段</strong>：当某个要访问的页不再内存中，则请求操作系统从虚拟内存将其调入物理内存。如果物理内存不足就进行页面置换。</li>
</ul></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Base and Bound" dir="auto" class="heading" id="第三课_Base_and_Bound"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Base and Bound</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 Memory Management Unit" dir="auto" class="heading" id="3.1_Memory_Management_Unit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 Memory Management Unit</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>内存管理单元(MMU)</strong>，也叫<strong>页内存管理单元(PMMU)</strong>，是一种支持虚拟内存和分页的硬件设备或电路，负责将虚拟地址转换成物理地址。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">在现代操作系统中，进程的逻辑地址空间大小理论可达计算机架构的最大值，而物理内存通常比理论最大值小。</li>
<li data-line="1" dir="auto">一个进程通常不会用完全部的逻辑地址空间，也很少会在在某一时刻使用大量内存。因此，可以同时在物理内存中容纳多个进程。</li>
<li data-line="2" dir="auto">MMU的任务就是把每个进程的逻辑地址映射到物理内存的不同区域，同时也要<mark>保证进程之间的隔离性</mark>（保护地址不会越界或溢出）。</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730215541.jpg" src="Pasted image 20240730215541.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730215541.jpg" src="congzhi's-os-series/pics/pasted-image-20240730215541.jpg"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.1 Base and Bound" dir="auto" class="heading" id="3.1.1_Base_and_Bound"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 Base and Bound</h4><div class="heading-children"><div class="el-p"><p dir="auto">基址和限长是虚拟内存的一种简单形式，通过一组或少量处理器寄存器（基址寄存器和限长寄存器）来控制对计算机内存的访问。工作原理如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>分配内存区域</strong><br>
每个用户进程被分配一个连续的主存区域。操作系统将该区域的物理首地址加载到<mark>基址寄存器（重定位寄存器）</mark>中，将其大小加载到<mark>限长寄存器</mark>中。</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730220832.jpg" src="Pasted image 20240730220832.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730220832.jpg" src="congzhi's-os-series/pics/pasted-image-20240730220832.jpg"></span></p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p><strong>物理地址转换</strong><br>
我们已经了解了基址寄存器和编址寄存器的作用，我们通过下图直观学习以下物理地址是这么转换的。当进程重定位到 14000 地址的基址时，这个基址会存放在基址寄存器中，和CPU送来的所及地址相加就可以得出物理地址了。不过要注意，在这里还要判断地址是否越界的问题，我们马上介绍。<br>
<span alt="Pasted image 20240730223332.jpg" src="Pasted image 20240730223332.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730223332.jpg" src="congzhi's-os-series/pics/pasted-image-20240730223332.jpg"></span></p>
</li>
<li data-line="4" dir="auto">
<p><strong>内存保护</strong><br>
通过进程P中基址和限长寄存器中的值，我们就可以轻松地判断是否存在非法的址错误。在下图中，硬件（MMU）会检查每个CPU送来的地址，检查是否越界等等。一旦发现送来的地址值小于基地址，或者大于限长寄存器（base+limit）中的值，MMU就会通过一条trap指令叫出操作系统处理这种 addressing error。</p>
</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730220817.jpg" src="Pasted image 20240730220817.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730220817.jpg" src="congzhi's-os-series/pics/pasted-image-20240730220817.jpg"></span></p></div><div class="el-p"><p dir="auto">结合<strong>物理地址转换</strong>和<strong>内存保护</strong>，我们就可以简单的描述出MMU地址转换和内存保护方法的步骤了。因为CPU送来的是逻辑地址，因此我们在这里省略和基地址的比较过程。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730221149.jpg" src="Pasted image 20240730221149.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730221149.jpg" src="congzhi's-os-series/pics/pasted-image-20240730221149.jpg"></span></p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第四课 Contiguous Memory Allocation" dir="auto" class="heading" id="第四课_Contiguous_Memory_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第四课 Contiguous Memory Allocation</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在计算机的内存管理中，<strong>连续分配管理方式</strong>是一种基础的分配方法。它的主要特点是将进程装入内存时，要求进程占据一块连续的内存空间。这种方法可以有效的管理和分配内存资源，但是也会有一些限制。</p></div><div class="el-p"><p dir="auto">连续分配管理方式可以进一步细分为固定分区和可变分区两种模式。这两种模式各有优缺点，适用于不同的应用场景。后面的分段、分页就是对这两种模式的延伸。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.1 Fixed Size Partitioning" dir="auto" class="heading" id="4.1_Fixed_Size_Partitioning"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 Fixed Size Partitioning</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>固定分区</strong>管理方式是一种将内存划分为若干固定大小分区的方法（分区大小不一定相同）。由于内存分区大小固定，所以每个分区在系统启动时就已经确定，不能动态调整。此外，在固定分区中，每个分区只能容纳一个进程，如果一个进程之战1MB，而分区大小为5MB，这就会造成4MB的浪费，即内部碎片(Internal fragmentation)。当我们分配分区时，尽量使得内部碎片尽可能的小。</p></div><div class="el-p"><p dir="auto">当系统有多个进程需要运行时，会将每个进程分配到一个合适大小的分区中。如果所有分区都被占用，新到的进程将无法进入内存，必须等待。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240801010828.png" src="Pasted image 20240801010828.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240801010828.png" src="congzhi's-os-series/pics/pasted-image-20240801010828.png"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.1 Memory Allocation and Deallocation" dir="auto" class="heading" id="4.1.1_Memory_Allocation_and_Deallocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1 Memory Allocation and Deallocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">在固定分区中，为了实现内存的分配和回收，系统需要维护一张表用于跟踪分区当前的状态。这张表记录着各个分区的编号、起始地址、大小和占用情况。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.1.1 Memory Allocation" dir="auto" class="heading" id="4.1.1.1_Memory_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1.1 Memory Allocation</h5><div class="heading-children"><div class="el-p"><p dir="auto">在固定分区下，当进程需要申请内存空间时，分配器会根据进程的大小，在表中寻找一个合适的分区进行分配。之后，将该分区的起始地址填入 Base register 中，将分区大小或进程大小填入 Limit register 中，并标注占用该分区的进程 ID 号。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.1.2 Memory Deallocation" dir="auto" class="heading" id="4.1.1.2_Memory_Deallocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1.2 Memory Deallocation</h5><div class="heading-children"><div class="el-p"><p dir="auto">当进程结束后，清除该分区的占用情况使分区重新可用。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.2 Address Conversion and Protection" dir="auto" class="heading" id="4.1.2_Address_Conversion_and_Protection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.2 Address Conversion and Protection</h4><div class="heading-children"><div class="el-p"><p dir="auto">在固定分区中的地址转换和保护中有两种不同的声音：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">限长寄存器中应当存放的是分区大小，也就是物理地址在内部碎片中也是允许的；</li>
<li data-line="1" dir="auto">限长寄存器存放的是进程大小，限制进程在分区内部碎片的访问权限。</li>
</ol></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.3 Trade-Offs" dir="auto" class="heading" id="4.1.3_Trade-Offs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.3 Trade-Offs</h4><div class="heading-children"><div class="el-p"><p dir="auto">权衡利弊，固定分区的好处就是简单易实现。但是其不灵活的缺点难免导致产生大量的内存内部碎片，不可避免的造成资源的浪费。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.2 Variable Size Partitioning" dir="auto" class="heading" id="4.2_Variable_Size_Partitioning"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 Variable Size Partitioning</h3><div class="heading-children"><div class="el-p"><p dir="auto">与固定分区的管理方式不同，<strong>可变分区</strong>的管理方式并不与先划分固定大小的分区，而根据进程的实际需要动态地分配内存。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.1 Memory Allocation and Deallocation" dir="auto" class="heading" id="4.2.1_Memory_Allocation_and_Deallocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 Memory Allocation and Deallocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">由于可变分区的内存管理方式不再固定地划分分区。为了确保内存分配高效性，系统需要维护两张表：<mark>空闲分区表</mark>和<mark>已用分区表</mark>。空闲的分区也叫做<mark>孔(holes)</mark>，初始情况下，整个内存区域就是一个空闲分区。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240730220934.jpg" src="Pasted image 20240730220934.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240730220934.jpg" src="congzhi's-os-series/pics/pasted-image-20240730220934.jpg"></span></p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.1.1 Allocation" dir="auto" class="heading" id="4.2.1.1_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1.1 Allocation</h5><div class="heading-children"><div class="el-p"><p dir="auto">根据进程大小在空闲分区表中寻找一个合适的分区进行分配，更新空闲分区表和已用分区表，并初始化进程的 Base register 和 Limit register。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.1.2 Deallocation" dir="auto" class="heading" id="4.2.1.2_Deallocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1.2 Deallocation</h5><div class="heading-children"><div class="el-p"><p dir="auto">在释放内存时，更新已用分区表和空闲分区表（如果可以，合并多个连着的空闲分区，这被称为 coalescence）。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.2 Memory Conversion and Protection" dir="auto" class="heading" id="4.2.2_Memory_Conversion_and_Protection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 Memory Conversion and Protection</h4><div class="heading-children"><div class="el-p"><p dir="auto">没什么好说的，参见上节课内存保护的部分。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.3 Trade-Offs" dir="auto" class="heading" id="4.2.3_Trade-Offs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 Trade-Offs</h4><div class="heading-children"><div class="el-p"><p dir="auto">相比固定分区，可变分区为我们带来了一定的灵活性。由于分区大小就是进程的大小，所以可变分区避免了内部碎片的产生。然而，这种分区为我们带来了外部碎片，也就是我们说的holes。如果孔的分配不合理，就可能出现许多无法利用的孔。</p></div><div class="el-p"><p dir="auto">为了减少外部碎片的占比，在可变分区中，我们有许多分配算法。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.3 Allocation Algorithms" dir="auto" class="heading" id="4.3_Allocation_Algorithms"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 Allocation Algorithms</h3><div class="heading-children"><div class="el-p"><p dir="auto">由于可变分区的分区方式是动态可调整的，因此如何分配“孔”就决定了内存的利用率。常见的分区策略有——<strong>First fit</strong>、<strong>Next fit</strong>、<strong>Best fit</strong>、<strong>Worst fit</strong>、<strong>Quick fit</strong>。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.3.1 First Fit" dir="auto" class="heading" id="4.2.3.1_First_Fit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3.1 First Fit</h5><div class="heading-children"><div class="el-p"><p dir="auto">首次适应从头开始搜索空闲分区表，检查每个块。一旦找到大小合适的空闲分区块，将其分配给进程。除了这种分配方式可能产生过多的内存碎片外，首次适应有许多优点：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">速度快 O(n)，找到第一个合适的就能分配了。</li>
<li data-line="1" dir="auto">易于实现。</li>
</ol></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.3.2 Next Fit" dir="auto" class="heading" id="4.2.3.2_Next_Fit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3.2 Next Fit</h5><div class="heading-children"><div class="el-p"><p dir="auto">下次适应是从上次分配结束的位置开始，继续向前查找，找到第一个足够大的空闲块进行分配。如果到达内存末尾，则从头开始继续查找。下次适应具有与首次适应（First Fit）相同的优点：速度快O(n)和易于实现。</p></div><div class="el-p"><p dir="auto">在某些情况下，下次适应可能更均匀地利用内存，因为它不会总是从内存的起始位置开始查找。然而，它也可能会导致更多的内存碎片，因为它不会总是选择最靠前的空闲块。此外，下次适应可能在某些情况下更快，因为它避免了每次分配都从头开始查找。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.3.3 Best Fit" dir="auto" class="heading" id="4.2.3.3_Best_Fit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3.3 Best Fit</h5><div class="heading-children"><div class="el-p"><p dir="auto">相比于前两种傻瓜式的比较适应算法，最佳适应会搜索整个空闲分区表，找到最接近进程所需大小的空闲分区块，然后将其分配给进程。相比较于前两者，最佳适应的<strong>外部碎片产生最小</strong>。但是有些实现方式可能使得搜索时间过长。</p></div><div class="el-p"><p dir="auto">然而，如果使用 AVL 树或红黑树，最佳适应算法的速度可能会优于首次适应算法：<strong>Θ(In(n))</strong>。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.3.4 Worst Fit" dir="auto" class="heading" id="4.2.3.4_Worst_Fit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3.4 Worst Fit</h5><div class="heading-children"><div class="el-p"><p dir="auto">最差适应算法反其道而行之，它通过搜索整个空闲分区表，找到最大的空闲分区表，将其分配给进程。为什么是最大的内存块？因为大块内存分配后，留下的空闲区域依然很大，便于后续的分配。这就是最差适应的中心思想，但是也可能造成更大的内存浪费。</p></div><div class="el-p"><p dir="auto">可以使用 max heap、 binomial heap 或 Fibonacci heap 来实现最差适应算法。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.3.5 Quick Fit" dir="auto" class="heading" id="4.2.3.5_Quick_Fit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3.5 Quick Fit</h5><div class="heading-children"><div class="el-p"><p dir="auto">快速适应是一种优化内存分配速度的算法。它通过维护多个空闲块列表，每个列表对应不同大小的内存块。当需要分配内存时，Quick Fit 会直接从对应大小的空闲块列表中查找和分配内存。这种方法可以显著减少内存分配和释放的时间开销，但可能会导致内存碎片问题。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.4 可变分区和空间利用技术" dir="auto" class="heading" id="4.2.4_可变分区和空间利用技术"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.4 可变分区和空间利用技术</h4><div class="heading-children"><div class="el-ul"><ul>
<li data-line="0" dir="auto">可变分区方式的内存利用率较高，可以更灵活地适应不同大小进程的需求。</li>
<li data-line="1" dir="auto">存在外部碎片（孔）和分配开销。</li>
<li data-line="2" dir="auto"><strong>合并技术 (coalescence)</strong>：内存管理器会将相邻的空闲块合并成一个更大的空闲块。</li>
<li data-line="3" dir="auto"><strong>紧凑技术 (compaction)</strong>：将进程在内存中进行移动，消除不可用的孔。但是这种移动内存块的方式会增加系统开销。</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.3 Binary Buddy System" dir="auto" class="heading" id="4.3_Binary_Buddy_System"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 Binary Buddy System</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第五课 Segmentation" dir="auto" class="heading" id="第五课_Segmentation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第五课 Segmentation</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在上节课的连分配管理方式中，我们看到无论是固定分区还是可变分区，都要求进程在内存中是完整的。但无论是哪种连续分配方式，都不可避免的会有碎片产生。因此，在本节课及往后，我们开始讨论非连续性存储管理方式，为找到一种更好的方式管理我们的内存。</p></div><div class="el-p"><p dir="auto">实际上，我们在阶段6第三课中已经对“段”这个概念有所耳闻了。我们知道虚拟内存中不同的段承担的职责是不一样的，我们有代码段、全局变量段、stack、heap、C标准库等各种段。尽管段内地址连续，但不同的段在内存中可以离散排布，我们依据不同的段对内存进行管理。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.1 Allocation and Deallocation" dir="auto" class="heading" id="5.1_Allocation_and_Deallocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 Allocation and Deallocation</h3><div class="heading-children"><div class="el-p"><p dir="auto">段式存储管理方式中，逻辑空间被分为了若干个段，每个段定义了一组完整逻辑意义的信息（代码段、数据段、堆栈段）。段式存储管理的优点是不同的段在加载进内存时不要求是连续的，但是某一个段内的内存需要是连续的。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>分段</strong>：每个逻辑段都有一个段号。</li>
<li data-line="1" dir="auto"><strong>段内连续</strong>：段内的逻辑地址总是从 0 开始。</li>
<li data-line="2" dir="auto"><strong>段的大小</strong>：不同段的大小不完全相同。</li>
<li data-line="3" dir="auto"><mark><strong>段表</strong></mark>：段表用来记录每个逻辑<mark>段的编号</mark>。<mark>物理起始大小</mark>、<mark>段大小</mark>及<mark>访问权限</mark>等。<br>
下面举例用段表只展示出内存保护所需的段基址和段长部分。<br>
<span alt="Pasted image 20240801075550.png" src="Pasted image 20240801075550.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240801075550.png" src="congzhi's-os-series/pics/pasted-image-20240801075550.png"></span></li>
<li data-line="6" dir="auto"><strong>分配方式</strong>：读取ELF头部，识别出需要加载的各个段，为每个段分配内存（查找、更新空闲分区表），最后更新段表。</li>
<li data-line="7" dir="auto"><strong>回收过程</strong>：更新段表-&gt;释放内存（更新空闲表）。</li>
</ul></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.2 Conversion and Protection" dir="auto" class="heading" id="5.2_Conversion_and_Protection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 Conversion and Protection</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="5.2.1 Conversion" dir="auto" class="heading" id="5.2.1_Conversion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2.1 Conversion</h4><div class="heading-children"><div class="el-p"><p dir="auto">逻辑地址由两部分构成：（1）<strong>段号</strong>，（2）<strong>段内偏移</strong>。段号决定虚拟内存中可划分多少个段，段内位移决定最小的段大小是多大。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.2.2 Protection" dir="auto" class="heading" id="5.2.2_Protection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2.2 Protection</h4><div class="heading-children"><div class="el-ul"><ul>
<li data-line="0" dir="auto">防止越界</li>
<li data-line="1" dir="auto">访问权限（CPL 和 DPL，还有段属性是只读、只写还是怎样）<br>
<span alt="Pasted image 20240801075704.png" src="Pasted image 20240801075704.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240801075704.png" src="congzhi's-os-series/pics/pasted-image-20240801075704.png"></span></li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.3 Trade-Offs" dir="auto" class="heading" id="5.3_Trade-Offs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.3 Trade-Offs</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第六课 Paging" dir="auto" class="heading" id="第六课_Paging"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第六课 Paging</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">我们在 ICS 先导课中已经学过页式存储的基本原理，我们将进程逻辑地址空间划分成大小相同的块，我们称为<strong>页(page)</strong>；再把物理内存划分成若干相同大小的块，称为<strong>页框(page frame)</strong>。一个页框放一个页。当我们分配内存时，我们可以将进程的页面离散地存放到也框里面，通过<strong>页表</strong>保存页和页框的映射关系（虚拟地址到物理地址之间的映射）。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.1 Page Table" dir="auto" class="heading" id="6.1_Page_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1 Page Table</h3><div class="heading-children"><div class="el-p"><p dir="auto">在32位机器上，逻辑地址占32bits，其中有页内位移12bits和页面号20bits。我们知道，页和页框中的页内位移是一一对应的。其中，逻辑地址通过页表映射出相对应的物理地址。因此要实现页式存储管理，页表中的页表项不需要记录页内位移的任何信息。而且虚拟地址空间是连续的，我们只需要在页表项中记录页框号和一些标志位即可。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.1.1 Page Table Entry" dir="auto" class="heading" id="6.1.1_Page_Table_Entry"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1.1 Page Table Entry</h4><div class="heading-children"><div class="el-p"><p dir="auto">32位机器上的页表项占四个字节，这里提供下面的图简单了解相关位的含义。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240805013618.png" src="Pasted image 20240805013618.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240805013618.png" src="congzhi's-os-series/pics/pasted-image-20240805013618.png"></span></p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.2 页式存储管理方式的开销" dir="auto" class="heading" id="6.2_页式存储管理方式的开销"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2 页式存储管理方式的开销</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.1 页表存储开销" dir="auto" class="heading" id="6.2.1_页表存储开销"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.1 页表存储开销</h4><div class="heading-children"><div class="el-p"><p dir="auto">32位机器上，一个进程的虚拟地址空间理论上是 4GB 空间，每个页 4KB 情况下可以划分出来 1M 个页出来。我们知道每个页表项需要 4B 空间，那么维护这一个进程的页表就需要<strong>占用 4MB 的内存空间（单级页表静态分配需要1000个连续页框的大小）</strong>。为了解决单个进程的页表占用大量内存的问题，通常采用<strong>多级页表(Multi-Level Page Table)</strong> 方案，我们会在之后的课程中学习。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.2 页表查询开销" dir="auto" class="heading" id="6.2.2_页表查询开销"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.2 页表查询开销</h4><div class="heading-children"><div class="el-p"><p dir="auto">当 CPU 想要访问一个逻辑地址时，会触发地址转换，这时需要访问物理内存<strong>两次</strong>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>访问页表</strong>：不难理解，你想从虚拟地址得到物理地址，你就需要从PTBR(Page Table Base Register)读取页表起始地址，然后从这个页表中查询页面号对应的页框号。随后得到物理地址。</li>
<li data-line="1" dir="auto"><strong>访问转换后的物理地址</strong></li>
</ul></div><div class="el-p"><p dir="auto">当 CPU 频繁访问内存时，页表查找的开销会显著增加。这时，我们采用一种更高效的解决方案——<strong>快表</strong>。我们将在下节课介绍。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.3 页的分配和回收" dir="auto" class="heading" id="6.3_页的分配和回收"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3 页的分配和回收</h3><div class="heading-children"><div class="el-ul"><ul>
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>分配过程</strong>
<ul>
<li data-line="1" dir="auto">读取ELF头部，识别出需要加载的各个段</li>
<li data-line="2" dir="auto">为每个段的虚拟地址划分页面</li>
<li data-line="3" dir="auto">为每个页面分配一个页框（查找并更新页框表）</li>
<li data-line="4" dir="auto">更新页表</li>
</ul>
</li>
<li data-line="5" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>回收过程</strong>
<ul>
<li data-line="6" dir="auto">更新页表</li>
<li data-line="7" dir="auto">释放内存（更新空闲页框表）</li>
</ul>
</li>
</ul></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.4 地址转换和保护" dir="auto" class="heading" id="6.4_地址转换和保护"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4 地址转换和保护</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="6.4.1 地址转换" dir="auto" class="heading" id="6.4.1_地址转换"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4.1 地址转换</h4><div class="heading-children"><div class="el-p"><p dir="auto">在虚拟地址空间中，我们把虚拟的地址空间划分成一个一个页，因而产生的逻辑地址很容易得出来：<strong>虚拟地址</strong> = <strong>页面号</strong> + <strong>页内位移</strong>。<br>
<span alt="Pasted image 20240801081814.jpg" src="Pasted image 20240801081814.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240801081814.jpg" src="congzhi's-os-series/pics/pasted-image-20240801081814.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.4.2 内存保护" dir="auto" class="heading" id="6.4.2_内存保护"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4.2 内存保护</h4><div class="heading-children"><div class="el-p"><p dir="auto">页表项处理页框外，还有很多标志位来提供更为精细的访问控制。</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>P(Present)位</strong>：表示页是否在物理内存中（1表示页在内存中）</li>
<li data-line="1" dir="auto"><strong>R/W(Read/Write)位</strong>：控制页的读写权限（0表示可读/1表示可读写）</li>
<li data-line="2" dir="auto"><strong>U/S(User/Supervisor)位</strong>：控制页的访问权限（0表示只有内核能访问/1表示用户也可以访问）</li>
<li data-line="3" dir="auto"><strong>A(Accessed)位</strong>：指示该页是否被访问过（页的置换算法）</li>
<li data-line="4" dir="auto"><strong>D(Dirty)位</strong>：指示该页是否被写过（write-back）</li>
<li data-line="5" dir="auto"><strong>NX(No Execute)位</strong>：表示该页是否可执行（64位机器）</li>
</ol></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.4.3 页的重用" dir="auto" class="heading" id="6.4.3_页的重用"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4.3 页的重用</h4><div class="heading-children"></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.5 Memory Management on 64-bits Machine" dir="auto" class="heading" id="6.5_Memory_Management_on_64-bits_Machine"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.5 Memory Management on 64-bits Machine</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们已经学习了段式内存管理和页式内存管理。在 ICS 先导课中，我们结合32位机器（IA-32）进行了学习。在32位机器上，段页式内存管理应用非常普遍。在64位机器上，页式存储管理方案更为常见。常见的分页表结构有三种，分别是：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>分层分页(Hierarchical Paging)</strong></li>
<li data-line="1" dir="auto"><strong>哈希分页表(Hashed Page Tables)</strong></li>
<li data-line="2" dir="auto"><strong>倒排分页表(Inverted Page Tables)</strong></li>
</ol></div><div class="el-p"><p dir="auto">在后续的课程中，我们将探讨分层分页的页式存储管理方式，包括<strong>快表</strong>和<strong>多级页表</strong>等。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.6 Tradeoffs" dir="auto" class="heading" id="6.6_Tradeoffs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.6 Tradeoffs</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第七课 Translation Lookaside Buffer" dir="auto" class="heading" id="第七课_Translation_Lookaside_Buffer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第七课 Translation Lookaside Buffer</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">学习页式存储管理方案中，每当CPU 访存时，访问页表会为机器带来额外的开销（两次访存）。为了减少这种开销，设计人员使用 Cache 来减少时间上的开销。现代计算机使用<strong>地址转换旁路缓冲存储器</strong>，由于合理使用TLB能够将查询页表的时间开销降低到原先的5%甚至以下，由此得名<strong>快表</strong>。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="7.1 TLB" dir="auto" class="heading" id="7.1_TLB"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1 TLB</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>TLB</strong>&nbsp;是用 SRAM 做成的一种<strong>全相联存储器</strong>（命中率高）。TLB 中存储最近使用的页表项，加快了地址的转换速度（减少访存次数）。因为是全相联存储器，所以它会<strong>将 CPU 送来的页号和 TLB 中缓存的所有页号同时比较</strong>（硬件实现复杂，成本高）。如果找到匹配条目即为命中（TLB hit）。</p></div><div class="el-p"><p dir="auto"><strong>若命中(hit)</strong>，就会直接返回匹配条目的物理地址，这种情况当然最好。根据匹配条目的位置，我们有两种不同的结局：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">物理地址中的数据在缓存中，不需要访问内存。</li>
<li data-line="1" dir="auto">如果物理地址中的数据块不在缓存中，则需要额外访问一次内存。</li>
</ul></div><div class="el-p"><p dir="auto"><strong>若不命中(miss)</strong>，就会再查看页表，转换物理地址的同时将页表项写进 TLB。物理地址中的数据在缓存中，需要访问一次内存。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">物理地址中的数据不在缓存中，页表命中。产生两次访存。</li>
<li data-line="1" dir="auto">页表不命中。最差的情况，需要访问磁盘。<br>
<span alt="Pasted image 20240805022104.png" src="Pasted image 20240805022104.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240805022104.png" src="congzhi's-os-series/pics/pasted-image-20240805022104.png"></span></li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.1 Hit Ratio" dir="auto" class="heading" id="7.1.1_Hit_Ratio"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.1 Hit Ratio</h4><div class="heading-children"><div class="el-p"><p dir="auto">TLB 的命中率对系统性能至关重要，越高的命中率就以为这更多的地址转换可以在 TLB 中完成，减少了访存的次数（访问内存页表）。</p></div><div class="el-p"><p dir="auto">通常情况下，TLB的命中率非常高。一般在 90% 到 99% 之间。影响的因素有多个：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">程序的访问模式（程序的局部性原理）</li>
<li data-line="1" dir="auto">TLB 的大小和结构</li>
</ul></div><div class="el-p"><p dir="auto">要保持TLB命中率，我们还需要注意：<strong>当发生进程切换时，会使所有的 TLB 条目失效</strong>。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.2 TLB的缺点" dir="auto" class="heading" id="7.1.2_TLB的缺点"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2 TLB的缺点</h4><div class="heading-children"><div class="el-ul"><ul>
<li data-line="0" dir="auto">TLB 的造价高：SRAM的全相联存储器</li>
<li data-line="1" dir="auto">TLB 的功耗高：能占到微处理器总功耗的 10% 以上</li>
</ul></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第八课 Multi-Level Page Tables" dir="auto" class="heading" id="第八课_Multi-Level_Page_Tables"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第八课 Multi-Level Page Tables</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto"> 在上节课快表的学习中，我们用快表（一种cache）解决了页表所带来频繁的访存开销。在本节课中，我们学习多级页表，了解一下多级页表是如何优化页表所带来的存储开销的。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.1 Back to Dark Ages" dir="auto" class="heading" id="8.1_Back_to_Dark_Ages"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1 Back to Dark Ages</h3><div class="heading-children"><div class="el-p"><p dir="auto">现如今，16GB、32GB甚至64GB的主机内存屡见不鲜。对于本节课，我们看到页表的分级可能不太理解，我们继续用 32 位 4GB 的虚存举例子。没有页表的分级结构前，我们需要 4MB 的连续内存来存储每个进程的页表。</p></div><div class="el-p"><p dir="auto">现在的内存价格大约是 15rmb/GB，换算成 rmb/MB 更加便宜。而在1985年 Intel 386 推出时，内存的价格是骇人的 500$/MB。当时Windows 1.0 (Nov 1985) 只需要 192KB RAM 就可以运行。我们可能感觉不到那是一个多么黑暗的年代，但是我们能够感同身受的是多级页表的存在真的非常必要。当时的 i386 使用的就是二级页表。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.2 Page Table PAGE" dir="auto" class="heading" id="8.2_Page_Table_PAGE"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2 Page Table PAGE</h3><div class="heading-children"><div class="el-p"><p dir="auto">在 x86-32 架构下，一个进程的虚拟地址空间的理论大小为: <span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>假设一个页面大小为 4KB，可划分出来的页面数量就有 1M 这么多，每个页表项 4B ，就会产生 1M*4B = 4MB 的连续空间大小。如果系统中有100个进程，那么即使什么都不做，都会用掉400M的连续内存。而进程一般不会用掉4GB的内存，因而有很多空洞页面。也就是说，每个进程是用不掉这1M个这么多的页表项的。</p></div><div class="el-p"><p dir="auto"><strong>但是在单级页表下，即使进程不访问主存，也要为进程分配足够的页表项来覆盖整个虚拟地址空间。（连续存储）</strong></p></div><div class="el-p"><p dir="auto">而我们可以将页表的内存空间再进行分页，就可以把这些<strong>页表页</strong>离散的存到内存里了。这样不仅仅有助于提高内存的利用率（将大象分块放入冰箱），同时操作系统也可以实现<strong>按需分配</strong>页表空间了。刚刚单级页表中，操作系统需要为那些空洞页面也分配页表项，这太浪费空间了！当操作系统可以按需分配页表后，就可以完全不为空洞页面分配页表项，节省内存。</p></div><div class="el-p"><p dir="auto">为了实现页表的分页，我们当然还需要额外地准备一张<strong>页目录表(Page Directory Table)</strong>，用来记录页表页存放的页框号。（二级页表）</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.3 Multi-Level Page Tables" dir="auto" class="heading" id="8.3_Multi-Level_Page_Tables"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3 Multi-Level Page Tables</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.1 Two-Level Page Table" dir="auto" class="heading" id="8.3.1_Two-Level_Page_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.1 Two-Level Page Table</h4><div class="heading-children"><div class="el-p"><p dir="auto">先将页表分页，本来 4MB 大小的页表可以分成 1K 页，每个<strong>页目录表(page directory/first level page table)</strong> 就只占 4KB 的空间，刚好是一个页的大小。其中每个<strong>页目录表项</strong>有 4B，记录页表页的存放的页框号，页目录表项就是 <strong>PDE(Page Directory Entry)</strong>。<br>
<span alt="Pasted image 20240924011424.jpg" src="Pasted image 20240924011424.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240924011424.jpg" src="congzhi's-os-series/pics/pasted-image-20240924011424.jpg"></span><br>
每个页目录表项都对应着一个页表(page table)。我们知道，一个页表可以映射4MB的内存，那么使用二级页表就可以通过第1级页表映射第2级页表，第二级页表进一步映射有：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6D"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c79"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c70"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.413em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span>那这4GB虚拟内存需要全部分配吗？当然不！在下图中，红色的部分就是页目录表项所记录的空洞页框号，在主存中并不用分配所对应的页框号，在页表中不需要给这部分空间分配页表项。所以操作系统就不用给这部分空间分配<strong>页表页(second level page table)</strong>，直到进程申请到了这部分的内存（<strong>按需分配</strong>）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240814201027.png" src="Pasted image 20240814201027.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240814201027.png" src="congzhi's-os-series/pics/pasted-image-20240814201027.png"></span><br>
从上面的图中，我们看到页目录表的出现好像为内存增加了额外的负担，但别忘了这是操作系统不需要为空洞页面分配相应页表页的前提下的。如果进程只是用了 1GB 的虚存空间，那么用这 4KB 去换取 3MB 的页表页不载入内存好像是一个不错的交换。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240814203923.png" src="Pasted image 20240814203923.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240814203923.png" src="congzhi's-os-series/pics/pasted-image-20240814203923.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.2 四级页表" dir="auto" class="heading" id="8.3.2_四级页表"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.2 四级页表</h4><div class="heading-children"><div class="el-p"><p dir="auto">进入 64 位架构的时代后，进程的虚拟地址空间剧增（用户区和内核区各占256TB）。如果我们仍然使用二级页表的连续页框来存储，那么将产生：<span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mfrac><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D447 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2217"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43A TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span>的二级页表空间，我们的内存显然是不够用的，因而出现了<strong>多级页表</strong>。我们在这里介绍<strong>四级页表</strong>。解决方法简单粗暴——对页目录表继续分页。在四级页表中，页面大小仍然是 4KB，从顶至底的页表分别是：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">PGD（9bits）：Page Global Directory</li>
<li data-line="1" dir="auto">PUD（9bits）：Page Upper Directory</li>
<li data-line="2" dir="auto">PMD（9bits）：Page Middle Directory</li>
<li data-line="3" dir="auto">PTE（9bits）：Page Table Entry</li>
<li data-line="4" dir="auto">Page（12bits）</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.3.3 Tradeoffs" dir="auto" class="heading" id="8.3.3_Tradeoffs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3.3 Tradeoffs</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>优点</strong>：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">分散的页表管理</li>
<li data-line="1" dir="auto">支持非常大的地址空间<br>
<strong>缺点</strong>：</li>
<li data-line="3" dir="auto">地址转换时间增加（通过增加TLB优化）</li>
<li data-line="4" dir="auto">开销增加</li>
<li data-line="5" dir="auto">复杂性增加</li>
</ul></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第九课 Caching/Buffering" dir="auto" class="heading" id="第九课_Caching/Buffering"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第九课 Caching/Buffering</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">Caching是一种用于提高数据访问速度和系统性能的技术。在中学时，我们常常把正在用的书放在面前，把常用到的书摞在一起放到课桌上，不常用的书放到书包里。这就是一种cache。在我们学习快表的时候，我们知道当 TLB 命中率越高，机器的性能就越好。（因为cache常用更快的存储介质）</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.1 Locality of Reference" dir="auto" class="heading" id="9.1_Locality_of_Reference"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1 Locality of Reference</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>局部性原理</strong>，也叫<strong>引用局部性</strong>。分为时间局部性和空间局部性。局部性原理在计算机科学中的应用是非常广泛的，不仅仅应用在替换算法中。局部性原理还体现在存储器层次结构和编译器优化上。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.1.1 Temporal Locality" dir="auto" class="heading" id="9.1.1_Temporal_Locality"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1 Temporal Locality</h4><div class="heading-children"><div class="el-p"><p dir="auto">时间局部性指的是，如果某个数据在被访问过一次，那么在不久的将来很可能还会被访问。当我们将这些数据放在 cache 中不进行替换，就会大大增加系统的运行性能。我们用一个例子来说明：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> matrix<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">// matirx的初始化</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
	
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> matirx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of sum is: %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这个例子中，变量&nbsp;<code>sum</code>&nbsp;和&nbsp;<code>j</code>&nbsp;是经常被访问的数据。将这些数据保存在缓存中可以显著提升性能，因为它们在短时间内被多次访问。。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.1.2 Spatial Locality" dir="auto" class="heading" id="9.1.2_Spatial_Locality"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.2 Spatial Locality</h4><div class="heading-children"><div class="el-p"><p dir="auto">空间局部性是指，当某个数据被访问到后，它周围空间之后一段时间也很有可能被访问到。继续上面的例子，如果将循环中变量 <code>i</code> 和 <code>j</code> 进行如下改动，那么空间局部性就会变得非常差。因为每次访问的地址都不是连续的，而且每一行都有1000个元素（4000字节），所以完全利用不到 cache 这个层次，总是访问主存甚至磁盘。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们看到，尽管先按列访问的方法的作用和按行访问相同，但是由于空间的局部性，它们对 cache 利用率会大不一样，因此列访问效率会不如行访问的效率。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.2 Memory Hierarchy" dir="auto" class="heading" id="9.2_Memory_Hierarchy"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2 Memory Hierarchy</h3><div class="heading-children"><div class="el-p"><p dir="auto">引用局部性是计算机系统中的一种可预测行为，强局部性的系统非常适合通过 cache、预取等技术进行性能优化。局部性的典型应用有<mark>层次化存储</mark>。</p></div><div class="el-p"><p dir="auto"><strong>层次化存储</strong>是一种利用时间和空间局部性的硬件优化，可用于多个层次的内存结构中。层次化存储系统通过将存储器分为多个层次，每个层次都有不同的速度和容量，来提高内存访问效率。层次化的存储有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>CPU寄存器</strong>：存储速度最快，速度有限（8-256个）</li>
<li data-line="1" dir="auto"><strong>L1 Cache</strong>：每个核心各有一个，容量32KB-512KB，速度很快</li>
<li data-line="2" dir="auto"><strong>L2 Cache</strong>：多个核心共享，容量128KB-24MB，速度比L1 Cache慢</li>
<li data-line="3" dir="auto"><strong>L3 Cache</strong>：所有核心共享，容量2MB-64MB，速度比L2 Cache慢</li>
<li data-line="4" dir="auto"><strong>主存储器</strong>：容量大，但存取速度慢</li>
<li data-line="5" dir="auto"><strong>磁盘存储</strong>：容量巨大，存取速度最慢</li>
<li data-line="6" dir="auto"><strong>云存储</strong>：容量无限制，存取速度根据网络状况而定</li>
</ol></div><div class="el-p"><p dir="auto">根据局部性原理，现代计算机会将那些更频繁使用的数据放在高层级的存储器中。如果高层级存储器空间不够用，就会用内存置换算法将存储空间中一部分内容对换到下层次的存储器中。在替换的过程中难免会有cache数据一致性的问题，我们用替换策略和写策略来做相应应对。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241123015750.jpg" src="Pasted image 20241123015750.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241123015750.jpg" src="congzhi's-os-series/pics/pasted-image-20241123015750.jpg"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.2.1 Page Fault" dir="auto" class="heading" id="9.2.1_Page_Fault"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2.1 Page Fault</h4><div class="heading-children"><div class="el-p"><p dir="auto">缺页是指当程序访问的页面不在物理内存中时，操作系统需要从磁盘中将该页面调入内存的情况。这种情况会导致程序暂时停止执行，直到所需页面被加载到内存中。缺页特指主存到磁盘存储这一层次的页面缺失。缺页会引起中断，使操作系统介入将页面加载到内存里，由于涉及到磁盘这一层次，所以缺页非常慢，高频次的缺页可能引起性能的大幅下降。</p></div><div class="el-p"><p dir="auto">缺页这类现象并不局限于主存-磁盘的存储结构，从Cache的结构到主存也会涉及到“缺页”相关的现象。只不过主存以下的缺页所带来的系统开销足够小，并不需要引发操作系统的重视。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.2.2 Replacement Policy" dir="auto" class="heading" id="9.2.2_Replacement_Policy"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2.2 Replacement Policy</h4><div class="heading-children"><div class="el-p"><p dir="auto">缓存写满时，就要再写入新数据就必须选择 cache line 进行替换，此时就要考虑替换策略：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>FIFO</strong>：最早进入缓存的数据最先被替换。这种策略简单易实现，但可能不总是最优的，因为最早进入的数据不一定是最不常用的。</li>
<li data-line="1" dir="auto"><strong>LRU</strong>：最近最少使用的数据被替换。这种策略更符合局部性原理，但实现起来相对复杂，需要维护每个缓存行的使用时间戳或链表。</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.2.3 Write Policy" dir="auto" class="heading" id="9.2.3_Write_Policy"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2.3 Write Policy</h4><div class="heading-children"><div class="el-p"><p dir="auto">当一个数据再缓存中被修改了，那么对应内存数据如何处理也成了一个问题。一般情况下，我们有这两种写策略：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>Write-Through</strong>：每次写操作都同时更新缓存和主存。虽然数据一致性高，但由于每次写操作都涉及主存，速度较慢。</li>
<li data-line="1" dir="auto"><strong>Write Back</strong>：每次写操作只更新缓存，只有缓存行被替换时才写回主存。这种策略速度快，但需要额外的机制来确保数据一致性，例如脏位（Dirty Bit）来标记哪些缓存行需要写回主存。</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.3 Page Replacement Algorithms" dir="auto" class="heading" id="9.3_Page_Replacement_Algorithms"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3 Page Replacement Algorithms</h3><div class="heading-children"><div class="el-p"><p dir="auto">在之前的学习中，我们了解了虚拟内存和进程的分页机制。这些机制共同作用，使系统可以加载比有限内存大得多的程序。当缺页发生（page fault），操作系统将缺失的页面加载进内存。然而这个过程是有代价的，我们这小节比较不同的算法，看看哪种算法下的hit ratio最高。</p></div><div class="el-p"><p dir="auto">本小节我们将着重关注当主存空间满时，页面是如何置换到磁盘中，为后来加载的页面腾出空间。当CPU要访问某一页面时，<strong>如果页面在内存中就Hit，如果不在页面中就Miss</strong>。对于页面置换算法而言，命中率越高，表明性能越好，反之，性能越坏。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.1 First-In, First-Out" dir="auto" class="heading" id="9.3.1_First-In,_First-Out"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.1 First-In, First-Out</h4><div class="heading-children"><div class="el-p"><p dir="auto">先进先出算法是简单的<strong>队列算法(Queue)</strong>，队列的数据结构插入和删除发生在不同的端头，<strong>在尾部插入，在头部删除(Enqueue in rear, dequeue in front)</strong>。这种结构确保了最早进入队列的元素能够得到最早的处理，在进程调度、打印任务管理的场景得到了很好的应用。这种结构是否适用于内存的置换呢？我们最关心的是这种结构的命中率如何。我们接着看。<br>
<span alt="Pasted image 20240923222601.png" src="Pasted image 20240923222601.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240923222601.png" src="congzhi's-os-series/pics/pasted-image-20240923222601.png"></span><br>
凡是缺页的就标记为Miss，命中的标记为Hit。如果队列满且下一次页面访存Miss，那么FIFO页面置换算法的操作系统就会选择最早进入内存的页面进行置换。我们直觉上就会感到这种算法很不靠谱，事实上也确实不靠谱。FIFO页面置换算法的命中率相比其他算法是相当低的。</p></div><div class="el-p"><p dir="auto">而且FIFO还会引发反直觉的Bélády's Anomaly现象。主要原因是FIFO只考虑了页面的时间序列，而没有考虑页面的引用局部性。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.3.1.1 Bélády's Anomaly" dir="auto" class="heading" id="9.3.1.1_Bélády's_Anomaly"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.1.1 Bélády's Anomaly</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>贝莱蒂现象</strong>得名于匈牙利科学家贝莱蒂发现的一种现象，即随着<strong>分配页面的增多缺页率反而增加</strong>。这是十分反直觉的，这种现象主要发生在FIFO算法中，原因我们上文也已给出。在OPT算法、LRU算法等考虑时间局部性的算法中几乎不会发生这种现象。</p></div><div class="el-p"><p dir="auto">下面我们用一个例子直观感受一下这种现象。假设当前的队列为空，我们下面即将访问页面的顺序是：<code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code>。当队列中页框数为3时，我们有：<br>
<span alt="Pasted image 20240923230804.png" src="Pasted image 20240923230804.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240923230804.png" src="congzhi's-os-series/pics/pasted-image-20240923230804.png"></span><br>
我们看到，在第一个例子中，我们总共发生了9次page faults。但是下图中，我们将队列中页框数增加到4时，我们看到，缺页次数不但没有下降，反而增加了。<br>
<span alt="Pasted image 20240923230816.png" src="Pasted image 20240923230816.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240923230816.png" src="congzhi's-os-series/pics/pasted-image-20240923230816.png"></span><br>
“基于栈”的页面置换算法就不会受到贝莱蒂现象的影响。因为这些算法在实现时使用了<strong>类似栈</strong>的数据结构来管理页面。具体来说，这些算法维护一个页面栈，栈顶的页面是最近使用的，而栈底的页面是最久未使用的。下面我们将会学习到OPT算法和LRU算法，这两个算法都是stack-based algo。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.3.1.2 FIFO算法优缺点" dir="auto" class="heading" id="9.3.1.2_FIFO算法优缺点"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.1.2 FIFO算法优缺点</h5><div class="heading-children"><div class="el-p"><p dir="auto">FIFO算法最大的优点就是<strong>实现简单</strong>，但是<strong>没有考虑到页面的引用局部性</strong>是FIFO最大的缺点。我们选用页面置换算法的目的是提高主存的命中率，从而减少访问磁盘的次数，使得机器的存取速度更接近主存的存取速度，进来提高机器的速度。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.2 CLOCK/Second Chance Algorithm" dir="auto" class="heading" id="9.3.2_CLOCK/Second_Chance_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.2 CLOCK/Second Chance Algorithm</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>时钟算法</strong>是FIFO的改进版，除了考虑页面的时间顺序，同时也照顾到了页面的引用情况。在之前的学习中，我们知道页表项(PTE)有一个<strong>属性位(Accessed bit)</strong>，1表示访问过，0表示未访问过。CLOCK算法就是在FIFO算法的基础上为每个页面增添一个<strong>引用位(reference bit)</strong>，和页表项中的accessed bit类似。</p></div><div class="el-p"><p dir="auto">由于是FIFO算法的改进，CLOCK会按照FIFO的顺序检查每一个页面的reference位，如果reference位为1，则将此位设置为0，然后检查下一页。如果页引用位是0，就选中该页作为淘汰页。这种方式给了页第二次驻留内存的机会，因此也称为<strong>二次机会算法</strong>。</p></div><div class="el-p"><p dir="auto">当检查完队列最后一个页面就会循环检查第一页。（Like a CLOCK spining again and again）</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.3.2.1 CLOCK+ Algorithm" dir="auto" class="heading" id="9.3.2.1_CLOCK+_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.2.1 CLOCK+ Algorithm</h5><div class="heading-children"><div class="el-p"><p dir="auto">CLOCK+算法是对CLOCK算法的一种改进，旨在延迟页面的置换操作。假如某个页面在加载进内存后被修改，那么它的dirty位就会置为1。我们知道，如果页面置换策略采用回写策略(write-back)，则表示只有页面置换到磁盘上时才会将数据进行同步。</p></div><div class="el-p"><p dir="auto">如果我们结合页的accessed bit和dirty bit两个属性，我们一共可以得到四种情况：</p></div><div class="el-pre"><pre><code data-line="0">1. A = 0, D = 0    // 最先淘汰
2. A = 0, D = 1
3. A = 1, D = 0
4. A = 1, D = 1    // 最后淘汰
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>第一轮检查</strong>：<br>
按照FIFO顺序检查1类页面，如果检出就淘汰<br>
如果没有检出就进行第二轮检查</li>
<li data-line="3" dir="auto"><strong>第二轮检查</strong>：<br>
按照FIFO顺序检查2类页面，如果检出就淘汰<br>
如果没有2类页面，则将后续页面的A位置为0<br>
如果第二轮结束依然没有找到二类页面，则重复第一轮</li>
</ol></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.3 Optimal Page Replacement Algorithm (Bélády's Algorithm)" dir="auto" class="heading" id="9.3.3_Optimal_Page_Replacement_Algorithm_(Bélády's_Algorithm)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.3 Optimal Page Replacement Algorithm (Bélády's Algorithm)</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>最佳页面置换算法</strong>会选择在将来最长时间内不会访问的页面进行替换。这种算法虽然确实是一种 optimal algorithm，理论上这种算法的命中率是最高的，但是这种算法过于理想了。</p></div><div class="el-p"><p dir="auto">因为预知未来将要访问的页面在实际的应用中几乎是不可能的。而且即使在模拟环境中实现 OPT 算法，所需要的计算资源也将是巨大的。所以 OPT 算法一般就作为 optimal algorithm 来判断一个页面置换算法的优劣。实践上，我们会用 OPT 算法与其他的算法进行比较。为其他算法提供一个理想的参考标准，用来评估其他页面置换算法的性能。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.4 Least Recently Used" dir="auto" class="heading" id="9.3.4_Least_Recently_Used"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.4 Least Recently Used</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>最近最久未使用</strong>算法算得上实际生活中页面置换算法的 GOAT ，LRU会替换最近最少使用的页面。这个根据是程序的<strong>局部性原理</strong>，即最近使用过的数据在未来一段时间后仍可能被使用。</p></div><div class="el-p"><p dir="auto">在算法的实现中，尽管我们不能预测未来，但是我们仍然可以观察过去。我们可以通过过去访问的页来指定未来哪些页需要被先置换出去，哪些页应当保留。要实现LRU，我们需要额外地维护一个链表，用于保存刚刚访问的页面及最久未被访问的页面。且每次访问页都可能对链表排序进行调整，又是额外的时间开销。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.5 Less Frequently Used" dir="auto" class="heading" id="9.3.5_Less_Frequently_Used"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.5 Less Frequently Used</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.6 Not Frequently Used" dir="auto" class="heading" id="9.3.6_Not_Frequently_Used"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.6 Not Frequently Used</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.7 NFU + Aging" dir="auto" class="heading" id="9.3.7_NFU_+_Aging"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.7 NFU + Aging</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.8 ARC" dir="auto" class="heading" id="9.3.8_ARC"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.8 ARC</h4><div class="heading-children"></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第十课 Virtual Memory" dir="auto" class="heading" id="第十课_Virtual_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第十课 Virtual Memory</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="10.1 Reviewing: Ideas of Virtual Memory" dir="auto" class="heading" id="10.1_Reviewing:_Ideas_of_Virtual_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1 Reviewing: Ideas of Virtual Memory</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们终于将虚拟内存作为单独的专题进行讨论了。我们先回顾一下为什么我们需要虚拟存储器。在早些时候，内存容量很小，所以我们需要二级存储器来作为后备力量。现在虽然我们有 16/32GB 甚至更大的主存容量，能够容纳大多数的软件，但随着软件数量的增多和体积的增大，这么大的主存容量可能还是不够用。</p></div><div class="el-p"><p dir="auto">那么如果我们只将程序的<strong>一小部分</strong>放在主存中呢？根据程序局部性原理，我们当然可以这样做，而且带来的好处远远大于整个程序的 swapping 所带来的系统开销。先导课程中，我们介绍过早期的虚拟内存实现。当程序不再需要完全放在内存中时，这不仅节省了内存空间，还减少了每个程序使用的主存空间，同时也减少了使用 IO 进行 swapping 的次数（每次只需加载程序的一部分）。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.1.2 Virtual Memory" dir="auto" class="heading" id="10.1.2_Virtual_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.2 Virtual Memory</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>虚拟内存(VM)</strong> 是操作系统管理内存的一种技术。通过将小部分的程序调入内存中运行，它可以向应用程序提供一个<strong>独享</strong>、<strong>连续</strong>且<strong>巨大</strong>的内存空间。尽管内存无法容纳所有进程，但虚拟内存提供了一种非常有效的方法来应对这种情况。即按需调入，并将长时间未访问的页调出到磁盘中。利用磁盘的大容量来运行程序。<br>
<span alt="Pasted image 20241112175054.png" src="Pasted image 20241112175054.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241112175054.png" src="congzhi's-os-series/pics/pasted-image-20241112175054.png"></span><br>
我们前面提到了页表、虚拟内存的思想blablabla，我们来总结一下虚拟内存怎么用：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>段检查（Segmentation Check）</strong>：每次CPU要访问某个内存地址的指令或数据时，内存管理单元（MMU）都会检查这个内存引用是否有效。MMU会先进行段检查，如果段不可用，就会终止程序并抛出segmentation fault。</li>
<li data-line="1" dir="auto"><strong>缺页处理（Page Fault Handling）</strong>：如果段地址有效，但引用的页不在内存中，就会发生缺页。这时操作系统会找到一个空闲页框，请求磁盘读操作（可能还会写），然后将新页面载入内存。</li>
<li data-line="2" dir="auto"><strong>更新页表和恢复执行</strong>：当页面加载完成后，操作系统会更新页表并记录相关信息。最后，重新对该虚拟地址进行访问，继续执行程序。</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.1.3 Demand Paging" dir="auto" class="heading" id="10.1.3_Demand_Paging"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.3 Demand Paging</h4><div class="heading-children"><div class="el-p"><p dir="auto">由于虚拟内存涉及到内存-磁盘这一层次的存储层次，当部分加载进内存的程序发生缺页时会发生什么呢？当进程访问的虚拟页不在物理内存中就会产生页错误。当缺页发生时，会：<br>
<span alt="Pasted image 20240808004636.png" src="Pasted image 20240808004636.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240808004636.png" src="congzhi's-os-series/pics/pasted-image-20240808004636.png"></span></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>发生缺页</strong>，向操作系统报告。随后操作系统接管并保存运行上下文，操作系统figure out这是一个缺页中断。随后MMU检查这个地址是否合法。</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>然后就是决定加载页面到内存的某个页框中（使用页面替换算法）。在选择装入前先检查一下要替换的页面是否被修改过（脏位是否为1）。
<ul>
<li data-line="2" dir="auto">如果没有修改过，跳到第 5 步。</li>
</ul>
</li>
<li data-line="3" dir="auto">如果修改过，先将该页面写回到磁盘中。磁盘写请求放在一个队列中。然后等待磁盘写执行，CPU这时会做其他的事情。当磁盘写完成之后会向操作系统发出中断信号。</li>
<li data-line="4" dir="auto">保存寄存器和其他进程状态（为什么？）</li>
<li data-line="5" dir="auto">发起磁盘读操作，将磁盘中的数据读到内存的空闲页框里。和前面的写操作一样，对磁盘读的请求会放在一个队列里，在磁盘读操作进行的过程中，CPU做其他的事情。</li>
<li data-line="6" dir="auto">当磁盘完成I/O操作后，向系统发生中断信号。</li>
<li data-line="7" dir="auto">如有必要，保存寄存器和其他进程状态。（为什么？）</li>
<li data-line="8" dir="auto">最后<strong>更新页表，恢复执行</strong>。</li>
</ol></div><div class="el-h5 heading-wrapper"><h5 data-heading="10.1.3.1 Lazy Approach" dir="auto" class="heading" id="10.1.3.1_Lazy_Approach"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.3.1 Lazy Approach</h5><div class="heading-children"><div class="el-p"><p dir="auto">：只有在需要的时候才从外存中加载到内存。（处理 page fault 就是一种 lazy approach）</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="10.1.3.2 HHDs and SSDs" dir="auto" class="heading" id="10.1.3.2_HHDs_and_SSDs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.1.3.2 HHDs and SSDs</h5><div class="heading-children"><div class="el-p"><p dir="auto">尽管缺页需要这么多步才能恢复执行，但实际上对磁盘（HHDs）的操作是最耗费时间的。重启进程和内存的管理需要耗费 1μs - 100μs。然而，磁盘的延迟有 3ms（3000μs），寻道时间 5ms（5000μs），而传输时间只用 0.05ms（50μs）。所以，当缺页中断率很高时，性能会非常非常差。（一般而言，缺页中断率会控制在<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-texatom size="s" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup></mjx-math></mjx-container></span>这个水平）这也就是为什么说page fault is painful。</p></div><div class="el-p"><p dir="auto">现在，我们大多使用SSDs这种介质作为二级存储器，相比于HHDs，SSDs是一种更快、更可靠的存储解决方案。SSD的延迟通常在几十微秒（μs）范围内，远低于HHDs的毫秒（ms）级别延迟。SSD没有机械部件，因此没有寻道时间，数据传输速度也更快。这使得SSD在处理缺页中断时的性能显著优于HHDs。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="10.2 Thrashing" dir="auto" class="heading" id="10.2_Thrashing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2 Thrashing</h3><div class="heading-children"><div class="el-p"><p dir="auto">当缺页(page fault)或换入换出(swapping)发生时，操作系统会进入内核态来处理这些事件。处理这些事件会有一定的时间开销。如果缺页的发生频率过高，CPU就不得不花费更多的时间来处理这些换出操作。这种由于换出过于频繁而导致系统性能大幅下降的现象称为<strong>抖动</strong>。<br>
<span alt="Pasted image 20240924163417.png" src="Pasted image 20240924163417.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240924163417.png" src="congzhi's-os-series/pics/pasted-image-20240924163417.png"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.2.1 影响抖动的因素" dir="auto" class="heading" id="10.2.1_影响抖动的因素"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2.1 影响抖动的因素</h4><div class="heading-children"><div class="el-p"><p dir="auto">引发抖动的原因可能有多个，比如<strong>并发进程数量</strong>、<strong>内存分配策略</strong>、<strong>页面调入策略</strong>、<strong>页面置换算法</strong>等。上节课我们已经了解过页面置换策略是如何影响页命中率的，下面我们着重来看内存分配策略和调页策略对抖动的影响和如何避免抖动。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.2.2 Frame Allocation Strategies" dir="auto" class="heading" id="10.2.2_Frame_Allocation_Strategies"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2.2 Frame Allocation Strategies</h4><div class="heading-children"><div class="el-p"><p dir="auto">OS为进程分配内存有两种策略，<strong>固定页框(fixed allocation)</strong> 和<strong>可变页框(variable allocation)</strong>。<strong>固定页框</strong>是指操作系统为每个进程分配一组固定数量的物理页框（物理内存块），且在进程运行期间一直保持这样数量的物理页框。固定页框策略要求每个进程只能使用自己分配的页框，不能使用其他进程的页框。<strong>等分页框(Equal Allocation)</strong> 就是一种固定页框，系统中的所有物理页框平均分配给每个进程。</p></div><div class="el-p"><p dir="auto"><strong>可变页框</strong>是操作系统根据进程的需求动态地分配物理页框，进程运行期间，页框的数量可以增加或减少。<strong>比例分配(Proportional Allocation)</strong> 是可变页框的一种，进程分配的页框数量可以根据进程的大小和进程数量来动态调整。</p></div><div class="el-p"><p dir="auto">固定页框<strong>实现简单，管理方便</strong>，因为每个进程的内存需求是预先确定的。但是这种分配策略的灵活性很差，可能导致内存利用率不高。如果分配的页框数量过多，会浪费内存；如果分配的页框数量过少，可能导致频繁的缺页中断。</p></div><div class="el-p"><p dir="auto">可变页框的优缺点完全和固定页框的实现反着来，可变页框灵活性高，可以根据实际需求调整内存分配，提高内存利用率。但是实现复杂，需要更复杂的管理机制来跟踪和调整页框的分配。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.2.3 Local and Global Page Replacement" dir="auto" class="heading" id="10.2.3_Local_and_Global_Page_Replacement"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2.3 Local and Global Page Replacement</h4><div class="heading-children"><div class="el-p"><p dir="auto">当缺页中断发生，操作系统需要swapping需要置换的页。我们也有两种相关的实现方式：<strong>局部置换</strong>和<strong>全局置换</strong>。</p></div><div class="el-p"><p dir="auto"><strong>局部置换</strong>是指当发生缺页中断时，操作系统只在当前进程的物理页框中选择一个页面进行置换。这样，每个进程只能使用自己分配的物理页框，不会影响其他进程的内存使用。如果某个进程的内存需求突然增加，可能会频繁发生缺页中断，影响该进程的性能。</p></div><div class="el-p"><p dir="auto"><strong>全局置换</strong>是指当发生缺页中断时，操作系统可以在所有进程的物理页框中选择一个页面进行置换。这样，操作系统可以动态调整各个进程的物理页框数量，根据实际需求进行分配。内存利用率更高，可以更好地适应不同进程的内存需求变化。可能导致进程之间的相互干扰，一个进程的内存需求增加可能会影响其他进程的性能。</p></div><div class="el-p"><p dir="auto">为什么固定页框和全局置换是矛盾的。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.2.4 Paging Strategies" dir="auto" class="heading" id="10.2.4_Paging_Strategies"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2.4 Paging Strategies</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>请页式(Demand Paging)</strong> 是当进程需要访问某个页面而页面不在内存中时，产生缺页中断，操作系统将该页面从磁盘调入内存的页面调入策略。只在需要时加载页面，减少了不必要的内存占用，但是也可能导致频繁的缺页中断，影响系统性能。</p></div><div class="el-p"><p dir="auto"><strong>调页式(Pre-paging)</strong> 是在执行访问页面之前将之后要访问的多个页面提前加载到内存中。如果预测准确，就会减少缺页中断的频率，如果预测不准确就会加载不必要的页面，浪费内存资源。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.2.5 Page Replacement Algorithms" dir="auto" class="heading" id="10.2.5_Page_Replacement_Algorithms"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.2.5 Page Replacement Algorithms</h4><div class="heading-children"><div class="el-p"><p dir="auto">除了上面的因素，页面置换算法也是影响系统发生抖动的重要因素。页面置换算法不同，缺页次数就不相同。我们熟悉的LRU就是一种好的页面置换算法。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="10.3 防止抖动的策略" dir="auto" class="heading" id="10.3_防止抖动的策略"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3 防止抖动的策略</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="10.3.1 Working-Set Model" dir="auto" class="heading" id="10.3.1_Working-Set_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3.1 Working-Set Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">工作集模型基于局部性原理，根据局部性大致地给出程序之后最有可能访问的页有哪些。根据工作集，我们能够<strong>减少缺页</strong>的同时尽可能地<strong>节省内存页框的资源</strong>。</p></div><div class="el-p"><p dir="auto">为确定工作集窗口，我们检测最近使用过的页，看看哪些页的使用是最频繁的，之后将工作集设置为局部时间Δ内引用最多的页面的集合（如下Δ = 10）。不难理解，如果某页面被频繁地访问，那么就会出现在工作集中。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240925010529.png" src="Pasted image 20240925010529.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240925010529.png" src="congzhi's-os-series/pics/pasted-image-20240925010529.png"></span></p></div><div class="el-p"><p dir="auto">当工作集一旦被确定，系统就可以在进程启动或重启之前，根据这些历史访问数据将工作集中的页面预先调入主存（预调页的实现）。进程开始执行时就能减少缺页中断的发生，提高了系统性能。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.3.2 Page Fault Frequency" dir="auto" class="heading" id="10.3.2_Page_Fault_Frequency"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.3.2 Page Fault Frequency</h4><div class="heading-children"><div class="el-p"><p dir="auto">通过之前的学习，我们了解了抖动问题的根源在于频繁的页面置换，即<strong>缺页中断频率（PFF）</strong>。如果一个进程的PFF过高，这表示系统给该进程分配的页框过少；如果系统给当前进程分配的页框非常多，就不会引起频繁的换入换出。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240925004924.png" src="Pasted image 20240925004924.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240925004924.png" src="congzhi's-os-series/pics/pasted-image-20240925004924.png"></span><br>
随着进程分配页框数的增加，PFF一定会减少。我们发现PFF会根据页框数呈类似于1/N的减少趋势。基于此，我们可以划定合适的上限PFF(upper bound)和下限PFF(lower bound)。根据这两个边界划分进程分配页框数。当分配的页框数过少时，PFF会显著增加（超过upper bound），从而影响性能；而当分配的页框数过多时（小于lower bound），会浪费内存页框，性价比不高。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="10.x Virtual Memory Allocation" dir="auto" class="heading" id="10.x_Virtual_Memory_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.x Virtual Memory Allocation</h3><div class="heading-children"><div class="el-p"><p dir="auto">在程序中申请内存时，我们操作的是虚拟内存。操作系统负责将这些虚拟地址映射到物理内存或磁盘空间（<code>mmap()</code>）。虚拟内存区域的分配只需确保不与现有映射冲突，无需采用物理内存管理中的<code>best fit</code>等算法。由于虚拟内存无需考虑碎片问题，所以通常使用更高效的方式（如 <code>first fit</code> ）管理地址空间。</p></div><div class="el-p"><p dir="auto">我们有两种不同的虚拟内存分配方式：静态的和动态的。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.x.1 Static Memory Allocation" dir="auto" class="heading" id="10.x.1_Static_Memory_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.x.1 Static Memory Allocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">静态内存分配是在编译时分配内存的方式。程序在编译时确定变量的虚拟地址布局（如 <code>.data</code> 段、 <code>.text</code> 段等），其生命周期覆盖整个程序运行周期。物理内存的实际分配由操作系统在程序加载时完成，且内存大小不可在运行时调整。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.x.2 Dynamic Memory Allocation" dir="auto" class="heading" id="10.x.2_Dynamic_Memory_Allocation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.x.2 Dynamic Memory Allocation</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果你需要在运行时申请内存（堆内存），你就会用到动态内存分配函数在程序运行时根据需要分配和释放内存。常见的动态内存分配函数包括 <code>malloc</code> 、<code>calloc</code> 、<code>realloc</code> 和 <code>free</code>。动态内存分配的灵活性高，可以根据程序的需要动态调整内存大小。但需要手动管理，容易发生内存泄漏。</p></div><div class="el-p"><p dir="auto">在 Linux 系统中，<code>malloc</code> 库函数会在底层调用 <code>brk</code>（小于 128KB 的内存申请） 和 <code>mmap</code> 系统调用（大于 128KB 的内存申请）。（一般情况下）</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="10.x.2.1 `brk` and `sbrk`" dir="auto" class="heading" id="10.x.2.1_`brk`_and_`sbrk`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.x.2.1 <code>brk</code> and <code>sbrk</code></h4><div class="heading-children"><div class="el-p"><p dir="auto">它们的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">brk</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>end_data_segment<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:
	1. end_data_segment: Pointer to the new end of the data segment. This value is interpreted as the new program break.
   
Return value: Returns 0 on success, otherwise -1 and errno is set to indicate the error.
*/</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token class-name">intptr_t</span> increment<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. increment: The amount by which to increase or decrease the program break. If the value is positive, the break is increased by increment bytes. If the value is negative, the break is decreased by increment bytes.
   
Return value: Returns the previous program break on success. On error, (void *) -1 is returned, and errno is set to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="10.x.2.2 `mmap`" dir="auto" class="heading" id="10.x.2.2_`mmap`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10.x.2.2 <code>mmap</code></h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>mmap</code> 我们在 IPC 章节已经介绍过，这里不在赘述。</p></div></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第x课 GNU/Linux Physical Memory Map in IA32" dir="auto" class="heading" id="第x课_GNU/Linux_Physical_Memory_Map_in_IA32"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第x课 GNU/Linux Physical Memory Map in IA32</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.1 物理内存和虚拟内存之间的映射" dir="auto" class="heading" id="x.1_物理内存和虚拟内存之间的映射"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1 物理内存和虚拟内存之间的映射</h3><div class="heading-children"><div class="el-p"><p dir="auto">在本阶段，我们一直讨论有关虚拟内存怎么实现、段、页等等，但是我们的讨论仿佛一直局限在用户程序。你有没有好奇过内核在哪里存放？内核代码也需要向用户代码那样按需分配么？本节课，我们就来回顾前面阶段的知识并探讨下一些重要又有趣的细节。</p></div><div class="el-p"><p dir="auto">i386采用二级页表</p></div><div class="el-p"><p dir="auto">CR3 Register用于存储页目录表的基地址。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.1 实模式" dir="auto" class="heading" id="x.1.1_实模式"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.1 实模式</h4><div class="heading-children"><div class="el-p"><p dir="auto">0-1M</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.2 内核内存映射" dir="auto" class="heading" id="x.1.2_内核内存映射"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.2 内核内存映射</h4><div class="heading-children"><div class="el-p"><p dir="auto">物理地址1M往上就是内核代码和数据，再往上就是内核分配的一些数据结构，用来存放页目录或管理物理内存的结构。在往上就是空闲的物理内存。在IA32上，虚拟内存大小为4GB，其中前面的0GB-3GB我们会将其划分给用户程序，将高地址的3GB-4GB划分给内核程序。Linux将内核的1GB内存分为两部分：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">低端地址是内核虚拟空间的低896MB，与物理内存<strong>一一映射</strong>；</li>
<li data-line="1" dir="auto">空闲的128MB是<strong>高端内存(High memory)</strong>，用来处理当物理内存大于896MB的情况。</li>
</ol></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">/* This file contains the definitions for memory management in our OS. */</span>

<span class="token comment">/* *
 *     Virtual memory map:
 *     4G ------------------&gt; +---------------------------------+ 0xFFFFFFFF
 *                            |         High Memory (*)         | 128M
 *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000
 *                            |    Remapped Physical Memory     | KMEMSIZE(896M)
 *                            |                                 |
 *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000(3G)
 *                            |        Invalid Memory (*)       | --/--
 *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000
 *                            |           User stack            |
 *                            +---------------------------------+
 *                            |                                 |
 *                            :                                 :
 *                            |         ~~~~~~~~~~~~~~~~        |
 *                            :                                 :
 *                            |                                 |
 *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                            |       User Program &amp; Heap       |
 *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000
 *                            |        Invalid Memory (*)       | --/--
 *                            |  - - - - - - - - - - - - - - -  |
 *                            |    User STAB Data (optional)    |
 *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000
 *                            |        Invalid Memory (*)       | --/--
 *     0 -------------------&gt; +---------------------------------+ 0x00000000
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.
 *
 *
 *    physical memory:
 *     4G -------------  ---&gt; +---------------------------------+ 0xFFFFFFFF
 *                            |           外设映射空间            |
 *                            |                                 |
 *     384M ----------------&gt; +---------------------------------+ 0x20000000
 *                            |           空闲内存~382M          |
 *                            |                                 |
 *     pages end -----------&gt; +---------------------------------+ pages end
 *                            |    npages*sizeof(struct Page)   | -- (768KB)
 *     kpgdir end ----------&gt; +---------------------------------+ kpgdir end
 *                            |           kern_pgdir            | -- PGSIZE
 *     bss end -------------&gt; +---------------------------------+ bss end
 *                            |           kernel code           |
 *     1M ------------------&gt; +---------------------------------+ 0x00100000
 *                            |           BIOS ROM              |
 *     960KB ---------------&gt; +---------------------------------+ 0x000F0000
 *                            |           16位外设,扩展ROMS       |
 *     768KB ---------------&gt; +---------------------------------+ 0x000C0000
 *                            |           VGA显示缓存            |
 *     640KB ---------------&gt; +---------------------------------+ 0x000A0000
 *                            |           bootloader            |
 *     0  ------------------&gt; +---------------------------------+ 0x00000000
 *
 * */</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">由于是一一映射的方式，内核的虚拟地址减去<code>KERNBASE</code>就可以得到内核的物理地址了，方便内核对实际的内核物理内存进行管理。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240924020957.png" src="Pasted image 20240924020957.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240924020957.png" src="congzhi's-os-series/pics/pasted-image-20240924020957.png"></span></p></div><div class="el-p"><p dir="auto">而对用户程序的地址空间会根据用户程序的情况把内存与物理内存空间进行映射。</p></div><div class="el-p"><p dir="auto">--- 如何知道某个物理页可以释放？页结构体中有一项 <code>uint_16t pp_ref;</code> 表示当前页有多少个虚拟内存映射到该页代表的物理内存页。当 <code>pp_ref</code> 为0时就代表该页可以释放掉了。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240924021026.png" src="Pasted image 20240924021026.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240924021026.png" src="congzhi's-os-series/pics/pasted-image-20240924021026.png"></span></p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240924023629.png" src="Pasted image 20240924023629.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240924023629.png" src="congzhi's-os-series/pics/pasted-image-20240924023629.png"></span></p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.x `mm_struct` and `vm_area_struct`" dir="auto" class="heading" id="1.x_`mm_struct`_and_`vm_area_struct`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.x <code>mm_struct</code> and <code>vm_area_struct</code></h3><div class="heading-children"><div class="el-p"><p dir="auto">在进程控制块 <code>task_struct</code> 中，我们有 <code>mm_struct</code>，它是一个描述进程内存管理信息的数据结构，用来管理用户进程的虚拟地址空间。<code>mm_struct</code> 包含了进程的地址空间信息，包括代码段、数据段、堆、栈等。它还包含了与内存管理相关的其他信息，如页表、内存映射等。</p></div><div class="el-p"><p dir="auto">而在用户区的所有段，操作系统都会为其建立一个 <code>vm_area_struct</code>，存放在 <code>mm_struct</code> 中的 <code>mmap</code> 链表中，这是一个描述进程虚拟内存区域的数据结构。<code>vm_area_struct</code> 包含了虚拟内存区域的起始地址、结束地址、权限等信息。</p></div><div class="el-p"><p dir="auto">对于有些数据，<code>vm_area_struct</code> 会和实际的物理内存建立映射。而如一次性申请 1GB 的堆内存时，操作系统只会分配一个 <code>vm_area_struct</code> 结构体，并不会立马与实际的物理内存建立映射关系。只有当使用时才会与物理内存建立映射关系（缺页异常并建立映射）。</p></div><div class="el-p"><p dir="auto">此外，<code>mm_struct</code> 中还有一个 <code>mmap_cache</code> 字段，用于缓存最近访问的虚拟内存区域，以提高内存访问的效率。</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#12. Memory Management"><div class="tree-item-contents heading-link" heading-name="
Memory Management
"><span class="tree-item-title">Memory Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第零课_南大ICS先导课"><div class="tree-item-contents heading-link" heading-name="第零课 南大ICS先导课"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第零课 南大ICS先导课</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.1_Organization_of_Memory"><div class="tree-item-contents heading-link" heading-name="0.1 Organization of Memory"><span class="tree-item-title">0.1 Organization of Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.2_Memory_Hierarchy"><div class="tree-item-contents heading-link" heading-name="0.2 Memory Hierarchy"><span class="tree-item-title">0.2 Memory Hierarchy</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3_Virtual_Memory"><div class="tree-item-contents heading-link" heading-name="0.3 Virtual Memory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">0.3 Virtual Memory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.1_Memory_Management_in_Early_Time"><div class="tree-item-contents heading-link" heading-name="0.3.1 Memory Management in Early Time"><span class="tree-item-title">0.3.1 Memory Management in Early Time</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.2_Paging_Management"><div class="tree-item-contents heading-link" heading-name="0.3.2 Paging Management"><span class="tree-item-title">0.3.2 Paging Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.3_Virtual_Memory_and_Virtual_Space"><div class="tree-item-contents heading-link" heading-name="0.3.3 Virtual Memory and Virtual Space"><span class="tree-item-title">0.3.3 Virtual Memory and Virtual Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.4_Paging_Management_Implementation"><div class="tree-item-contents heading-link" heading-name="0.3.4 Paging Management Implementation"><span class="tree-item-title">0.3.4 Paging Management Implementation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.5_Segmentation"><div class="tree-item-contents heading-link" heading-name="0.3.5 Segmentation"><span class="tree-item-title">0.3.5 Segmentation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#0.3.6_Segmented_Paging_Management"><div class="tree-item-contents heading-link" heading-name="0.3.6 Segmented Paging Management"><span class="tree-item-title">0.3.6 Segmented Paging Management</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第一课_Main_Memory_Management"><div class="tree-item-contents heading-link" heading-name="第一课 Main Memory Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课 Main Memory Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.1_Physical_Address_and_Logical_Address"><div class="tree-item-contents heading-link" heading-name="1.1 Physical Address and Logical Address"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Physical Address and Logical Address</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.1.1_Main_Memory"><div class="tree-item-contents heading-link" heading-name="1.1.1 Main Memory"><span class="tree-item-title">1.1.1 Main Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.1.2_Physical_Address"><div class="tree-item-contents heading-link" heading-name="1.1.2 Physical Address"><span class="tree-item-title">1.1.2 Physical Address</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.1.3_Logical_Address"><div class="tree-item-contents heading-link" heading-name="1.1.3 Logical Address"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.3 Logical Address</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.1.3.1_Relative_Address"><div class="tree-item-contents heading-link" heading-name="1.1.3.1 Relative Address"><span class="tree-item-title">1.1.3.1 Relative Address</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第二课_Address_Conversion"><div class="tree-item-contents heading-link" heading-name="第二课 Address Conversion"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 Address Conversion</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.1_How_Program_is_Loaded"><div class="tree-item-contents heading-link" heading-name="2.1 How Program is Loaded"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.1 How Program is Loaded</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.1.1_Assembly_Code_Example"><div class="tree-item-contents heading-link" heading-name="2.1.1 Assembly Code Example"><span class="tree-item-title">2.1.1 Assembly Code Example</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.2_When_does_Address_Conversion_Happen?"><div class="tree-item-contents heading-link" heading-name="2.2 When does Address Conversion Happen?"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2 When does Address Conversion Happen?</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.2.1_Link-Time_Conversion"><div class="tree-item-contents heading-link" heading-name="2.2.1 Link-Time Conversion"><span class="tree-item-title">2.2.1 Link-Time Conversion</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.2.2_Load-Time_Conversion"><div class="tree-item-contents heading-link" heading-name="2.2.2 Load-Time Conversion"><span class="tree-item-title">2.2.2 Load-Time Conversion</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.2.3_Run-time_Conversion"><div class="tree-item-contents heading-link" heading-name="2.2.3 Run-time Conversion"><span class="tree-item-title">2.2.3 Run-time Conversion</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#2.2.4_Logic_Address_to_Virtual_Address"><div class="tree-item-contents heading-link" heading-name="2.2.4 Logic Address to Virtual Address"><span class="tree-item-title">2.2.4 Logic Address to Virtual Address</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第三课_Base_and_Bound"><div class="tree-item-contents heading-link" heading-name="第三课 Base and Bound"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Base and Bound</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#3.1_Memory_Management_Unit"><div class="tree-item-contents heading-link" heading-name="3.1 Memory Management Unit"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 Memory Management Unit</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#3.1.1_Base_and_Bound"><div class="tree-item-contents heading-link" heading-name="3.1.1 Base and Bound"><span class="tree-item-title">3.1.1 Base and Bound</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第四课_Contiguous_Memory_Allocation"><div class="tree-item-contents heading-link" heading-name="第四课 Contiguous Memory Allocation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第四课 Contiguous Memory Allocation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1_Fixed_Size_Partitioning"><div class="tree-item-contents heading-link" heading-name="4.1 Fixed Size Partitioning"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1 Fixed Size Partitioning</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1.1_Memory_Allocation_and_Deallocation"><div class="tree-item-contents heading-link" heading-name="4.1.1 Memory Allocation and Deallocation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1.1 Memory Allocation and Deallocation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1.1.1_Memory_Allocation"><div class="tree-item-contents heading-link" heading-name="4.1.1.1 Memory Allocation"><span class="tree-item-title">4.1.1.1 Memory Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1.1.2_Memory_Deallocation"><div class="tree-item-contents heading-link" heading-name="4.1.1.2 Memory Deallocation"><span class="tree-item-title">4.1.1.2 Memory Deallocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1.2_Address_Conversion_and_Protection"><div class="tree-item-contents heading-link" heading-name="4.1.2 Address Conversion and Protection"><span class="tree-item-title">4.1.2 Address Conversion and Protection</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.1.3_Trade-Offs"><div class="tree-item-contents heading-link" heading-name="4.1.3 Trade-Offs"><span class="tree-item-title">4.1.3 Trade-Offs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2_Variable_Size_Partitioning"><div class="tree-item-contents heading-link" heading-name="4.2 Variable Size Partitioning"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2 Variable Size Partitioning</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.1_Memory_Allocation_and_Deallocation"><div class="tree-item-contents heading-link" heading-name="4.2.1 Memory Allocation and Deallocation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2.1 Memory Allocation and Deallocation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.1.1_Allocation"><div class="tree-item-contents heading-link" heading-name="4.2.1.1 Allocation"><span class="tree-item-title">4.2.1.1 Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.1.2_Deallocation"><div class="tree-item-contents heading-link" heading-name="4.2.1.2 Deallocation"><span class="tree-item-title">4.2.1.2 Deallocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.2_Memory_Conversion_and_Protection"><div class="tree-item-contents heading-link" heading-name="4.2.2 Memory Conversion and Protection"><span class="tree-item-title">4.2.2 Memory Conversion and Protection</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3_Trade-Offs"><div class="tree-item-contents heading-link" heading-name="4.2.3 Trade-Offs"><span class="tree-item-title">4.2.3 Trade-Offs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.3_Allocation_Algorithms"><div class="tree-item-contents heading-link" heading-name="4.3 Allocation Algorithms"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.3 Allocation Algorithms</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3.1_First_Fit"><div class="tree-item-contents heading-link" heading-name="4.2.3.1 First Fit"><span class="tree-item-title">4.2.3.1 First Fit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3.2_Next_Fit"><div class="tree-item-contents heading-link" heading-name="4.2.3.2 Next Fit"><span class="tree-item-title">4.2.3.2 Next Fit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3.3_Best_Fit"><div class="tree-item-contents heading-link" heading-name="4.2.3.3 Best Fit"><span class="tree-item-title">4.2.3.3 Best Fit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3.4_Worst_Fit"><div class="tree-item-contents heading-link" heading-name="4.2.3.4 Worst Fit"><span class="tree-item-title">4.2.3.4 Worst Fit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.3.5_Quick_Fit"><div class="tree-item-contents heading-link" heading-name="4.2.3.5 Quick Fit"><span class="tree-item-title">4.2.3.5 Quick Fit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.2.4_可变分区和空间利用技术"><div class="tree-item-contents heading-link" heading-name="4.2.4 可变分区和空间利用技术"><span class="tree-item-title">4.2.4 可变分区和空间利用技术</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#4.3_Binary_Buddy_System"><div class="tree-item-contents heading-link" heading-name="4.3 Binary Buddy System"><span class="tree-item-title">4.3 Binary Buddy System</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第五课_Segmentation"><div class="tree-item-contents heading-link" heading-name="第五课 Segmentation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第五课 Segmentation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#5.1_Allocation_and_Deallocation"><div class="tree-item-contents heading-link" heading-name="5.1 Allocation and Deallocation"><span class="tree-item-title">5.1 Allocation and Deallocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#5.2_Conversion_and_Protection"><div class="tree-item-contents heading-link" heading-name="5.2 Conversion and Protection"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.2 Conversion and Protection</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#5.2.1_Conversion"><div class="tree-item-contents heading-link" heading-name="5.2.1 Conversion"><span class="tree-item-title">5.2.1 Conversion</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#5.2.2_Protection"><div class="tree-item-contents heading-link" heading-name="5.2.2 Protection"><span class="tree-item-title">5.2.2 Protection</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#5.3_Trade-Offs"><div class="tree-item-contents heading-link" heading-name="5.3 Trade-Offs"><span class="tree-item-title">5.3 Trade-Offs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第六课_Paging"><div class="tree-item-contents heading-link" heading-name="第六课 Paging"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第六课 Paging</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.1_Page_Table"><div class="tree-item-contents heading-link" heading-name="6.1 Page Table"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.1 Page Table</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.1.1_Page_Table_Entry"><div class="tree-item-contents heading-link" heading-name="6.1.1 Page Table Entry"><span class="tree-item-title">6.1.1 Page Table Entry</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.2_页式存储管理方式的开销"><div class="tree-item-contents heading-link" heading-name="6.2 页式存储管理方式的开销"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2 页式存储管理方式的开销</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.2.1_页表存储开销"><div class="tree-item-contents heading-link" heading-name="6.2.1 页表存储开销"><span class="tree-item-title">6.2.1 页表存储开销</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.2.2_页表查询开销"><div class="tree-item-contents heading-link" heading-name="6.2.2 页表查询开销"><span class="tree-item-title">6.2.2 页表查询开销</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.3_页的分配和回收"><div class="tree-item-contents heading-link" heading-name="6.3 页的分配和回收"><span class="tree-item-title">6.3 页的分配和回收</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.4_地址转换和保护"><div class="tree-item-contents heading-link" heading-name="6.4 地址转换和保护"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.4 地址转换和保护</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.4.1_地址转换"><div class="tree-item-contents heading-link" heading-name="6.4.1 地址转换"><span class="tree-item-title">6.4.1 地址转换</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.4.2_内存保护"><div class="tree-item-contents heading-link" heading-name="6.4.2 内存保护"><span class="tree-item-title">6.4.2 内存保护</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.4.3_页的重用"><div class="tree-item-contents heading-link" heading-name="6.4.3 页的重用"><span class="tree-item-title">6.4.3 页的重用</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.5_Memory_Management_on_64-bits_Machine"><div class="tree-item-contents heading-link" heading-name="6.5 Memory Management on 64-bits Machine"><span class="tree-item-title">6.5 Memory Management on 64-bits Machine</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#6.6_Tradeoffs"><div class="tree-item-contents heading-link" heading-name="6.6 Tradeoffs"><span class="tree-item-title">6.6 Tradeoffs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第七课_Translation_Lookaside_Buffer"><div class="tree-item-contents heading-link" heading-name="第七课 Translation Lookaside Buffer"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第七课 Translation Lookaside Buffer</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#7.1_TLB"><div class="tree-item-contents heading-link" heading-name="7.1 TLB"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1 TLB</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#7.1.1_Hit_Ratio"><div class="tree-item-contents heading-link" heading-name="7.1.1 Hit Ratio"><span class="tree-item-title">7.1.1 Hit Ratio</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#7.1.2_TLB的缺点"><div class="tree-item-contents heading-link" heading-name="7.1.2 TLB的缺点"><span class="tree-item-title">7.1.2 TLB的缺点</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第八课_Multi-Level_Page_Tables"><div class="tree-item-contents heading-link" heading-name="第八课 Multi-Level Page Tables"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第八课 Multi-Level Page Tables</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.1_Back_to_Dark_Ages"><div class="tree-item-contents heading-link" heading-name="8.1 Back to Dark Ages"><span class="tree-item-title">8.1 Back to Dark Ages</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.2_Page_Table_PAGE"><div class="tree-item-contents heading-link" heading-name="8.2 Page Table PAGE"><span class="tree-item-title">8.2 Page Table PAGE</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.3_Multi-Level_Page_Tables"><div class="tree-item-contents heading-link" heading-name="8.3 Multi-Level Page Tables"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.3 Multi-Level Page Tables</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.3.1_Two-Level_Page_Table"><div class="tree-item-contents heading-link" heading-name="8.3.1 Two-Level Page Table"><span class="tree-item-title">8.3.1 Two-Level Page Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.3.2_四级页表"><div class="tree-item-contents heading-link" heading-name="8.3.2 四级页表"><span class="tree-item-title">8.3.2 四级页表</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#8.3.3_Tradeoffs"><div class="tree-item-contents heading-link" heading-name="8.3.3 Tradeoffs"><span class="tree-item-title">8.3.3 Tradeoffs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第九课_Caching/Buffering"><div class="tree-item-contents heading-link" heading-name="第九课 Caching/Buffering"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第九课 Caching/Buffering</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.1_Locality_of_Reference"><div class="tree-item-contents heading-link" heading-name="9.1 Locality of Reference"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.1 Locality of Reference</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.1.1_Temporal_Locality"><div class="tree-item-contents heading-link" heading-name="9.1.1 Temporal Locality"><span class="tree-item-title">9.1.1 Temporal Locality</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.1.2_Spatial_Locality"><div class="tree-item-contents heading-link" heading-name="9.1.2 Spatial Locality"><span class="tree-item-title">9.1.2 Spatial Locality</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.2_Memory_Hierarchy"><div class="tree-item-contents heading-link" heading-name="9.2 Memory Hierarchy"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.2 Memory Hierarchy</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.2.1_Page_Fault"><div class="tree-item-contents heading-link" heading-name="9.2.1 Page Fault"><span class="tree-item-title">9.2.1 Page Fault</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.2.2_Replacement_Policy"><div class="tree-item-contents heading-link" heading-name="9.2.2 Replacement Policy"><span class="tree-item-title">9.2.2 Replacement Policy</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.2.3_Write_Policy"><div class="tree-item-contents heading-link" heading-name="9.2.3 Write Policy"><span class="tree-item-title">9.2.3 Write Policy</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3_Page_Replacement_Algorithms"><div class="tree-item-contents heading-link" heading-name="9.3 Page Replacement Algorithms"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.3 Page Replacement Algorithms</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.1_First-In,_First-Out"><div class="tree-item-contents heading-link" heading-name="9.3.1 First-In, First-Out"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.3.1 First-In, First-Out</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.1.1_Bélády's_Anomaly"><div class="tree-item-contents heading-link" heading-name="9.3.1.1 Bélády's Anomaly"><span class="tree-item-title">9.3.1.1 Bélády's Anomaly</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.1.2_FIFO算法优缺点"><div class="tree-item-contents heading-link" heading-name="9.3.1.2 FIFO算法优缺点"><span class="tree-item-title">9.3.1.2 FIFO算法优缺点</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.2_CLOCK/Second_Chance_Algorithm"><div class="tree-item-contents heading-link" heading-name="9.3.2 CLOCK/Second Chance Algorithm"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.3.2 CLOCK/Second Chance Algorithm</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.2.1_CLOCK+_Algorithm"><div class="tree-item-contents heading-link" heading-name="9.3.2.1 CLOCK+ Algorithm"><span class="tree-item-title">9.3.2.1 CLOCK+ Algorithm</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.3_Optimal_Page_Replacement_Algorithm_(Bélády's_Algorithm)"><div class="tree-item-contents heading-link" heading-name="9.3.3 Optimal Page Replacement Algorithm (Bélády's Algorithm)"><span class="tree-item-title">9.3.3 Optimal Page Replacement Algorithm (Bélády's Algorithm)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.4_Least_Recently_Used"><div class="tree-item-contents heading-link" heading-name="9.3.4 Least Recently Used"><span class="tree-item-title">9.3.4 Least Recently Used</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.5_Less_Frequently_Used"><div class="tree-item-contents heading-link" heading-name="9.3.5 Less Frequently Used"><span class="tree-item-title">9.3.5 Less Frequently Used</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.6_Not_Frequently_Used"><div class="tree-item-contents heading-link" heading-name="9.3.6 Not Frequently Used"><span class="tree-item-title">9.3.6 Not Frequently Used</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.7_NFU_+_Aging"><div class="tree-item-contents heading-link" heading-name="9.3.7 NFU + Aging"><span class="tree-item-title">9.3.7 NFU + Aging</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#9.3.8_ARC"><div class="tree-item-contents heading-link" heading-name="9.3.8 ARC"><span class="tree-item-title">9.3.8 ARC</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第十课_Virtual_Memory"><div class="tree-item-contents heading-link" heading-name="第十课 Virtual Memory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第十课 Virtual Memory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.1_Reviewing:_Ideas_of_Virtual_Memory"><div class="tree-item-contents heading-link" heading-name="10.1 Reviewing: Ideas of Virtual Memory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.1 Reviewing: Ideas of Virtual Memory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.1.2_Virtual_Memory"><div class="tree-item-contents heading-link" heading-name="10.1.2 Virtual Memory"><span class="tree-item-title">10.1.2 Virtual Memory</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.1.3_Demand_Paging"><div class="tree-item-contents heading-link" heading-name="10.1.3 Demand Paging"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.1.3 Demand Paging</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.1.3.1_Lazy_Approach"><div class="tree-item-contents heading-link" heading-name="10.1.3.1 Lazy Approach"><span class="tree-item-title">10.1.3.1 Lazy Approach</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.1.3.2_HHDs_and_SSDs"><div class="tree-item-contents heading-link" heading-name="10.1.3.2 HHDs and SSDs"><span class="tree-item-title">10.1.3.2 HHDs and SSDs</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2_Thrashing"><div class="tree-item-contents heading-link" heading-name="10.2 Thrashing"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.2 Thrashing</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2.1_影响抖动的因素"><div class="tree-item-contents heading-link" heading-name="10.2.1 影响抖动的因素"><span class="tree-item-title">10.2.1 影响抖动的因素</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2.2_Frame_Allocation_Strategies"><div class="tree-item-contents heading-link" heading-name="10.2.2 Frame Allocation Strategies"><span class="tree-item-title">10.2.2 Frame Allocation Strategies</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2.3_Local_and_Global_Page_Replacement"><div class="tree-item-contents heading-link" heading-name="10.2.3 Local and Global Page Replacement"><span class="tree-item-title">10.2.3 Local and Global Page Replacement</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2.4_Paging_Strategies"><div class="tree-item-contents heading-link" heading-name="10.2.4 Paging Strategies"><span class="tree-item-title">10.2.4 Paging Strategies</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.2.5_Page_Replacement_Algorithms"><div class="tree-item-contents heading-link" heading-name="10.2.5 Page Replacement Algorithms"><span class="tree-item-title">10.2.5 Page Replacement Algorithms</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.3_防止抖动的策略"><div class="tree-item-contents heading-link" heading-name="10.3 防止抖动的策略"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.3 防止抖动的策略</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.3.1_Working-Set_Model"><div class="tree-item-contents heading-link" heading-name="10.3.1 Working-Set Model"><span class="tree-item-title">10.3.1 Working-Set Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.3.2_Page_Fault_Frequency"><div class="tree-item-contents heading-link" heading-name="10.3.2 Page Fault Frequency"><span class="tree-item-title">10.3.2 Page Fault Frequency</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.x_Virtual_Memory_Allocation"><div class="tree-item-contents heading-link" heading-name="10.x Virtual Memory Allocation"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.x Virtual Memory Allocation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.x.1_Static_Memory_Allocation"><div class="tree-item-contents heading-link" heading-name="10.x.1 Static Memory Allocation"><span class="tree-item-title">10.x.1 Static Memory Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.x.2_Dynamic_Memory_Allocation"><div class="tree-item-contents heading-link" heading-name="10.x.2 Dynamic Memory Allocation"><span class="tree-item-title">10.x.2 Dynamic Memory Allocation</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.x.2.1_`brk`_and_`sbrk`"><div class="tree-item-contents heading-link" heading-name="10.x.2.1 `brk` and `sbrk`"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">10.x.2.1 <code>brk</code> and <code>sbrk</code></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#10.x.2.2_`mmap`"><div class="tree-item-contents heading-link" heading-name="10.x.2.2 `mmap`"><span class="tree-item-title">10.x.2.2 <code>mmap</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#第x课_GNU/Linux_Physical_Memory_Map_in_IA32"><div class="tree-item-contents heading-link" heading-name="第x课 GNU/Linux Physical Memory Map in IA32"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第x课 GNU/Linux Physical Memory Map in IA32</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#x.1_物理内存和虚拟内存之间的映射"><div class="tree-item-contents heading-link" heading-name="x.1 物理内存和虚拟内存之间的映射"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.1 物理内存和虚拟内存之间的映射</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#x.1.1_实模式"><div class="tree-item-contents heading-link" heading-name="x.1.1 实模式"><span class="tree-item-title">x.1.1 实模式</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#x.1.2_内核内存映射"><div class="tree-item-contents heading-link" heading-name="x.1.2 内核内存映射"><span class="tree-item-title">x.1.2 内核内存映射</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\12.-memory-management.html#1.x_`mm_struct`_and_`vm_area_struct`"><div class="tree-item-contents heading-link" heading-name="1.x `mm_struct` and `vm_area_struct`"><span class="tree-item-title">1.x <code>mm_struct</code> and <code>vm_area_struct</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>