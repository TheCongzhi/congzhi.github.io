<!DOCTYPE html> <html><head>
		<title>10. Synchronization and Mutex</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 10. Synchronization and Mutex">
		<meta property="og:title" content="10. Synchronization and Mutex">
		<meta property="og:description" content="Congzhi's Notes Vault - 10. Synchronization and Mutex">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/10.-synchronization-and-mutex.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/this_is_fine.jpg">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D457.TEX-I::before{padding:.661em .412em .204em 0;content:"j"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-mtext{display:inline-block;text-align:left}mjx-c.mjx-c44::before{padding:.683em .764em 0 0;content:"D"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c69::before{padding:.669em .278em 0 0;content:"i"}mjx-c.mjx-c6E::before{padding:.442em .556em 0 0;content:"n"}mjx-c.mjx-c20::before{padding:0 .25em 0 0;content:" "}mjx-c.mjx-c54::before{padding:.677em .722em 0 0;content:"T"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c2D::before{padding:.252em .333em 0 0;content:"-"}mjx-c.mjx-c43::before{padding:.705em .722em .021em 0;content:"C"}mjx-c.mjx-c75::before{padding:.442em .556em .011em 0;content:"u"}mjx-c.mjx-c72::before{padding:.442em .392em 0 0;content:"r"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c53::before{padding:.705em .556em .022em 0;content:"S"}mjx-c.mjx-c63::before{padding:.448em .444em .011em 0;content:"c"}mjx-c.mjx-c6B::before{padding:.694em .528em 0 0;content:"k"}mjx-c.mjx-c52::before{padding:.683em .736em .022em 0;content:"R"}mjx-c.mjx-c67::before{padding:.453em .5em .206em 0;content:"g"}mjx-c.mjx-c45::before{padding:.68em .681em 0 0;content:"E"}mjx-c.mjx-c78::before{padding:.431em .528em 0 0;content:"x"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c37::before{padding:.676em .5em .022em 0;content:"7"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c220F.TEX-S2::before{padding:.95em 1.278em .45em 0;content:"∏"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c2264::before{padding:.636em .778em .138em 0;content:"≤"}mjx-munderover{display:inline-block;text-align:left}mjx-munderover:not([limits=false]){padding-top:.1em}mjx-munderover:not([limits=false])>*{display:block}mjx-msubsup{display:inline-block;text-align:left}mjx-script{display:inline-block;padding-right:.05em;padding-left:.033em}mjx-script>mjx-spacer{display:block}mjx-c.mjx-c1D70F.TEX-I::before{padding:.431em .517em .013em 0;content:"τ"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c1D448.TEX-I::before{padding:.683em .767em .022em 0;content:"U"}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c3C::before{padding:.54em .778em .04em 0;content:"<"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msub{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D44A.TEX-I::before{padding:.683em 1.048em .022em 0;content:"W"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c1D444.TEX-I::before{padding:.704em .791em .194em 0;content:"Q"}mjx-c.mjx-c3E::before{padding:.54em .778em .04em 0;content:">"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="10. Synchronization and Mutex"><ol start="10">
<li dir="auto">Synchronization and Mutex</li>
</ol></h1><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="info" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></div><div class="callout-title-inner">第一遍重写中</div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第一课 Synchronization Problem" dir="auto" class="heading" id="第一课_Synchronization_Problem"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课 Synchronization Problem</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Concurrency is a Disaster" dir="auto" class="heading" id="1.1_Concurrency_is_a_Disaster"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Concurrency is a Disaster</h3><div class="heading-children"><div class="el-p"><p dir="auto">在之前的学习中，我们了解到许多并发给我们带来的诸多好处，如更好的资源利用率、更低的响应时间、更好的用户体验。但在享受这些便利的同时，并发还会为系统带来许多灾难。在设计系统的并发时，我们要考虑<strong>资源共享</strong>的问题，不当的程序可能会为系统带来<strong>条件竞争(Race condition)</strong>、<strong>饥饿和死锁</strong>。这些问题一定要在开始就规避掉，不然会酿成大祸。</p></div><div class="el-p"><p dir="auto"><span alt="this_is_fine.jpg" src="this_is_fine.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="this_is_fine.jpg" src="congzhi's-os-series/pics/this_is_fine.jpg"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 Synchronization" dir="auto" class="heading" id="1.1.1_Synchronization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 Synchronization</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>同步</strong>指通过协调多个并发线程（或进程）的执行，是他们能够安全的共享资源或进行通信。同步的目的是防止竞争、数据不一致和死锁等问题，从而保证系统的正确性和稳定性。我们下面先举两个例子展示不同的同步模式。</p></div><div class="el-p"><p dir="auto">在多核系统上，两个线程是有并行执行的能力的。但有时候，两个线程虽然可以同时执行，但是不可以同时访问某些资源，我们称这种情况为<strong>互相排斥的同步问题(mutual exclusion)</strong>。在之前的学习中，共享内存的访问就需要进行互斥的访问（虽然也需要serialization的同步）。</p></div><div class="el-p"><p dir="auto">还有另一种情况，两个线程的执行必须要有一定的顺序，比如B线程需要A线程执行完毕后才能执行或是两个线程交替着执行亦或是更复杂的情况。我们一律将这种情况称作<strong>serialization的同步问题</strong>。同样的，我们之前学习管道的进程间通讯方式就需要进行serialization的同步。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 Non-Deterministic Program and Heisenbug" dir="auto" class="heading" id="1.1.2_Non-Deterministic_Program_and_Heisenbug"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 Non-Deterministic Program and Heisenbug</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们很多写的简单测试程序都是确定性的程序，即我们在程序运行前我们就能知道输出是什么（比如简单的打印"Helloworld\n"）。但当程序涉及到并发时，我们的程序有时就不再是确定性的程序了，我们称之为<strong>不确定性程序(Non-deterministic program)</strong>。</p></div><div class="el-p"><p dir="auto">下面的C++程序就是不确定性的程序：</p></div><div class="el-pre"><pre class="language-none" tabindex="0"><code data-line="0" class="language-c++ language-none is-loaded">#include &lt;iostream&gt;
#include &lt;thread&gt;

int counter = 0;

int main(){
	std::thread newThread([](){
        for (int i = 0; i &lt; 10000000; i++){
            counter++; 
        }   
    });
	for(int i = 0; i &lt; 10000000; i++){
		counter++;
	}
    newThread.join();
	printf("I counted: %d\n", counting);
	return 0;
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这个程序很奇怪，当你打印结果，你会发现它的输出千奇百怪，总之就是不为<code>20000000</code>。为什么？虽然看上去并不需要同步，但高级语言中的<code>++</code>、<code>--</code>不仅仅只是看上去那么简单。这些指令被称为read-modify-write指令，你需要先读值、修改最后写回结果。造成这种情况完全是因为read-modify-write指令并不是一气呵成的。（两线程都先读，之后两线程先后写，会造成什么情况？）</p></div><div class="el-p"><p dir="auto">由这种不确定性引起的程序bug，我们将其戏称为<strong>Heisenbug</strong>（得名于 "Heisenberg Uncertainty Principle"）。这时，我们就需要对资源的操作进行 mutual exclusion 的同步操作。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.3 Resource Allocation and Executing Order" dir="auto" class="heading" id="1.1.3_Resource_Allocation_and_Executing_Order"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 Resource Allocation and Executing Order</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们现在明白，造成 Heisenbug 的主要原因在于资源的分配问题和执行顺序的控制问题。上边的程序中并发引起的 Heisenbug 就是由于单一资源分配不当导致的。当然，资源个数也可以有很多，这时要考虑的问题就会随着资源个数的增加而变得不同。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>单一资源</strong>：如果资源只有一个，多个并发进程都想访问它，则需要排队一个一个地访问资源，确保在同一时刻只能有一个进程访问该资源。</li>
<li data-line="1" dir="auto"><strong>多个资源</strong>：如果资源有多个，需要合理地分配资源给并发进程，防止出现资源多分配或资源未分配的情况。</li>
</ul></div><div class="el-p"><p dir="auto">对执行顺序的控制能够确保多个进程或线程按照预期的顺序执行，以满足特定的任务依赖关系和执行逻辑。对于这些非确定性程序，我们可以用一些同步工具来管理和控制资源或执行顺序。通过这些同步工具，我们能够有效防止竞态条件和资源冲突，确保系统的正确性和稳定性。但在此之前，我们有必要先了解一下临界区的管理。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 Critical Section Management" dir="auto" class="heading" id="第二课_Critical_Section_Management"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 Critical Section Management</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">在之前的示例中，我们发现程序的不确定性是由一条 read-modify-write 高级语言指令（如 <code>i++;</code>、<code>i--;</code>）引起的。为了避免数据竞争，我们只需要对这条指令进行管理即可。这也正是我们即将要学习的临界资源和临界区中所要关注的内容。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 Critical Resources and Critical Section" dir="auto" class="heading" id="2.1_Critical_Resources_and_Critical_Section"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 Critical Resources and Critical Section</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.1 Critical Resources" dir="auto" class="heading" id="2.1.1_Critical_Resources"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1 Critical Resources</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>临界资源</strong>是指那些在同一时刻只能被一个进程访问的<strong>共享资源</strong>，如共享内存、文件、打印机及其他系统互斥资源。对临界资源的访问必须是不可中断的。前面引起Heisenbug的C++程序中，那个全局变量就是需要互斥访问的临界资源。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.2 Critical Section" dir="auto" class="heading" id="2.1.2_Critical_Section"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.2 Critical Section</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>临界区</strong>就是并发线程（或进程）中访问了临界资源的一段代码。要使得系统运行稳定、规避并发带来的一系列问题，我们需要保证时刻只有一个进程在临界区内代码来避免出现竞争条件或是数据不一致现象。之前的例子中，<code>counter++;</code>就是对临界区的访问，这种情况下，我们的临界区可以划分的很小。</p></div><div class="el-pre"><pre class="language-none" tabindex="0"><code data-line="0" class="language-c++ language-none is-loaded">for(int i = 0; i &lt; 10000000; i++){
// Critical Section starts form here
	counter++;
// To here
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.3 A Real Example: Ticket Booking" dir="auto" class="heading" id="2.1.3_A_Real_Example:_Ticket_Booking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.3 A Real Example: Ticket Booking</h4><div class="heading-children"><div class="el-p"><p dir="auto">现实生活中，订票系统是我们身边较为常见的可能引起数据不一致的场景。我们通过 pthread 库给这个进程中生成了两个线程。我们共有两张票，两个线程都会 booking 一张票，因此我们期望进程执行后余票为0。但由于并发执行，两个线程在进入临界区时可能会导致数据的不一致性。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> ticket_amount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ticketAgent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> ticketAmount<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"One ticket sold\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		t<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Ticket sold out\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ticketAmount <span class="token operator">=</span> t<span class="token punctuation">;</span>
	<span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> agrv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">pthread_t</span> ticketAgent_tid<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">pthread_create</span><span class="token punctuation">(</span>ticketAgent_tid<span class="token operator">+</span>i<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> ticketAgent<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">pthread_join</span><span class="token punctuation">(</span>ticketAgent_tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The left ticket is %d\n"</span><span class="token punctuation">,</span> ticketAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">运行结果如下：</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240701005315.png" src="Pasted image 20240701005315.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240701005315.png" src="congzhi's-os-series/pics/pasted-image-20240701005315.png"></span></p></div><div class="el-p"><p dir="auto">代码执行后我们看到一些结果是正确的，还有一些执行中售出两张票但仍留了一张。这是因为并发线程交替执行”临界区“中的代码，在上面我们也提到了 <code>--</code> 这种 read-modify-write 指令。如此，并发执行会引起 Heisenbug 。对于这种情况，我们提出临界区管理的原则。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.4 Management Principles" dir="auto" class="heading" id="2.1.4_Management_Principles"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.4 Management Principles</h4><div class="heading-children"><div class="el-p"><p dir="auto">管理临界区的本质就是要对访问临界区的并发进程进行同步，要实现的目标有互斥、前进和有限等待。通过这些目标，我们能够在不同的同步模式下管理临界区并避免竟态条件和资源冲突所带来的一系列问题。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>互斥(Mutual Exclusion,Mutex)</strong>：同一时间只能有一个进程/线程进入临界区。</li>
<li data-line="1" dir="auto"><strong>前进(Progress)</strong>：进程/线程在持有锁的情况下才能执行临界区内的代码。</li>
<li data-line="2" dir="auto"><strong>有限等待(Bounded Waiting)</strong>：完成操作后释放锁，让其他线程有机会进入临界区。</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.2 The First Synchronous Tool: Mutex Lock" dir="auto" class="heading" id="2.2_The_First_Synchronous_Tool:_Mutex_Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 The First Synchronous Tool: Mutex Lock</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>互斥锁</strong>是由操作系统提供的临界区同步工具，可以保证临界区的管理目标要求。互斥锁的上锁、解锁操作是原子化的，因而保证了每次只会有一个进程/线程进入临界区。互斥锁的同步模型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">acquireLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//+--------------------+</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//|  critical section  |</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//+--------------------+</span>
<span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这段同步模型的伪代码中，我们满足了临界区管理的三大原则，即：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">进入临界区前请求锁（互斥），如果成功则上锁并进入临界区（前进），否则等待</li>
<li data-line="1" dir="auto">离开临界区后释放锁，让其他进程有机会进入临界区（有限等待）</li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2.1 Mutex Lock POSIX Brings" dir="auto" class="heading" id="2.2.1_Mutex_Lock_POSIX_Brings"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1 Mutex Lock POSIX Brings</h4><div class="heading-children"><div class="el-p"><p dir="auto">下面是一些POSIX系统提供的一些互斥锁的系统调用。相关操作有：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">;</span>
<span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">借助<code>pthread</code>库，我们就可以实现线程间的互斥。我们在 ticket booking 中加入互斥锁，如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> ticketAmout <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 票的数量: 全局变量</span>
<span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">;</span> <span class="token comment">// 定义互斥锁</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ticketAgent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 上锁</span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> ticketAmout<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"One ticket sold\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		t<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Ticket sold out\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ticketAmout <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span>
	<span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> agrv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">pthread_t</span> ticketAgent_tid<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 锁的初始化</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">pthread_create</span><span class="token punctuation">(</span>ticketAgent_tid<span class="token operator">+</span>i<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> ticketAgent<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">pthread_join</span><span class="token punctuation">(</span>ticketAgent_tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The left ticket is %d\n"</span><span class="token punctuation">,</span> ticketAmout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">观察输出，你会发现此时不会有资源共享问题导致的数据不一致性了。<strong>pthread库</strong>除了提供互斥锁，还有读写锁、<strong>自旋锁(Spin-lock)</strong> 等，这些都可以为我们临界区的管理提供同步的帮助。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Complementing a Lock" dir="auto" class="heading" id="第三课_Complementing_a_Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Complementing a Lock</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">从上节课的例子中，我们看到互斥锁的使用十分简单。借助 <code>pthread</code> 库，我们只需要定义并初始化一把锁，接着进行上锁、解锁和锁的摧毁操作即可。要实现互斥锁对临界区的管理，就需要满足互斥、前进、有限等待三个条件。本节课，带着对临界区的管理原则，我们来尝试实现一把锁。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 Complementing a Mutex Lock" dir="auto" class="heading" id="3.1_Complementing_a_Mutex_Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 Complementing a Mutex Lock</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.1 The First Try" dir="auto" class="heading" id="3.1.1_The_First_Try"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 The First Try</h4><div class="heading-children"><div class="el-p"><p dir="auto">在第一次尝试中，互斥锁并<strong>不满足互斥和有限等待的条件</strong>，因为测试和上锁并不是一气呵成的。因而，线程1和线程2可能同时通过测试并上锁，导致两个线程都认为自己获得了锁。此外，没有其他的条件分支，这个锁实际上并不能发挥其应有的作用。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">bool mutex_lock <span class="token operator">=</span> false<span class="token punctuation">;</span>

<span class="token function">lock</span><span class="token punctuation">(</span>mutex_lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>mutex_lock <span class="token operator">==</span> false<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// test</span>
		mutex_lock <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment">// lock</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//+--------------------+</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//|  critical section  |</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//+--------------------+</span>
<span class="token function">unlock</span><span class="token punctuation">(</span>mutex_lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mutex <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.2 The Second Try" dir="auto" class="heading" id="3.1.2_The_Second_Try"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.2 The Second Try</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了满足有限等待的条件，我们将判断嵌入到 <code>while</code> 循环中。如果线程2在进入循环时不满足  <code>mutex_lock = false</code> 的条件就会进入空循环，等待线程1解锁释放临界区资源。但是在第二次尝试中，测试和上锁仍然是分开的，<strong>不符合互斥的条件</strong>。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">bool mutex_lock <span class="token operator">=</span> false<span class="token punctuation">;</span>

<span class="token function">lock</span><span class="token punctuation">(</span>mutex_lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>mutex_lock <span class="token operator">!=</span> true<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// test</span>
		<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	mutex_lock <span class="token operator">=</span> true<span class="token punctuation">;</span>          <span class="token comment">// lock</span>
<span class="token punctuation">}</span>
<span class="token comment">//+--------------------+</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//|  critical section  |</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//+--------------------+</span>
<span class="token function">unlock</span><span class="token punctuation">(</span>mutex_lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mutex_lock <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.3 Atomic Operations" dir="auto" class="heading" id="3.1.3_Atomic_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.3 Atomic Operations</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了使得测试和上锁操作连贯且不可打断，我们需要引入<strong>原子操作</strong>的概念。原子操作就是在执行过程中需要一气呵成、不会分割、不能也不会被中断的操作。原子操作也称为原语，一般由硬件实现或系统提供。无论是什么原子操作，需要实现其原子性就离不了硬件平台的支持。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1.3.1 The Hardware's Got Your Back!" dir="auto" class="heading" id="3.1.3.1_The_Hardware's_Got_Your_Back!"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.3.1 The Hardware's Got Your Back!</h5><div class="heading-children"><div class="el-p"><p dir="auto">硬件支持的原子操作是由处理器提供的一些指令，确保这些操作在执行时不会被其他操作中断。下面列举了几个常见的硬件原子操作指令的实现：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Compare-and-Swap（比较并交换）</strong>：这个指令比较内存位置的值与给定的值，如果匹配，则将其更新为新值。常用于无锁编程中的互斥操作。CAS 实现大致是这样的：</li>
</ol></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// The atomic hardware instruction CAS would not be interrupted.</span>
bool <span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> old_val<span class="token punctuation">,</span> <span class="token keyword">int</span> new_val<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr <span class="token operator">==</span> old_val<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token operator">*</span>ptr <span class="token operator">=</span> new_val<span class="token punctuation">;</span>
		<span class="token keyword">return</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> false<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ol"><ol start="2">
<li data-line="0" dir="auto"><strong>Test-and-Set（测试并设置）</strong>：用于检查某个内存位置的值，并在检查的同时将其设置为新值。TS 指令的实现大致如下：</li>
</ol></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Same, wouldn't be interrupted</span>
<span class="token keyword">int</span> <span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> new_val<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_val <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
	<span class="token operator">*</span>ptr <span class="token operator">=</span> new_val<span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ol"><ol start="3">
<li data-line="0" dir="auto"><strong>Fetch-and-Add（取回并增加）</strong>：这个指令从内存位置取回一个值，并将其增加一个给定的值。多用于计数器递增操作，比如实现线程安全的计数器。</li>
</ol></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Same...</span>
<span class="token keyword">int</span> <span class="token function">fetch_and_add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> old_val <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
    <span class="token operator">*</span>ptr <span class="token operator">+=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">return</span> old_val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1.3.2 Standing on the Shoulders of Giants" dir="auto" class="heading" id="3.1.3.2_Standing_on_the_Shoulders_of_Giants"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.3.2 Standing on the Shoulders of Giants</h5><div class="heading-children"><div class="el-p"><p dir="auto">系统提供的原子操作主要通过操作系统和编程语言的库函数实现，来确保在多线程环境下操作的安全性。以下是一些常见的方法：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>Mutex（互斥锁）</strong>：互斥锁是一种用于保护临界区的机制，确保同一时间只有一个线程能够访问临界区代码。在POSIX线程库中，<code>pthread_mutex_lock</code>&nbsp;和&nbsp;<code>pthread_mutex_unlock</code>&nbsp;用于加锁和解锁。</li>
<li data-line="1" dir="auto"><strong>Spinlock（自旋锁）</strong>：自旋锁是一种简单的锁机制，线程在获取锁之前会一直循环检查锁的状态。常用于短时间持锁的情况，以减少线程上下文切换的开销。</li>
<li data-line="2" dir="auto"><strong>Atomic&nbsp;Variables（原子变量）</strong>：编程语言也提供原子变量和操作，保证变量的读写操作是原子的。例如，在C++中，可以使用 <code>std::atomic</code> 来定义原子变量，提供原子性的读写操作。</li>
</ul></div><div class="el-p"><p dir="auto">需要注意的是，系统所提供的这些原子性操作通常是通过对硬件封装所得的。如果硬件层面不支持原子操作，系统很难在不借助这些底层支持的情况下实现真正的原子性。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.4 The Third Try" dir="auto" class="heading" id="3.1.4_The_Third_Try"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.4 The Third Try</h4><div class="heading-children"><div class="el-p"><p dir="auto">用原子操作指令，我们能够完成一个如下的简易版 spinlock。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">//未上锁:0</span>
<span class="token comment">//已上锁:1</span>
bool mutex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> false<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//测试+上锁</span>
	<span class="token comment">//while(test_and_set(mutex, 1) == 1){</span>
		<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//+--------------------+</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//|  critical section  |</span>
<span class="token comment">//|                    |</span>
<span class="token comment">//+--------------------+</span>
<span class="token function">unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mutex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.2 Busy waiting" dir="auto" class="heading" id="3.2_Busy_waiting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 Busy waiting</h3><div class="heading-children"><div class="el-p"><p dir="auto">忙式等待是指一个进程或线程在等待某个条件满足时，不断地循环检查该条件是否满足的技术，这个循环等待的过程仍然在消耗CPU资源。我们本节课前面的互斥锁正是应用了这种技术，这类锁也称作<strong>自旋锁(SpinLocks)</strong>。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.1 Lemme Sleep" dir="auto" class="heading" id="3.2.1_Lemme_Sleep"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1 Lemme Sleep</h4><div class="heading-children"><div class="el-p"><p dir="auto">若进程请求锁时发现锁已不可用，那就让该进程或线程睡觉(阻塞/等待状态)，这样就不会消耗CPU来执行等待。但是，临界区中的进程离开临界区时在解锁操作中要唤醒之前等待的进程(从等待状态迁移到就绪状态)。上节课我们用到的 <code>pthread_mutex</code> 就是这类锁，即<strong>阻塞锁</strong>。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第四课 Mutex Lock and Spin-Lock" dir="auto" class="heading" id="第四课_Mutex_Lock_and_Spin-Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第四课 Mutex Lock and Spin-Lock</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">上节课我们简单地实现了自己的自旋锁，在课程末尾，我们提到了阻塞锁。我们实现自旋锁时的忙等待白白浪费CPU资源，这不是我们想要的。这节课，我们就来学习互斥锁。并比较两者的差别。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.1 `pthread_mutex`" dir="auto" class="heading" id="4.1_`pthread_mutex`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 <code>pthread_mutex</code></h3><div class="heading-children"><div class="el-p"><p dir="auto">POSIX 系统提供了<code>pthread_mutex</code>互斥锁来实现不同操作之间的互斥。我们之前也在课程中使用过<code>pthread_mutex</code>。当检查到互斥锁已经被其他线程所侵占时，线程就会阻塞自己，由于这种实现方式，互斥锁也被称作阻塞锁。</p></div><div class="el-p"><p dir="auto">下面是POSIX thread库中所提供的互斥锁的系统调用。我们最熟悉的是lock和unlock的系统调用，简单明了。当我们使用<code>pthread_mutex_lock()</code>时，这个函数会先检查锁是否可用，若是不可用就阻塞自己，锁可用后会向阻塞线程发送信号。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. mutex: Pointer to the mutex to lock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">如果你想实现一些条件分支，例如当锁不可用时怎么怎么办，pthread还提供trylock的逻辑。不同于mutex_lock，trylock并不会阻塞线程。当如果互斥锁已经被其他线程占有时trylock会返回错误码 <code>EBUSY</code>，表示锁当前不可用。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. mutex: Pointer to the mutex to try to lock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面是对锁的解锁操作。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:
	1. mutex: Pointer to the mutex to unlock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">说完了加锁和解锁，要使锁可用，锁的初始化和销毁是绕不开的点。使用<code>pthread_mutex_init()</code>我们可用将锁初始化为几种不同的状态。如果状态参数设置为NULL，那么就会使用默认的mutex类型，即<code>PTHREAD_MUTEX_DEFAULT</code>，行为未被定义。此外，我们还有其他的几种行为，如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_mutexattr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. mutex: Pointer to the mutex to initialize.
	2. attr: Pointer to a mutex attributes object, or NULL for default attributes.
	   - PTHREAD_MUTEX_NORMAL: Mutex relocking is not allowed,  will cause deadlock.
	   - PTHREAD_MUTEX_ERRORCHECK: Mutex relocking will return an error.
	   - PTHREAD_MUTEX_RECURSIVE: Allowing the same mutex relock multiple times.
	   - PTHREAD_MUTEX_DEFAULT: Default mutex, behavior undefined.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. mutex: Pointer to the mutex to destroy.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">一旦调用 <code>pthread_mutex_destroy()</code> 销毁了一个互斥锁，该互斥锁对象就不能再被使用了。销毁互斥锁会释放与该互斥锁相关的所有资源。如果在销毁后尝试使用该互斥锁，可能会导致未定义行为，甚至程序崩溃。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1.1 Mutex Don't Spin Around" dir="auto" class="heading" id="4.1.1_Mutex_Don't_Spin_Around"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1 Mutex Don't Spin Around</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//尝试使用CAS操作来获取锁</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">atomic_compare_and_swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//这是一个快速路径</span>
		<span class="token comment">//成功获取锁</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//锁已经被其他执行流占有，进入慢速路径(阻塞自己，省略实现)</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.2 `pthread_spinlock`" dir="auto" class="heading" id="4.2_`pthread_spinlock`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 <code>pthread_spinlock</code></h3><div class="heading-children"><div class="el-p"><p dir="auto">POSIX 系统也提供了 <code>pthread_spinlock</code> 自旋锁来实现不同操作之间的互斥。我们前面实现过自己的一个自旋锁。自旋锁在检查到锁已经被其他线程占用时，不会阻塞线程，而是会在一个循环中不断检查锁的状态，直到锁可用。下面是 POSIX thread 库中所提供的自旋锁的系统调用：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">pthread_spin_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. lock: Pointer to the spinlock to initialize.
	2. pshared: If non-zero, the spinlock is shared between processes; if zero, it is shared between threads of the same process.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_spin_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. lock: Pointer to the spinlock to destroy.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_spin_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. lock: Pointer to the spinlock to lock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_spin_trylock</span><span class="token punctuation">(</span><span class="token class-name">pthread_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. lock: Pointer to the spinlock to try to lock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_spin_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_spinlock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. lock: Pointer to the spinlock to unlock.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">自旋锁的系统调用和阻塞锁的系统调用很类似，唯一的差别就在于阻塞还是忙等待。你可能注意到初始化函数也有所不同，但是你实际上可以通过下面这种方式设置互斥锁的状态：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
<span class="token class-name">pthread_mutexattr_t</span> attr<span class="token punctuation">;</span>

<span class="token function">pthread_mutexattr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutexattr_setpshared</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_PROCESS_SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面是其函数原型：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_setpshared</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutexattr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. attr: Pointer to the mutex attributes object.
	2. pshared: The process-shared attribute. It can be set to:
	   - PTHREAD_PROCESS_SHARED: The mutex can be shared between processes.
	   - PTHREAD_PROCESS_PRIVATE: The mutex is shared only between threads of the same process.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.3 Mutex Lock vs. Spin-Lock" dir="auto" class="heading" id="4.3_Mutex_Lock_vs._Spin-Lock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 Mutex Lock vs. Spin-Lock</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.1 Testing Code for Mutex" dir="auto" class="heading" id="4.2.1_Testing_Code_for_Mutex"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 Testing Code for Mutex</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_ITERATIONS</span> <span class="token expression"><span class="token number">100000</span></span></span>

<span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mutex_thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_ITERATIONS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//Get mutex lock</span>
		counter<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Increase system load</span>
		<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Release the lock</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">timespec</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>

	<span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Initialize the lock</span>

	<span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Start time counting</span>

	<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> mutex_thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> mutex_thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Finish time counting</span>

	<span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//Destroy the lock</span>

	<span class="token keyword">double</span> elapsed <span class="token operator">=</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_sec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span> 
				   <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_nsec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_nsec<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Final counter value with pthread_mutex_t: %d\n"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elapsed time with pthread_mutex_t: %f\n"</span><span class="token punctuation">,</span>elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.2 Testing Code for Spinlock" dir="auto" class="heading" id="4.2.2_Testing_Code_for_Spinlock"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 Testing Code for Spinlock</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_ITERATIONS</span> <span class="token expression"><span class="token number">100000</span></span></span>

<span class="token class-name">pthread_spinlock_t</span> spinlock<span class="token punctuation">;</span>
<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mutex_thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_ITERATIONS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">pthread_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Get spin lock</span>
		counter<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Increase system load</span>
		<span class="token function">pthread_spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Release the lock</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">timespec</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>

	<span class="token function">pthread_spin_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock<span class="token punctuation">,</span> PTHREAD_PROCESS_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Initialize the lock</span>

	<span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Start time counting</span>

	<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> mutex_thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> mutex_thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//Finish time counting</span>

	<span class="token function">pthread_spin_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spinlock<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//Destroy the lock</span>

	<span class="token keyword">double</span> elapsed <span class="token operator">=</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_sec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span> 
				   <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_nsec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_nsec<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1e9</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Final counter value with pthread_spinlock_t: %d\n"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elapsed time with pthread_spinlock_t: %f\n"</span><span class="token punctuation">,</span>elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.3 No One's the Best" dir="auto" class="heading" id="4.2.3_No_One's_the_Best"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 No One's the Best</h4><div class="heading-children"><div class="el-p"><p dir="auto">运行的结果因机器而异，但这两种锁的实现方式决定了它们的特点。对于互斥锁而言，线程/进程切换的开销是其主要的开销；而对于自旋锁，忙等待让CPU空转是其主要的开销。我们知道，进程/线程的切换需要保存上下文信息，这需要一定的代价，从而，两种锁的比较就变成了空转的时间更长还是上下文切换的时间更长。</p></div><div class="el-p"><p dir="auto">不难想象，线程占有锁的时间越长，相比忙等待，线程切换的系统开销占比就会越小，这时mutex显然更优。但由于空循环忙等待的开销占比基本一成不变，当短时间持有锁时则 spinlock 更优。</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">特性</th>
<th dir="ltr">Mutex</th>
<th dir="ltr">Spinlock</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">基础结构</td>
<td dir="ltr"><code>pthread_mutex_t</code></td>
<td dir="ltr"><code>pthread_spinlock_t</code></td>
</tr>
<tr>
<td dir="ltr">加锁操作</td>
<td dir="ltr"><code>pthread_mutex_lock</code></td>
<td dir="ltr"><code>pthread_spin_lock</code></td>
</tr>
<tr>
<td dir="ltr">解锁操作</td>
<td dir="ltr"><code>pthread_mutex_unlock</code></td>
<td dir="ltr"><code>pthread_spin_unlock</code></td>
</tr>
<tr>
<td dir="ltr">等待机制</td>
<td dir="ltr">阻塞，进入内核态等待</td>
<td dir="ltr">自旋，忙等占用CPU资源</td>
</tr>
<tr>
<td dir="ltr">使用场景</td>
<td dir="ltr">长时间持有锁</td>
<td dir="ltr">短时间持有锁</td>
</tr>
<tr>
<td dir="ltr">性能</td>
<td dir="ltr">适合长时间等待，这时CPU利用率提高</td>
<td dir="ltr">适合短时间等待，免去上下文切换的开销</td>
</tr>
<tr>
<td dir="ltr">复杂度</td>
<td dir="ltr">较高，依赖 <code>mutex</code> 等系统调用</td>
<td dir="ltr">较低，基于原子操作实现</td>
</tr>
</tbody>
</table></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第五课 Peterson and Dekker" dir="auto" class="heading" id="第五课_Peterson_and_Dekker"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第五课 Peterson and Dekker</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">我们学过了临界区的管理原则有：<strong>互斥</strong>、<strong>前进</strong>、<strong>有限等待</strong>。在原子操作和互斥锁工具还没有被应用的时代，Dekker算法和Peterson算法就是当是两种为了解决临界区管理问题所应用的算法。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.1 Peterson Algorithm" dir="auto" class="heading" id="5.1_Peterson_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 Peterson Algorithm</h3><div class="heading-children"><div class="el-p"><p dir="auto">Peterson算法是软件解决管理临界区问题经典算法。它利用线程间访问共享资源的方式实现进程/线程间<strong>互斥</strong>访问<strong>临界区</strong>的算法。</p></div><div class="el-p"><p dir="auto">Peterson算法的伪代码如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">//Peterson算法的变量</span>
bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">,</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//flag[i]表示第i个线程/进程有进入临界区的意愿</span>
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>                      <span class="token comment">//turn的值j表示现在第j个值有进入临界区的令牌</span>

<span class="token comment">/*
当flag[i] &amp;&amp; turn == i,这时只有第i个进程才能进入临界区。实现了对临界区的管理
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">P0进程：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>  <span class="token comment">//P0a</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//P0b</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//busy wait</span>
<span class="token punctuation">}</span>
<span class="token comment">//start of critical section</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//end of critical section</span>

flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>               <span class="token comment">//unlock</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">P1进程：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>  <span class="token comment">//P1a</span>
turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//P1b</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//busy wait</span>
<span class="token punctuation">}</span>
<span class="token comment">//start of critical section</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//end of critical section</span>

flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>               <span class="token comment">//unlock</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1.1 Peterson Algorithm Processing Possibilities" dir="auto" class="heading" id="5.1.1_Peterson_Algorithm_Processing_Possibilities"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.1 Peterson Algorithm Processing Possibilities</h4><div class="heading-children"><div class="el-p"><p dir="auto">在算法执行时，由于进程的并发性，语句执行顺序及结构可能出现如下几种可能：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">flag[0]</th>
<th align="center" dir="ltr">flag[1]</th>
<th align="center" dir="ltr">turn</th>
<th align="center" dir="ltr">可能的执行顺序</th>
<th align="center" dir="ltr">最终执行</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr">true</td>
<td align="center" dir="ltr">false</td>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">P0a-P0b-(P1a-P1b)</td>
<td align="center" dir="ltr">P0</td>
</tr>
<tr>
<td align="center" dir="ltr">false</td>
<td align="center" dir="ltr">true</td>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">P1a-P1b-(P0a-P0b)</td>
<td align="center" dir="ltr">P1</td>
</tr>
<tr>
<td align="center" dir="ltr">true</td>
<td align="center" dir="ltr">ture</td>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">P0a-P1a-P0b-(P1b) / P1a-P0a-P0b-(P1b)</td>
<td align="center" dir="ltr">P1</td>
</tr>
<tr>
<td align="center" dir="ltr">true</td>
<td align="center" dir="ltr">true</td>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">P0a-P1a-P1b-(P0b) / P1a-P0a-P1b-(P0b)</td>
<td align="center" dir="ltr">P0</td>
</tr>
</tbody>
</table></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1.2 Peterson Summary" dir="auto" class="heading" id="5.1.2_Peterson_Summary"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.2 Peterson Summary</h4><div class="heading-children"><div class="el-p"><p dir="auto">Peterson 算法是一种不依赖硬件实现的原子操作机制。如今大多数CPU以指令乱序执行来提高执行效率，此时实现 Peterson 算法就得使用相关内存屏障指令。现在一般使用硬件支持的原子操作机制（比如 test-and-set 或 compare-and-swap），这些机制往往只需要很少的硬件支持。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.2 Dekker Algorithm" dir="auto" class="heading" id="5.2_Dekker_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 Dekker Algorithm</h3><div class="heading-children"><div class="el-p"><p dir="auto">和 Peterson 算法一样，Dekker 算法也是用进程间共享资源的方式实现进程间的互斥操作。同年 Dijkstra 提出信号量的概念也是受 Dekker 算法的影响。</p></div><div class="el-p"><p dir="auto">Dekker 算法的伪代码如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Dekker算法的变量</span>
bool wants_to_enter<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">,</span> false<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 表示进程是否想要进入临界区</span>
<span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 表示当前的优先权</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">进程P0：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// 进程P0</span>
wants_to_enter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment">//P0a</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>wants_to_enter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        wants_to_enter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 忙等待</span>
        <span class="token punctuation">}</span>
        wants_to_enter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 临界区</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
wants_to_enter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token comment">// 剩余部分</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">进程P1：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// 进程P1</span>
wants_to_enter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment">//P1a</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>wants_to_enter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        wants_to_enter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 忙等待</span>
        <span class="token punctuation">}</span>
        wants_to_enter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 临界区</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
wants_to_enter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token comment">// 剩余部分</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.2.1 Dekker Algorithm Processing Possibilities" dir="auto" class="heading" id="5.2.1_Dekker_Algorithm_Processing_Possibilities"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2.1 Dekker Algorithm Processing Possibilities</h4><div class="heading-children"><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">wte[0]</th>
<th align="center" dir="ltr">wte[1]</th>
<th align="center" dir="ltr">turn</th>
<th align="center" dir="ltr">最终执行</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr">true</td>
<td align="center" dir="ltr">false</td>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">P0</td>
</tr>
<tr>
<td align="center" dir="ltr">false</td>
<td align="center" dir="ltr">true</td>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">P1</td>
</tr>
<tr>
<td align="center" dir="ltr">true</td>
<td align="center" dir="ltr">ture</td>
<td align="center" dir="auto">0</td>
<td align="center" dir="ltr">P0</td>
</tr>
</tbody>
</table></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第六课 Semaphore and PV Operations (Since 1965)" dir="auto" class="heading" id="第六课_Semaphore_and_PV_Operations_(Since_1965)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第六课 Semaphore and PV Operations (Since 1965)</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.1 Basics" dir="auto" class="heading" id="6.1_Basics"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1 Basics</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>信号量</strong>概念最早由荷兰计算机科学家Edsger W. Dijkstra在1965年提出，是用与多线程环境下同步和互斥的一种机制。这个机制包含一个值和两个原子操作：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>信号量值</strong>：一个整数值</li>
<li data-line="1" dir="auto"><strong>P操作</strong>：荷兰语 Proberen，意为“测试”，也称为 <strong>wait 操作</strong>。</li>
<li data-line="2" dir="auto"><strong>V操作</strong>：荷兰语 Verhogen，意为”增加“，也称为 <strong>post/signal 操作</strong>。</li>
</ul></div><div class="el-p"><p dir="auto">信号量是一种比互斥锁更强大的同步工具，它的引入极大地简化了复杂的并发控制问题，使得操作系统和并发编程中的资源管理变得更有效和可靠。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.2 PV Operations" dir="auto" class="heading" id="6.2_PV_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2 PV Operations</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="6.2.1 Busy Waiting" dir="auto" class="heading" id="6.2.1_Busy_Waiting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.2.1 Busy Waiting</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果信号量只包含数值，且在数值不可用时实施忙式等待，那么就成这对PV操作为自旋PV操作。（也叫”整数信号量“）</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">semaphore sem<span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//busy waiting</span>
	<span class="token punctuation">}</span>
	s<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>
	s<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.3.2 Blocking PV" dir="auto" class="heading" id="6.3.2_Blocking_PV"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3.2 Blocking PV</h4><div class="heading-children"><div class="el-p"><p dir="auto">要消除自旋等待，我们可以把信号量打造成一个包含值和队列指针的结构体。具体思路如下：我们在执行P操作时，先判断数值是否可用，若不可用，利用进程指针将进程给阻塞掉。等到资源可用后，V操作在阻塞队列中再一个个地唤醒阻塞进程。这就是阻塞PV操作，也叫记录型信号量。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> value<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">process</span><span class="token operator">*</span> L<span class="token punctuation">;</span>
<span class="token punctuation">}</span>semaphore<span class="token punctuation">;</span>
semaphore sem<span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>value
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">block</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">wakeup</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.3 Blocking and Non-Blocking PV" dir="auto" class="heading" id="6.3_Blocking_and_Non-Blocking_PV"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.3 Blocking and Non-Blocking PV</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们假设有一个信号量s，它的初始值为1，我们还有3个并发进程 P1、P2、P3 都要对s先进行P操作，再进行V操作，下面是其中一种可能的顺序：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">操作</th>
<th align="center" dir="ltr">自旋PV操作</th>
<th align="center" dir="ltr">阻塞PV操作</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr">P1执行P操作</td>
<td align="center" dir="ltr"><code>s ← 0</code></td>
<td align="center" dir="ltr"><code>s ← 0</code></td>
</tr>
<tr>
<td align="center" dir="ltr">P2执行P操作</td>
<td align="center" dir="ltr">busy waiting</td>
<td align="center" dir="ltr"><code>s ← -1</code> and block P2</td>
</tr>
<tr>
<td align="center" dir="ltr">P3执行P操作</td>
<td align="center" dir="ltr">busy waiting</td>
<td align="center" dir="ltr"><code>s ← -2</code> and block P3</td>
</tr>
<tr>
<td align="center" dir="ltr">P1执行V操作</td>
<td align="center" dir="ltr"><code>s ← 1</code></td>
<td align="center" dir="ltr"><code>s ← -1</code> and unblock P2</td>
</tr>
<tr>
<td align="center" dir="ltr">P2被”唤醒“并执行</td>
<td align="center" dir="ltr">terminates waiting and <code>s ← 0</code></td>
<td align="center" dir="ltr">P2 running</td>
</tr>
<tr>
<td align="center" dir="ltr">P2执行V操作</td>
<td align="center" dir="ltr"><code>s ← 1</code></td>
<td align="center" dir="ltr"><code>s ← 0</code> and unblock P3</td>
</tr>
<tr>
<td align="center" dir="ltr">P3被“唤醒”并执行</td>
<td align="center" dir="ltr">terminates waiting and <code>s ← 0</code></td>
<td align="center" dir="ltr">P3 running</td>
</tr>
<tr>
<td align="center" dir="ltr">P3执行V操作</td>
<td align="center" dir="ltr"><code>s ← 1</code></td>
<td align="center" dir="ltr"><code>s ← 1</code></td>
</tr>
</tbody>
</table></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.4 Binary Semaphore" dir="auto" class="heading" id="6.4_Binary_Semaphore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4 Binary Semaphore</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="6.4.1 Mutual Exclusion based on Binary Semaphore" dir="auto" class="heading" id="6.4.1_Mutual_Exclusion_based_on_Binary_Semaphore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4.1 Mutual Exclusion based on Binary Semaphore</h4><div class="heading-children"><div class="el-p"><p dir="auto">从之前互斥锁实现中，我们已经学会如何使用“锁”来管理临界区，我们使用信号量和PV操作同样可以完成临界区管理的任务。以下我们给出一段伪代码：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

Thread n<span class="token operator">:</span>
	<span class="token comment">//其他代码</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//相当于lock</span>
	<span class="token comment">//+--------------------+</span>
	<span class="token comment">//|                    |</span>
	<span class="token comment">//|  critical section  |</span>
	<span class="token comment">//|                    |</span>
	<span class="token comment">//+--------------------+</span>
	<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//相当于unlock</span>
	<span class="token comment">//其他代码</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">结合上面的伪代码，很容易想明白当有多个进程并发地要访问临界区时，只有第一个执行P操作的进程能够进入临界区，并抢占这里的唯一的信号量资源。其他进程由于没有资源可以使用，因此只能自旋或阻塞等待释放临界区资源。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>初始状态</strong>：mutex = 1，临界区空闲，任何进程可以进入临界区。</li>
<li data-line="1" dir="auto"><strong>进程执行</strong>：某个进程执行了P(mutex)操作。信号量mutex减1变成0，此时临界区被占用</li>
<li data-line="2" dir="auto"><strong>线程离开临界区</strong>：返还临界区资源，mutex加1。其他进程可以进入临界区。</li>
</ul></div><div class="el-p"><p dir="auto">这种实现互斥的信号量初值总是1，它的值总是在0和1之间变化，因此被称作<strong>二值信号量</strong>。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.4.2 Synchronization Based on Binary Semaphore" dir="auto" class="heading" id="6.4.2_Synchronization_Based_on_Binary_Semaphore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.4.2 Synchronization Based on Binary Semaphore</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们知道，在计算机世界中由于并发进程执行是异步的。如果我们想要多个进程按照某个顺序执行要怎么办呢？我们可以利用PV操作实现这多个进程之间的同步。</p></div><div class="el-p"><p dir="auto">假设我们现在有两个进程P1和P2，P2需要在P1完成某些操作后才能继续执行任务，我们可以先定义一个名为sync的信号量，如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">semaphore sync <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//初始化为0，表示P2需要等待</span>

P1<span class="token operator">:</span>
	<span class="token comment">//其他代码</span>
	<span class="token comment">//执行P2需要等待的操作</span>
	<span class="token function">post</span><span class="token punctuation">(</span>sync<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//其他代码</span>
P2<span class="token operator">:</span>
	<span class="token comment">//其他代码</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>sync<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//等待P1相关操作执行完毕</span>
	<span class="token comment">//继续执行</span>
	<span class="token comment">//其他代码</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过上面的伪代码，我们不难看出，即使机器中的代码是异步执行的，但是P2相关操作还是可以同步等待P1相关操作的完成。不论大厨炒菜多么快速，他都需要等待菜全部切好才能开始炒菜，不然就可能导致不好的事情出现。</p></div><div class="el-p"><p dir="auto">这个例子中，不论是P1先执行还是P2先执行，没有P1进行V操作，P2就无法执行P操作从而继续执行其他代码。从这个例子中也能明白，我们同步的目标是保证P2在P1完成相关操作后才能继续执行。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.5 Resource Allocation Using Semaphore" dir="auto" class="heading" id="6.5_Resource_Allocation_Using_Semaphore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.5 Resource Allocation Using Semaphore</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们已经学习过如何用信号量实现同步和互斥，但是我们仍然有一种情况没有考虑到。如果在多进程系统中，并发的进程要同时访问共享资源呢？我们考虑以下几种情况：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">某类管理资源在同一时刻只允许一个进程使用（二值信号量实现的临界区互斥管理）</li>
<li data-line="1" dir="auto">对文件或数据库资源，可以某一时刻有多个进程同时读取甚至写入。</li>
<li data-line="2" dir="auto">资源较多，系统可以按进程的需求进行分配。</li>
</ol></div><div class="el-p"><p dir="auto">我们已经学过第一种情况的管理机制，那么底下的2、3情况呢？我们需要一种机制来防止资源竞争来确保系统的稳定性。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.5.1 Counting Semaphore" dir="auto" class="heading" id="6.5.1_Counting_Semaphore"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.5.1 Counting Semaphore</h4><div class="heading-children"><div class="el-p"><p dir="auto">计数信号量的初始值是一个非负整数，用于表示多个相同资源的可用数量。从这里，我们能看出二值信号量实际上是计数信号量的特殊情况，其中计数信号量的值只能是0或1。引入计数信号量扩展了对临界区资源数量大于1的情况的处理能力，使得多个线程可以同时访问多个相同的资源。</p></div><div class="el-p"><p dir="auto">例：假设系统中有3台打印机，多个进程都需要使用这些打印机，我们可以使用一个计数信号量来管理这3台打印机的申请和释放。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">semaphore printer <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

Process n<span class="token operator">:</span>
	<span class="token comment">//其他代码</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>printer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//+-----------------+</span>
	<span class="token comment">//|                 |</span>
	<span class="token comment">//|  using printer  |</span>
	<span class="token comment">//|                 |</span>
	<span class="token comment">//+-----------------+</span>
	<span class="token function">post</span><span class="token punctuation">(</span>printer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//其他代码</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>初始化信号量</strong>：信号量的初始值为3，表示系统中有3台可用的打印机。</li>
<li data-line="1" dir="auto"><strong>当进程需要使用打印机时，执行P操作</strong>。P操作会检查信号量的当前值，如果值大于0，则表示有可用的打印机，信号量值减1，进程获得使用打印机的权限。如果信号量值为0，表示没有可用的打印机，进程将等待，直到有打印机可用。</li>
<li data-line="2" dir="auto"><strong>当进程使用完打印机后，执行V操作</strong>。V操作会增加信号量的值，表示释放了一台打印机。如果有等待的进程，V操作将唤醒其中一个进程，使其可以继续执行。</li>
<li data-line="3" dir="auto"><strong>进程数量</strong>：当进程数量 ≤ 3 时，所有进程都可以同时使用打印机；当进程数量 &gt; 3 时，只有3个进程可以同时使用打印机，其他进程需要等待。</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.6 Comparison on Different Semaphores" dir="auto" class="heading" id="6.6_Comparison_on_Different_Semaphores"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.6 Comparison on Different Semaphores</h3><div class="heading-children"><div class="el-table" dir="auto" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="auto"></th>
<th align="center" dir="ltr">应用场景</th>
<th align="center" dir="ltr">初始值</th>
<th align="center" dir="ltr">PV操作</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr"><strong>二值信号量</strong></td>
<td align="center" dir="ltr">互斥、临界区管理</td>
<td align="center" dir="ltr">init_value = 1</td>
<td align="center" dir="ltr">同一进程</td>
</tr>
<tr>
<td align="center" dir="ltr"><strong>同步信号量</strong></td>
<td align="center" dir="ltr">进程执行顺序管理</td>
<td align="center" dir="ltr">init_value = 0</td>
<td align="center" dir="ltr">不同进程</td>
</tr>
<tr>
<td align="center" dir="ltr"><strong>计数信号量</strong></td>
<td align="center" dir="ltr">可用资源数量的申请释放管理</td>
<td align="center" dir="ltr">init_value ＞ 0</td>
<td align="center" dir="ltr">同一进程</td>
</tr>
</tbody>
</table></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6.7 System Call on Its Way" dir="auto" class="heading" id="6.7_System_Call_on_Its_Way"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7 System Call on Its Way</h3><div class="heading-children"><div class="el-p"><p dir="auto">POSIX标准提供了几个用于信号量（semaphore）的系统调用，这些调用可以用于进程或线程之间的同步。以下是几个主要的POSIX信号量系统调用：</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.1 sem_init" dir="auto" class="heading" id="6.7.1_sem_init"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.1 sem_init</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore to initialize.
	2. pshared: If non-zero, the semaphore is shared between processes; if zero, it is shared between threads of the same process.
	3. value: Initial value of the semaphore.

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.2 sem_destroy" dir="auto" class="heading" id="6.7.2_sem_destroy"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.2 sem_destroy</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore to destroy.

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.3 sem_wait" dir="auto" class="heading" id="6.7.3_sem_wait"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.3 sem_wait</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore to decrement (wait).

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.4 sem_trywait" dir="auto" class="heading" id="6.7.4_sem_trywait"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.4 sem_trywait</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore to decrement (try to wait).

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.5 sem_post" dir="auto" class="heading" id="6.7.5_sem_post"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.5 sem_post</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore to increment (signal).

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="6.7.6 sem_getvalue" dir="auto" class="heading" id="6.7.6_sem_getvalue"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.7.6 sem_getvalue</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. sem: Pointer to the semaphore.
	2. sval: Pointer to an integer to store the current value of the semaphore.

Return value: Returns 0 on success, -1 on failure and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第七课 Synchronization Patterns" dir="auto" class="heading" id="第七课_Synchronization_Patterns"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第七课 Synchronization Patterns</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="7.1 Simple Patterns" dir="auto" class="heading" id="7.1_Simple_Patterns"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1 Simple Patterns</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.1 Signaling" dir="auto" class="heading" id="7.1.1_Signaling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.1 Signaling</h4><div class="heading-children"><div class="el-p"><p dir="auto">之前我们学习二值信号量实现的同步中，我们实际上就已经接触了signaling的同步模式，相当于一个进程/线程对另一个进程/线程的等待。我们另外举一个例子，假如我们有信号量<code>sem</code>，初始化为0。通过信号量的PV操作，我们就能实现两个进程/线程之间的同步。</p></div><div class="el-p"><p dir="auto"><strong>Thread A</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement A1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Thread B</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement B1<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">上面的例子中，如果B线程开始执行，由于Statement A1并没有完成（信号量没有被post），所以线程B会被阻塞，等待信号量的释放。所以只要线程A调用<code>post(sem)</code>之后，线程B才会开始执行。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.2 Rendevous" dir="auto" class="heading" id="7.1.2_Rendevous"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2 Rendevous</h4><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.2.1 Two Threads Meet-up" dir="auto" class="heading" id="7.1.2.1_Two_Threads_Meet-up"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2.1 Two Threads Meet-up</h5><div class="heading-children"><div class="el-p"><p dir="auto">Rendezvous的同步模式是一种双向的同步模式，它相当于是对signaling的拓展。与signaling不同，rendezvous不仅仅是一个进程/线程在等待另一个进程/线程的信号，而是两个进程/线程彼此都在等待对方。因而，在这种同步模式中，我们需要两个信号量<code>sem1</code>和<code>sem2</code>并初始化为0。</p></div><div class="el-p"><p dir="auto"><strong>Thread A</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement A1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement A2<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Thread B</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement B1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement B2<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">上述的例子中，只有当线程A和线程B<strong>都走完</strong>Statement A1和Statement B1时，下一阶段的任务才会开始。这种双向同步确保了两个线程在特定的同步点上达成一致，然后才能继续各自的任务。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.1.2.2 Several Threads Meet-up" dir="auto" class="heading" id="7.1.2.2_Several_Threads_Meet-up"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.2.2 Several Threads Meet-up</h5><div class="heading-children"><div class="el-p"><p dir="auto">问题来了，如果线程的数量越来越多，会发生什么？如果线程数量不断增加，会导致同步和管理的复杂性显著增加。为了避免死锁，必须确保PV操作平衡，即每个<code>post</code>操作应有相应的<code>wait</code>操作。</p></div><div class="el-p"><p dir="auto">在有三个线程（A、B、C）的情况下，可以如下进行rendezvous的同步：</p></div><div class="el-p"><p dir="auto"><strong>Thread A</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement A1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement A2<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Thread B</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement B1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem3<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement B2<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Thread C</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">Statement C1<span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>sem3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>sem2<span class="token punctuation">)</span><span class="token punctuation">;</span>
Statement C2<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这种方式中，每个线程在执行完自己的第一部分工作后（Statement&nbsp;A1,&nbsp;B1,&nbsp;C1），分别<code>post</code>一个信号量并<code>wait</code>两个信号量。每个线程都在等待另外两个线程的信号，从而确保所有线程都在同步点相遇后才能继续执行剩余工作。</p></div><div class="el-p"><p dir="auto">虽然这种设计可以防止死锁，但随线程数量增加，同步复杂度和信号量的管理也会增加。为了简化管理和实现，我们可以使用一些更高级的同步原语或模式，我们将介绍的下一个同步模式屏障(barrier)就是为此而生的。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.3 Barrier Pattern" dir="auto" class="heading" id="7.1.3_Barrier_Pattern"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.3 Barrier Pattern</h4><div class="heading-children"><div class="el-p"><p dir="auto">屏障是多线程编程中用于同步多个线程执行进度的设计模式。它的核心思想是：强制所有的线程在某个预定义的点等待，直到所有线程都到达该点后，才能继续执行后续操作。比如在下面的伪代码中，我们有 N 个参与屏障同步的线程。</p></div><div class="el-p"><p dir="auto">每个线程到达时，<code>count</code> 都会 + 1。但最开始，这些线程会被阻塞掉，直到所有的 n 个线程都已就绪。随后我们有信号量 <code>barrier</code> 来控制线程的阻塞和唤醒。</p></div><div class="el-p"><p dir="auto"><strong>Thread N</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>
    count<span class="token operator">++</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>
<span class="token comment">// At this point, every thread will block here until count == n</span>
<span class="token keyword">if</span> count <span class="token operator">==</span> n
    <span class="token keyword">for</span> i from <span class="token number">1</span> to n
        <span class="token function">post</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span> <span class="token comment">// Unblock all threads waiting on the barrier</span>
    end <span class="token keyword">for</span>
end <span class="token keyword">if</span>
<span class="token function">wait</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span> <span class="token comment">// Each thread waits on the barrier until it is released</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">你可以在多人参与的游戏中看到这种设计模式。当你买了一个新手机后，你可能会抱怨某个玩家真的应该换一部手机了，怎么那么慢。比如下面的蓝方吕布玩家，他真的应该换一台设备了。</p></div><div class="el-p"><p dir="auto"><span alt="moba_game_begin.jpg" src="moba_game_begin.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="moba_game_begin.jpg" src="congzhi's-os-series/pics/moba_game_begin.jpg"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="7.1.4 Turnstile Pattern" dir="auto" class="heading" id="7.1.4_Turnstile_Pattern"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1.4 Turnstile Pattern</h4><div class="heading-children"><div class="el-p"><p dir="auto">Turnstile&nbsp;pattern&nbsp;是一种设计模式，主要用于在并发编程中控制对共享资源的访问。它像个旋转门一样，只允许一个线程在特定时间内通过，从而确保多个线程之间能够有序地进行协调。</p></div><div class="el-p"><p dir="auto">条件变量和&nbsp;turnstile&nbsp;pattern&nbsp;是相关的。在&nbsp;turnstile&nbsp;pattern&nbsp;中，条件变量可以用来管理线程的等待和唤醒。当资源不可用时，线程会被阻塞并放入条件变量中。当资源可用时，通过条件变量发出信号，唤醒等待的线程，使其继续执行。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第八课 Classical Concurrency Problem" dir="auto" class="heading" id="第八课_Classical_Concurrency_Problem"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第八课 Classical Concurrency Problem</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.1 Producer-Consumer Problem/Bounded Buffer Problem" dir="auto" class="heading" id="8.1_Producer-Consumer_Problem/Bounded_Buffer_Problem"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1 Producer-Consumer Problem/Bounded Buffer Problem</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>生产者-消费者问题</strong>描述了两个进程，一个是生成数据的生产者进程，一个是负责消费数据的消费者，两者通过共享缓冲区进行通信。由于问题描述的固定大小的缓冲区，也被称<strong>有限缓冲问题</strong>。核心挑战在于如何有效地管理缓冲区，确保生产者不会在缓冲区满时继续生产，也确保消费者不会在缓冲区空时继续消费。这个问题有很多变体，例如我们可以设置 x 个生产者， y 个消费者之类的。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.1.1 遵纪守法" dir="auto" class="heading" id="8.1.1_遵纪守法"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.1 遵纪守法</h4><div class="heading-children"><div class="el-p"><p dir="auto">在生产者-消费者问题中，有许多规则需要双方遵守的。当我们设置缓冲区大小为<code>BUFFER_SIZE</code>。我们规定：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">当缓冲区为空时，消费者不可以从缓冲区中读取信息。</li>
<li data-line="1" dir="auto">当缓冲区满了后，生产者也不可以在缓冲区写入任何东西。</li>
<li data-line="2" dir="auto">对于缓冲区的操作，我们需要确保其是互斥访问的，以免导致数据竞争问题。</li>
</ul></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.1.1.1 Checking All the Time" dir="auto" class="heading" id="8.1.1.1_Checking_All_the_Time"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.1.1 Checking All the Time</h5><div class="heading-children"><div class="el-p"><p dir="auto">通过这三条规则，我们可以用以下的伪代码对生产-消费的过程进行模拟。下面是一个忙等待加互斥的例子，我们用互斥锁对临界区进行了保护（缓冲区相关操作）。如果缓冲区满，生产者会一直查看缓冲区是否有空隙；若是缓冲区空，消费者也会一直查看缓冲区是否有可读信息。</p></div><div class="el-p"><p dir="auto"><strong>Producer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">added <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>added <span class="token operator">=</span> false<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// Add item.</span>
		count<span class="token operator">++</span><span class="token punctuation">;</span>
		added <span class="token operator">=</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Consumer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">removed <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>removed <span class="token operator">=</span> false<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// Remove item.</span>
		count<span class="token operator">--</span><span class="token punctuation">;</span>
		removed <span class="token operator">=</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.1.1.2 Check and Sleep" dir="auto" class="heading" id="8.1.1.2_Check_and_Sleep"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.1.2 Check and Sleep</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们之前比较过互斥锁和自旋锁的优劣，如果我们要长时间持有锁，忙等待显然会一直白白浪费资源。这种情况下，检查一次缓冲区，如果不满足相应的条件就直接阻塞进程/线程明显是更好的办法。使用锁好像效益来的不再可观，我们需要使用其他的工具。</p></div><div class="el-p"><p dir="auto">我们可以使用两个信号量，他们的最大值都是<code>BUFFER_SIZE</code>。两个信号量的描述如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>items</code>信号量：从0开始，表示缓冲区内现有多少可读的数据。</li>
<li data-line="1" dir="auto"><code>spaces</code>信号量：从<code>BUFFER_SIZE</code>开始，表示缓冲区还有多大的可用空间。</li>
</ul></div><div class="el-p"><p dir="auto">下面的伪代码中，<code>mutex</code>用于确保对缓冲区的访问是互斥的，从而避免了数据竞争问题。<code>spaces</code>和<code>items</code>信号量则用于控制缓冲区的容量和可读数据量。这样可以确保生产者和消费者在操作缓冲区时遵守规则，从而实现同步互斥。</p></div><div class="el-p"><p dir="auto"><strong>Producer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Add item.</span>
<span class="token function">post</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Consumer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Remove item.</span>
<span class="token function">post</span><span class="token punctuation">(</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这个示例会有什么问题？我们的确保证了对缓冲区的互斥访问。但是如果缓冲区满时，生产者率先进入临界区，生产者会阻塞在<code>wait(spaces);</code>。因为缓冲区满了，需要消费者进入缓冲区消耗资源但是由于生产者持有互斥锁，消费者无法进入缓冲区消耗资源。这就会导致<strong>死锁(Deadlock)</strong> 的发生。如果缓冲区为空，消费者先进入临界区也会导致类似的死锁问题。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.1.1.3 Swap the Waits" dir="auto" class="heading" id="8.1.1.3_Swap_the_Waits"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.1.3 Swap the Waits</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们对伪代码进行一些调整，生产者和消费者在等待<code>spaces</code>和<code>items</code>信号量时不再持有互斥锁，从而避免了死锁的发生。从而生产者和消费者可以在缓冲区满或空的情况下正确地等待和释放资源。</p></div><div class="el-p"><p dir="auto"><strong>Producer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Add item.</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Consumer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Remove item.</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.1.2 Multi-Producers and Consumers" dir="auto" class="heading" id="8.1.2_Multi-Producers_and_Consumers"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.1.2 Multi-Producers and Consumers</h4><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">20</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PRODUCER_NUMBER</span> <span class="token expression"><span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONSUMER_NUMBER</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token keyword">int</span><span class="token operator">*</span> buffer<span class="token punctuation">;</span>
<span class="token keyword">int</span> pindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">sem_t</span> spaces<span class="token punctuation">;</span>
<span class="token class-name">sem_t</span> items<span class="token punctuation">;</span>
<span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">252</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">rand_r</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rand_r for thread safe.</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Producer: %d\tproduced: %d.\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Consumer: %d\tconsumed %d.\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> counter <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token operator">*</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>pindex<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
        pindex <span class="token operator">=</span> <span class="token punctuation">(</span>pindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> counter <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> buffer<span class="token punctuation">[</span>cindex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>cindex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        cindex <span class="token operator">=</span> <span class="token punctuation">(</span>cindex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">consume</span><span class="token punctuation">(</span><span class="token operator">*</span>id<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>
    buffer <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>BUFFER_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BUFFER_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spaces<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">pthread_t</span> producer_thread<span class="token punctuation">[</span>PRODUCER_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> consumer_thread<span class="token punctuation">[</span>CONSUMER_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PRODUCER_NUMBER<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>id <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>producer_thread<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> producer<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> CONSUMER_NUMBER<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token operator">*</span> id <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>id <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>consumer_thread<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consumer<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> PRODUCER_NUMBER<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>producer_thread<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> CONSUMER_NUMBER<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>consumer_thread<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>spaces<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.2 Readers-Writers Problem" dir="auto" class="heading" id="8.2_Readers-Writers_Problem"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2 Readers-Writers Problem</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="8.2.1 Here Comes Mutant Fellow" dir="auto" class="heading" id="8.2.1_Here_Comes_Mutant_Fellow"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.1 Here Comes Mutant Fellow</h4><div class="heading-children"><div class="el-p"><p dir="auto">读者写者问题描述了多个读者和写者对共享数据的访问。读者-写者问题与生产者-消费者问题相似而又不同。相似的是两个问题中都有数据的输入（生产者/写者）和输出方（消费者/读者），而且生产者/写者修改共享数据时不能有其他线程访问共享数据。</p></div><div class="el-p"><p dir="auto">不同的是，读者-写者问题中的输出方（读者）并不涉及到对数据的修改操作（do not modify），这就意味着多个读者在读取数据的同时不会引起冲突。而且很多现实问题中写入很稀有但是读操作非常常见，允许缓冲区中多个读者读数据实际上可以提升很多性能。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.2.2 RW Solution-1" dir="auto" class="heading" id="8.2.2_RW_Solution-1"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.2 RW Solution-1</h4><div class="heading-children"><div class="el-p"><p dir="auto">现在我们考虑第一种情况，即一个写者对应着多个读者。假设读和写的操作都在一个房间中进行，即进行读写操作的房间实际上是我们的临界区。因而我们需要一个二元信号量<code>roomEmpty</code>对临界区进行管理。在读者进入临界区时，我们不想计算读者的数量时出现数据竞争的问题，所以我们使用<code>mutex</code>让读者一个一个地进入临界区。</p></div><div class="el-p"><p dir="auto">当写者要进入临界区中时，我们需要保证临界区中没有读者存在，在solution-1中，我们用以下的伪代码表示写者的行为：</p></div><div class="el-p"><p dir="auto"><strong>Writer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Write something</span>
<span class="token function">post</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们提到过，在读者-写者问题中，临界区中可以存在多个读者。因此我们在solution-1的伪代码中给出如下的读者行为：</p></div><div class="el-p"><p dir="auto"><strong>Reader</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Read data.</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">post</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.2.2.1 RW Solution-1 Analysis" dir="auto" class="heading" id="8.2.2.1_RW_Solution-1_Analysis"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.2.1 RW Solution-1 Analysis</h5><div class="heading-children"><div class="el-p"><p dir="auto">在solution-1中写者的行为逻辑简单又清晰，等待房间里没有读者了，写者进入房间中进行写操作。而由于可能会有很多读者，读者在进出房间时会挨个登记（<code>wait(mutex)</code> 和 <code>post(mutex)</code>），如果是第一个进入房间的，就负责标识房间已被占用（<code>wait(roomEmpty)</code>），最后一个出房间就负责标识房间空闲（<code>post(roomEmpty)</code>。</p></div><div class="el-p"><p dir="auto">读者的这种行为模式叫做light switch pattern（先进入房间的人开灯，最后一个离开房间的人关灯）。在solution-1中，读者的行为会为写者带来很多困扰。比如读者占用房间后，后来的读者可以随意进出，只要保证最后一个离开房间的写者离开时释放房间资源就可以了。但是，你没有办法知道后面究竟有多少读者要读。在solution-1中，写者只能干等，这会导致写者长时间得不到资源的问题，也就是<strong>饥饿(Starvation)</strong>：which means a thread may never gets a chance to run.</p></div><div class="el-p"><p dir="auto">写者的饥饿可能对博客这种读写问题的影响不会很大，但是对那些对实时性有要求的系统的影响尤其大（比如数据库的读写问题）。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.2.3 RW Solution-2: Writer's Gotta be Tough" dir="auto" class="heading" id="8.2.3_RW_Solution-2:_Writer's_Gotta_be_Tough"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.3 RW Solution-2: Writer's Gotta be Tough</h4><div class="heading-children"><div class="el-p"><p dir="auto">为了避免写者的饥饿问题，我们需要另辟蹊径，重新找一个方法。我们试想一下solution-2的描述：当写者到达，已经在房间里的读者们继续阅读，但是后来者就不可以进入临界区阅读数据了。在solution-2的假设下，写者只需要等待临界区中读者读完数据走出临界区，不需要担心无休止到来的读者。</p></div><div class="el-p"><p dir="auto">Solution-2我们引入了另一个二元信号量<code>turnstile</code>。相当于对“门”进行控制，无论是读者还是写者，要进入房间（临界区）必须通过“门”。通过占有“门”资源，读者和写者就能顺序地进入临界区。Solution-2中的写者行为如下：</p></div><div class="el-p"><p dir="auto"><strong>Writer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Write data.</span>
<span class="token function">post</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>trunstile<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Reader</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Read data.</span>
<span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">post</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="8.2.3.1 RW Solution-2 Analysis" dir="auto" class="heading" id="8.2.3.1_RW_Solution-2_Analysis"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.3.1 RW Solution-2 Analysis</h5><div class="heading-children"><div class="el-p"><p dir="auto">虽然我们成功地使写者免受了饥饿的困扰，但是写者仍然不对临界区拥有任何特权。想想看，如果前面仍然有许多的读者在写者前面排队等待进入临界区，写者就仍然需要队列前面的所有读者进入临界区-读取-出临界区后才能对临界区资源进行操作。</p></div><div class="el-p"><p dir="auto">Solution-2仍然不够实时，怎么办？我们需要划分<strong>优先级</strong>，使得写者相对读者总是享有有限进入临界区的特权。可以通过将信号量<code>roomEmpty</code>划分为两个信号量：<code>noReaders</code> 和 <code>noWriters</code> 来实现。通过让写者持有<code>noReaders</code>信号量来控制读者进入临界区。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.2.4 RW Solution-3: Writer Priority" dir="auto" class="heading" id="8.2.4_RW_Solution-3:_Writer_Priority"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.4 RW Solution-3: Writer Priority</h4><div class="heading-children"><div class="el-p"><p dir="auto">在Solution-3中，我们引入优先级机制，写者可以相对读者享有优先权。第一个写者会等待并占有<code>noReaders</code>信号量，阻止新的读者进入临界区。这样，写者可以在当前读者完成操作后立即进入临界区，而不需要等待新的读者完成操作。</p></div><div class="el-p"><p dir="auto"><strong>Writer</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>writeMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
writers<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>writers <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>noReaders<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>writeMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>noWriters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Write data.</span>
<span class="token function">post</span><span class="token punctuation">(</span>noWriters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>writeMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
writers<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>writers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">post</span><span class="token punctuation">(</span>noReaders<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Reader</strong></p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">wait</span><span class="token punctuation">(</span>noReaders<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span>readMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">wait</span><span class="token punctuation">(</span>noWriters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>readMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>noReaders<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Read data.</span>
<span class="token function">wait</span><span class="token punctuation">(</span>readMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readers<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>readers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">post</span><span class="token punctuation">(</span>noWriters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">post</span><span class="token punctuation">(</span>readMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="8.2.x Multi-Readers and Writers" dir="auto" class="heading" id="8.2.x_Multi-Readers_and_Writers"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.2.x Multi-Readers and Writers</h4><div class="heading-children"></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="8.3 RW Lock in POSIX thread" dir="auto" class="heading" id="8.3_RW_Lock_in_POSIX_thread"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8.3 RW Lock in POSIX thread</h3><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token class-name">pthread_rwlock_t</span> rwlock<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_rwlockattr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. rwlock: Pointer to the read-write lock to initialize.
	2. attr: Pointer to a read-write lock attributes object, or NULL for default attributes.
	   - PTHREAD_PROCESS_SHARED: The lock can be shared between processes.
	   - PTHREAD_PROCESS_PRIVATE: The lock is private to the process (default).

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. rwlock: Pointer to the read-write lock to destroy. The lock must be uninitialized before calling this function.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Blocks if the lock is currently held by a writer.</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. rwlock: Pointer to the read-write lock to acquire for read access.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Does not block. Returns immediately if the lock cannot be acquired.</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_tryrdlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. rwlock: Pointer to the read-write lock to attempt acquiring for read access.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Blocks if the lock is currently held by a reader or writer.</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:
	1. rwlock: Pointer to the read-write lock to acquire for write access.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Does not block. Returns immediately if the lock cannot be acquired.</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_trywrlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
Parameters:
	1. rwlock: Pointer to the read-write lock to attempt acquiring for write access.

	Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Releases the lock held by either a reader or a writer.</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. rwlock: Pointer to the read-write lock to release.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第九课 Condition Variables, Monitor and Atomic Types" dir="auto" class="heading" id="第九课_Condition_Variables,_Monitor_and_Atomic_Types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第九课 Condition Variables, Monitor and Atomic Types</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.1 Condition Variables" dir="auto" class="heading" id="9.1_Condition_Variables"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1 Condition Variables</h3><div class="heading-children"><div class="el-p"><p dir="auto">条件变量和我们学过的条件语句非常类似，我们用不同的条件语句可以使得在条件满足时跳进特定的分支。条件变量也一样，条件变量的作用就是允许一个线程等待特定的条件被满足，在条件满足时通知其他线程继续执行。不同的是，条件变量是我们达成线程同步的一种方法，协调了线程之间的执行顺序。确保了某些线程在条件满足之前阻塞等待。</p></div><div class="el-p"><p dir="auto">那这些阻塞的线程怎么才能知道条件已经满足了呢？在之前，我们可能会使用信号量、互斥锁来实现线程同步和协调。那这些和我们本节学习的条件变量相比有何不足呢？当我们使用信号量时，我们只能给特定的某一个线程发送信号。而<strong>使用条件变量，我们就可以选择当条件得到满足后，是给某个特定的线程发送信号还是给所有等待事件发生的线程发送信号</strong>。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.1.1 CV in POSIX" dir="auto" class="heading" id="9.1.1_CV_in_POSIX"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1 CV in POSIX</h4><div class="heading-children"><div class="el-p"><p dir="auto">在 POSIX 线程库底下，我们有许多相关的系统调用。下面我们来看看这些不同的系统调用。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.1.1.1 `pthread_cond_init()`" dir="auto" class="heading" id="9.1.1.1_`pthread_cond_init()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1.1 <code>pthread_cond_init()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">我们用 <code>pthread_cond_init</code> 来初始化一个条件变量。详细的系统调用原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_condattr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cond: Pointer to the condition variable to initialize.
	2. attr: Pointer to a condition variable attributes object.
	   - NULL: default attributes (PTHREAD_PROCESS_PRIVATE|CLOCK_REALTIME).
	   - PTHREAD_PROCESS_SHARED: condition variable can be shared between processes.
	   - PTHREAD_PROCESS_PRIVATE: condition variable is only used within a single process.
	   - PTHREAD_CONDATTR_CLOCKID: clock type used by the condition variable (e.g., CLOCK_REALTIME, CLOCK_MONOTONIC).

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面是简单的例子，举例如何创建并销毁一个环境变量。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_cond_t</span> cond<span class="token punctuation">;</span> <span class="token comment">// Declare a condition variable</span>
    <span class="token keyword">int</span> res<span class="token punctuation">;</span> <span class="token comment">// Variable to store the result of initialization</span>
    res <span class="token operator">=</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Condition variable initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize condition variable. Error code: %d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.1.1.2 `pthread_cond_wait()`" dir="auto" class="heading" id="9.1.1.2_`pthread_cond_wait()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1.2 <code>pthread_cond_wait()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_cond_wait</code> 允许线程等待某个条件满足，同时释放互斥锁以避免资源竞争。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">,</span> <span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cond: Pointer to the condition variable to wait on.
	2. mutex: Pointer to the mutex that should be locked by the calling thread.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.1.1.3 `pthread_cond_signal()`" dir="auto" class="heading" id="9.1.1.3_`pthread_cond_signal()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1.3 <code>pthread_cond_signal()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_cond_signal</code> 的作用是唤醒一个在条件变量上等待的线程。如果有多个线程在等待条件变量，函数只会唤醒一个线程（由系统决定的）。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cond: Pointer to the condition variable to signal.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们用一个例子来学习：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
<span class="token class-name">pthread_cond_t</span> cond<span class="token punctuation">;</span>
<span class="token keyword">int</span> condition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Explicitly initialize the condition variable to 0</span>
<span class="token keyword">void</span> <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Mutex lock initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize mutex lock. Error code: %d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">cv_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> res<span class="token punctuation">;</span>
    res <span class="token operator">=</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Condition variable initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize condition variable. Error code: %d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// The thread will block here, and the mutex lock will be released until the condition variable is signaled.</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld continues\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cv_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
	<span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Sleep for a second to ensure the thread is waiting on the condition variable</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main thread is about to signal the condition variable.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    condition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Condition fulfilled by main thread.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// Destroy the condition variable and mutex to release resources</span>
    <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">首先，我们定义了三个全局的资源变量并对其进行初始化。</p></div><div class="el-p"><p dir="auto">之后，我们启动了 8 个线程来执行 <code>thread_func()</code> 函数。在函数里面，线程会进入循环并调用 <code>pthread_cond_wait(&amp;cond, &amp;mutex);</code> ，这时，每个运行到 <code>pthread_cond_wait</code> 的线程都会被阻塞并释放其拥有的互斥锁。（当线程被唤醒后会重新获取 mutex ）</p></div><div class="el-p"><p dir="auto">因为我们让主线程睡了 1 秒钟，所以主线程会在这 8 个子线程都阻塞后才进入临界区完成一系列的操作，之后挨个调用<code>pthread_cond_signal</code> ，因为主线程这时仍然持有锁，所以即使唤醒线程，它仍然阻塞。但因为等待条件被满足，所以当主线程释放锁，8 个线程会重新获取锁并开始执行。</p></div><div class="el-p"><p dir="auto">之前我们提到了 barrier 的同步模式，虽然我们用条件变量实现这样一个 Barrier 同步模式很简单，但实际上，上面的实现仍然不能够保证可靠和 barrier 的思想。比如，我们使用 <code>usleep</code> 来确保所有的子线程都执行到 <code>pthread_cond_wait(&amp;cond, &amp;mutex);</code>。而且我们用循环来唤醒所有的线程，效率也不高。（触发多次内核态的系统调用）</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.1.1.4 `pthread_cond_broadcast()`" dir="auto" class="heading" id="9.1.1.4_`pthread_cond_broadcast()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1.4 <code>pthread_cond_broadcast()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>pthread_cond_broadcast()</code> 用来唤醒所有在条件变量上等待的线程。上面，我们每次只唤醒一个子线程，效率极为低下。但通过 <code>pthread_cond_broadcast()</code> ，我们可以保证一次系统调用就可以唤醒所有的子线程。它的函数调用原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cond: Pointer to the condition variable to broadcast.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">现在，你可以用更少的系统调用来实现屏障：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">;</span>
<span class="token class-name">pthread_cond_t</span> cv<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cv<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们将之前一个一个唤醒线程的方式用 <code>pthread_cond_broadcast()</code> 来替换：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
<span class="token class-name">pthread_cond_t</span> cond<span class="token punctuation">;</span>
<span class="token class-name">pthread_barrier_t</span> barrier<span class="token punctuation">;</span>
<span class="token keyword">int</span> condition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Mutex lock initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize mutex lock.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">cv_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Condition variable initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize condition variable.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">barrier_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_barrier_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Barrier initialized successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Failed to initialize barrier.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld waiting at barrier.\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_barrier_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld has acquired mutex lock.\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld continues after the condition is fulfilled.\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cv_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">barrier_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">pthread_barrier_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    condition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Condition fulfilled by main thread.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_barrier_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>barrier<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.1.1.5 `pthread_cond_destroy()`" dir="auto" class="heading" id="9.1.1.5_`pthread_cond_destroy()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.1.5 <code>pthread_cond_destroy()</code></h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cond: Pointer to the condition variable to destroy.

Return value: Returns 0 on success, otherwise an error number.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.1.2 Always Stick with Mutex Locks" dir="auto" class="heading" id="9.1.2_Always_Stick_with_Mutex_Locks"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.2 Always Stick with Mutex Locks</h4><div class="heading-children"><div class="el-p"><p dir="auto">好了，现在我们还有一个问题：为什么条件变量总是和互斥锁在一起配合使用？比如说你会看到：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition_is_false<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们前面提到过，条件变量是一种类似 if...else... 的逻辑。在多线程的环境中，我们需要保证检查条件是否满足和进入等待条件必须是原子操作，一气呵成的。不然就可能因为线程的并发执行而发生条件竞争。假如我们有下面的情况：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Check</span>
	    <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// And wait</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> threads_A<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads_A<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    condition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads_A<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这里没有互斥锁，就可能导致在子线程检查完毕后，主线程抢占 CPU 并修改条件为满足并调用 <code>pthread_cond_signal</code>。这就会使得子线程调用&nbsp;<code>pthread_cond_wait</code> 时条件已满足，导致无限等待。所以我们需要加锁。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.1.3 Interview Question: Can CV Be Integrated with Mutexes?" dir="auto" class="heading" id="9.1.3_Interview_Question:_Can_CV_Be_Integrated_with_Mutexes?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1.3 Interview Question: Can CV Be Integrated with Mutexes?</h4><div class="heading-children"><div class="el-p"><p dir="auto">为什么不在条件变量中集成互斥锁？</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.2 Monitors" dir="auto" class="heading" id="9.2_Monitors"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2 Monitors</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="9.2.1 封装和抽象" dir="auto" class="heading" id="9.2.1_封装和抽象"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2.1 封装和抽象</h4><div class="heading-children"><div class="el-p"><p dir="auto">条件变量可以用于管程的创建（更高层级的抽象），所以管程是一个更高级的同步工具，有点类似于OOP中的类。在C++中，我们用类来打包数据和相关的操作，管程的目标就是将那些共享的数据和对这些共享数据的操作进行打包封装起来。有了管程，我们就不需要手动地操作那些共享数据了，减少了出错的可能性。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.2.2 人工队 vs. 机器队" dir="auto" class="heading" id="9.2.2_人工队_vs._机器队"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2.2 人工队 vs. 机器队</h4><div class="heading-children"><div class="el-p"><p dir="auto">在传统的方法中，我们需要人为地对锁进行管理。下面这里例子中，我们有一个加锁和一个解锁，乍一看是正确的，但是程序中的<code>if</code>条件判断使得程序实际上存在着两个分支。我们需要给这两个分支的互斥锁都做好善后工作，因此实际上我们需要两个解锁函数。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* Read some data. */</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>condition_is_true<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Cannot continue due to reasons.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Missing something here~</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/* Do something more. */</span>
	<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这种人为管理资源的模式太麻烦了，我们需要一种更加智能的管理方式。在C语言中，我们可以使用pthread库中的条件变量和互斥锁来实现管程。而 C++ 的 RAII 机制使得管程的实现尤为容易。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
    <span class="token class-name">pthread_cond_t</span> cond<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Monitor<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Monitor <span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>cond<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span>Monitor <span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">wait_for_count</span><span class="token punctuation">(</span>Monitor <span class="token operator">*</span>m<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">-&gt;</span>count <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>Monitor <span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token operator">-&gt;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Monitor m<span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>increment<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>wait_for_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Final count: %d\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Monitor</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">wait_for_count</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> count <span class="token operator">&gt;=</span> target<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Monitor monitor<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Monitor<span class="token double-colon punctuation">::</span>increment<span class="token punctuation">,</span> <span class="token operator">&amp;</span>monitor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Monitor<span class="token double-colon punctuation">::</span>wait_for_count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>monitor<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final count: "</span> <span class="token operator">&lt;&lt;</span> monitor<span class="token punctuation">.</span><span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.3 Atomic Types" dir="auto" class="heading" id="9.3_Atomic_Types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3 Atomic Types</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.1 加锁？枷锁！" dir="auto" class="heading" id="9.3.1_加锁？枷锁！"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.1 加锁？枷锁！</h4><div class="heading-children"><div class="el-p"><p dir="auto">在学习原子类型变量之前，要规避并发访问共享数据带来的竞争条件问题，我们可能想当然地使用锁来解决。将共享数据的访问放到一个临界区中，然后对临界区进行加锁和解锁来实现这一过程。但是会带来额外的性能开销（两次系统调用）。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// system call * 1</span>
shared_var<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// system call * 2</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">上面利用互斥锁实现的对共享资源访问的方法中，我们看到，系统调用的开销要远远大于对共享资源操作所带来的开销。这时只会使用锁的单一解决方法就成为了一种枷锁。那有没有办法降低这种资源损耗？当然有：原子类型。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.2 Another Layers of Abstraction" dir="auto" class="heading" id="9.3.2_Another_Layers_of_Abstraction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.2 Another Layers of Abstraction</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们前面已经学习过像&nbsp;test-and-set、compare-and-swap&nbsp;等硬件提供的原子操作指令。没有硬件提供的原子指令，软件再怎么模拟也不可能实现相似的原子性操作。利用机器提供的这些原子操作指令的接口，我们可以在上层封装这些原子操作为己所用。</p></div><div class="el-p"><p dir="auto">实际上，互斥锁和原子类型都是对这些机器指令的封装和抽象，但不同的是，原子类型直接利用指令提供的原子性操作，避开了系统调用的开销，而锁更加高级，常用于处理复杂的竞争条件问题。对于单一共享资源的处理，我们简单地利用原子类型就可以了。</p></div><div class="el-p"><p dir="auto">早期 C 标准库没有引入原子操作时，GNU 标准下的 C 库（glibc）就通过对下层机器指令的封装提供了原子类型。这些原子类型操作保证了操作的原子性，规避简单的条件竞争。在 C++11 之后，我们可以包含 <code>&lt;atomic&gt;</code> 头文件来使用C++中的原子操作。当我们在高级语言中使用这些原子类型时，编译器会将这些数据类型转换成硬件能够提供的原子操作指令。</p></div><div class="el-p"><p dir="auto">下面我们展示了 C++11 中的原子类型。对 <code>std::atomic</code> 类型的操作是原子性的，不可被打断的。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">shared_var</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

shared_var<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// Operations to shared_var is unbreakable.</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="9.3.3 Atomic Operations" dir="auto" class="heading" id="9.3.3_Atomic_Operations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.3 Atomic Operations</h4><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="9.3.3.1 Atomic Operations in GCC" dir="auto" class="heading" id="9.3.3.1_Atomic_Operations_in_GCC"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.3.1 Atomic Operations in GCC</h5><div class="heading-children"><div class="el-p"><p dir="auto">下面是GCC（GNU&nbsp;Compiler&nbsp;Collection）提供的一组内建函数，主要用于进行原子操作和实现无锁编程。它们利用硬件提供的原子指令，确保操作的原子性，避免了竞态条件。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">type <span class="token function">__sync_lock_test_and_set</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span>
bool <span class="token function">__sync_bool_compare_and_swap</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type oldval<span class="token punctuation">,</span> type newval<span class="token punctuation">)</span>
type <span class="token function">__sync_val_compare_and_swap</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type oldval<span class="token punctuation">,</span> type newval<span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>type&nbsp;__sync_lock_test_and_set(type&nbsp;*ptr,&nbsp;type&nbsp;value)</code>:&nbsp;该函数将<code>value</code>写入<code>*ptr</code>，并返回<code>*ptr</code>的旧值。这是一个原子的“测试并设置”操作，常用于实现简单的锁。</p></div><div class="el-p"><p dir="auto"><code>bool&nbsp;__sync_bool_compare_and_swap(type&nbsp;*ptr,&nbsp;type&nbsp;oldval,&nbsp;type&nbsp;newval)</code>:&nbsp;该函数如果<code>*ptr</code>等于<code>oldval</code>，则将<code>newval</code>写入<code>*ptr</code>，返回<code>true</code>；否则，不修改<code>*ptr</code>，返回<code>false</code>。</p></div><div class="el-p"><p dir="auto"><code>type&nbsp;__sync_val_compare_and_swap(type&nbsp;*ptr,&nbsp;type&nbsp;oldval,&nbsp;type&nbsp;newval)</code>:&nbsp;该函数如果<code>*ptr</code>等于<code>oldval</code>，则将<code>newval</code>写入<code>*ptr</code>，并返回<code>*ptr</code>的旧值。</p></div><div class="el-p"><p dir="auto">除此之外，gcc还提供其他的一些内建函数。如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// Return the old value:</span>
type <span class="token function">__sync_fetch_and_add</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_fetch_and_sub</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_fetch_and_or</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_fetch_and_and</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_fetch_and_xor</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_fetch_and_nand</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Return the new value:</span>
type <span class="token function">__sync_add_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_sub_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_or_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_and_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_xor_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_nand_and_fetch</span><span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="9.3.3.x Atomic Reading" dir="auto" class="heading" id="9.3.3.x_Atomic_Reading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3.3.x Atomic Reading</h5><div class="heading-children"><div class="el-p"><p dir="auto">自始至终，我们学到的原子操作都是关于 modifying 的原子操作，但从来没有提到读指令的原子操作。那该如何保证每次读到的数据都是最新的呢？</p></div><div class="el-p"><p dir="auto">x86机器并没有 build-in 读原子操作指令。由于机器上的读指令在大多数情况下是原子性的，单独的读操作通常是不可分割的。在x86机器上，读取一个32位整数或一个64位整数（在64位架构上）通常默认就是原子操作。但如果这样，我们仍然可能得到过时的数据，因为如果读的时候刚好写入了新的数据，那么读到的数据可能就不再是最新的了。</p></div><div class="el-p"><p dir="auto">我们其实可以用 modifying 的原子操作来做一个读的事情。比如对原先的变量原子加或减0，就能够保证我们每次读到的数值都是最新的。如果不在乎性能开销，使用锁也是可以的。</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#10. Synchronization and Mutex"><div class="tree-item-contents heading-link" heading-name="
Synchronization and Mutex
"><span class="tree-item-title">Synchronization and Mutex</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第一课_Synchronization_Problem"><div class="tree-item-contents heading-link" heading-name="第一课 Synchronization Problem"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课 Synchronization Problem</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#1.1_Concurrency_is_a_Disaster"><div class="tree-item-contents heading-link" heading-name="1.1 Concurrency is a Disaster"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Concurrency is a Disaster</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#1.1.1_Synchronization"><div class="tree-item-contents heading-link" heading-name="1.1.1 Synchronization"><span class="tree-item-title">1.1.1 Synchronization</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#1.1.2_Non-Deterministic_Program_and_Heisenbug"><div class="tree-item-contents heading-link" heading-name="1.1.2 Non-Deterministic Program and Heisenbug"><span class="tree-item-title">1.1.2 Non-Deterministic Program and Heisenbug</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#1.1.3_Resource_Allocation_and_Executing_Order"><div class="tree-item-contents heading-link" heading-name="1.1.3 Resource Allocation and Executing Order"><span class="tree-item-title">1.1.3 Resource Allocation and Executing Order</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第二课_Critical_Section_Management"><div class="tree-item-contents heading-link" heading-name="第二课 Critical Section Management"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 Critical Section Management</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.1_Critical_Resources_and_Critical_Section"><div class="tree-item-contents heading-link" heading-name="2.1 Critical Resources and Critical Section"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.1 Critical Resources and Critical Section</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.1.1_Critical_Resources"><div class="tree-item-contents heading-link" heading-name="2.1.1 Critical Resources"><span class="tree-item-title">2.1.1 Critical Resources</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.1.2_Critical_Section"><div class="tree-item-contents heading-link" heading-name="2.1.2 Critical Section"><span class="tree-item-title">2.1.2 Critical Section</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.1.3_A_Real_Example:_Ticket_Booking"><div class="tree-item-contents heading-link" heading-name="2.1.3 A Real Example: Ticket Booking"><span class="tree-item-title">2.1.3 A Real Example: Ticket Booking</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.1.4_Management_Principles"><div class="tree-item-contents heading-link" heading-name="2.1.4 Management Principles"><span class="tree-item-title">2.1.4 Management Principles</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.2_The_First_Synchronous_Tool:_Mutex_Lock"><div class="tree-item-contents heading-link" heading-name="2.2 The First Synchronous Tool: Mutex Lock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2 The First Synchronous Tool: Mutex Lock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#2.2.1_Mutex_Lock_POSIX_Brings"><div class="tree-item-contents heading-link" heading-name="2.2.1 Mutex Lock POSIX Brings"><span class="tree-item-title">2.2.1 Mutex Lock POSIX Brings</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第三课_Complementing_a_Lock"><div class="tree-item-contents heading-link" heading-name="第三课 Complementing a Lock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Complementing a Lock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1_Complementing_a_Mutex_Lock"><div class="tree-item-contents heading-link" heading-name="3.1 Complementing a Mutex Lock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 Complementing a Mutex Lock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.1_The_First_Try"><div class="tree-item-contents heading-link" heading-name="3.1.1 The First Try"><span class="tree-item-title">3.1.1 The First Try</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.2_The_Second_Try"><div class="tree-item-contents heading-link" heading-name="3.1.2 The Second Try"><span class="tree-item-title">3.1.2 The Second Try</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.3_Atomic_Operations"><div class="tree-item-contents heading-link" heading-name="3.1.3 Atomic Operations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1.3 Atomic Operations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.3.1_The_Hardware's_Got_Your_Back!"><div class="tree-item-contents heading-link" heading-name="3.1.3.1 The Hardware's Got Your Back!"><span class="tree-item-title">3.1.3.1 The Hardware's Got Your Back!</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.3.2_Standing_on_the_Shoulders_of_Giants"><div class="tree-item-contents heading-link" heading-name="3.1.3.2 Standing on the Shoulders of Giants"><span class="tree-item-title">3.1.3.2 Standing on the Shoulders of Giants</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.1.4_The_Third_Try"><div class="tree-item-contents heading-link" heading-name="3.1.4 The Third Try"><span class="tree-item-title">3.1.4 The Third Try</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.2_Busy_waiting"><div class="tree-item-contents heading-link" heading-name="3.2 Busy waiting"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2 Busy waiting</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#3.2.1_Lemme_Sleep"><div class="tree-item-contents heading-link" heading-name="3.2.1 Lemme Sleep"><span class="tree-item-title">3.2.1 Lemme Sleep</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第四课_Mutex_Lock_and_Spin-Lock"><div class="tree-item-contents heading-link" heading-name="第四课 Mutex Lock and Spin-Lock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第四课 Mutex Lock and Spin-Lock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.1_`pthread_mutex`"><div class="tree-item-contents heading-link" heading-name="4.1 `pthread_mutex`"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1 <code>pthread_mutex</code></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.1.1_Mutex_Don't_Spin_Around"><div class="tree-item-contents heading-link" heading-name="4.1.1 Mutex Don't Spin Around"><span class="tree-item-title">4.1.1 Mutex Don't Spin Around</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.2_`pthread_spinlock`"><div class="tree-item-contents heading-link" heading-name="4.2 `pthread_spinlock`"><span class="tree-item-title">4.2 <code>pthread_spinlock</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.3_Mutex_Lock_vs._Spin-Lock"><div class="tree-item-contents heading-link" heading-name="4.3 Mutex Lock vs. Spin-Lock"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.3 Mutex Lock vs. Spin-Lock</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.2.1_Testing_Code_for_Mutex"><div class="tree-item-contents heading-link" heading-name="4.2.1 Testing Code for Mutex"><span class="tree-item-title">4.2.1 Testing Code for Mutex</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.2.2_Testing_Code_for_Spinlock"><div class="tree-item-contents heading-link" heading-name="4.2.2 Testing Code for Spinlock"><span class="tree-item-title">4.2.2 Testing Code for Spinlock</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#4.2.3_No_One's_the_Best"><div class="tree-item-contents heading-link" heading-name="4.2.3 No One's the Best"><span class="tree-item-title">4.2.3 No One's the Best</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第五课_Peterson_and_Dekker"><div class="tree-item-contents heading-link" heading-name="第五课 Peterson and Dekker"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第五课 Peterson and Dekker</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#5.1_Peterson_Algorithm"><div class="tree-item-contents heading-link" heading-name="5.1 Peterson Algorithm"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.1 Peterson Algorithm</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#5.1.1_Peterson_Algorithm_Processing_Possibilities"><div class="tree-item-contents heading-link" heading-name="5.1.1 Peterson Algorithm Processing Possibilities"><span class="tree-item-title">5.1.1 Peterson Algorithm Processing Possibilities</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#5.1.2_Peterson_Summary"><div class="tree-item-contents heading-link" heading-name="5.1.2 Peterson Summary"><span class="tree-item-title">5.1.2 Peterson Summary</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#5.2_Dekker_Algorithm"><div class="tree-item-contents heading-link" heading-name="5.2 Dekker Algorithm"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.2 Dekker Algorithm</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#5.2.1_Dekker_Algorithm_Processing_Possibilities"><div class="tree-item-contents heading-link" heading-name="5.2.1 Dekker Algorithm Processing Possibilities"><span class="tree-item-title">5.2.1 Dekker Algorithm Processing Possibilities</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第六课_Semaphore_and_PV_Operations_(Since_1965)"><div class="tree-item-contents heading-link" heading-name="第六课 Semaphore and PV Operations (Since 1965)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第六课 Semaphore and PV Operations (Since 1965)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.1_Basics"><div class="tree-item-contents heading-link" heading-name="6.1 Basics"><span class="tree-item-title">6.1 Basics</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.2_PV_Operations"><div class="tree-item-contents heading-link" heading-name="6.2 PV Operations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.2 PV Operations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.2.1_Busy_Waiting"><div class="tree-item-contents heading-link" heading-name="6.2.1 Busy Waiting"><span class="tree-item-title">6.2.1 Busy Waiting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.3.2_Blocking_PV"><div class="tree-item-contents heading-link" heading-name="6.3.2 Blocking PV"><span class="tree-item-title">6.3.2 Blocking PV</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.3_Blocking_and_Non-Blocking_PV"><div class="tree-item-contents heading-link" heading-name="6.3 Blocking and Non-Blocking PV"><span class="tree-item-title">6.3 Blocking and Non-Blocking PV</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.4_Binary_Semaphore"><div class="tree-item-contents heading-link" heading-name="6.4 Binary Semaphore"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.4 Binary Semaphore</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.4.1_Mutual_Exclusion_based_on_Binary_Semaphore"><div class="tree-item-contents heading-link" heading-name="6.4.1 Mutual Exclusion based on Binary Semaphore"><span class="tree-item-title">6.4.1 Mutual Exclusion based on Binary Semaphore</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.4.2_Synchronization_Based_on_Binary_Semaphore"><div class="tree-item-contents heading-link" heading-name="6.4.2 Synchronization Based on Binary Semaphore"><span class="tree-item-title">6.4.2 Synchronization Based on Binary Semaphore</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.5_Resource_Allocation_Using_Semaphore"><div class="tree-item-contents heading-link" heading-name="6.5 Resource Allocation Using Semaphore"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.5 Resource Allocation Using Semaphore</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.5.1_Counting_Semaphore"><div class="tree-item-contents heading-link" heading-name="6.5.1 Counting Semaphore"><span class="tree-item-title">6.5.1 Counting Semaphore</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.6_Comparison_on_Different_Semaphores"><div class="tree-item-contents heading-link" heading-name="6.6 Comparison on Different Semaphores"><span class="tree-item-title">6.6 Comparison on Different Semaphores</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7_System_Call_on_Its_Way"><div class="tree-item-contents heading-link" heading-name="6.7 System Call on Its Way"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6.7 System Call on Its Way</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.1_sem_init"><div class="tree-item-contents heading-link" heading-name="6.7.1 sem_init"><span class="tree-item-title">6.7.1 sem_init</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.2_sem_destroy"><div class="tree-item-contents heading-link" heading-name="6.7.2 sem_destroy"><span class="tree-item-title">6.7.2 sem_destroy</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.3_sem_wait"><div class="tree-item-contents heading-link" heading-name="6.7.3 sem_wait"><span class="tree-item-title">6.7.3 sem_wait</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.4_sem_trywait"><div class="tree-item-contents heading-link" heading-name="6.7.4 sem_trywait"><span class="tree-item-title">6.7.4 sem_trywait</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.5_sem_post"><div class="tree-item-contents heading-link" heading-name="6.7.5 sem_post"><span class="tree-item-title">6.7.5 sem_post</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#6.7.6_sem_getvalue"><div class="tree-item-contents heading-link" heading-name="6.7.6 sem_getvalue"><span class="tree-item-title">6.7.6 sem_getvalue</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第七课_Synchronization_Patterns"><div class="tree-item-contents heading-link" heading-name="第七课 Synchronization Patterns"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第七课 Synchronization Patterns</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1_Simple_Patterns"><div class="tree-item-contents heading-link" heading-name="7.1 Simple Patterns"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1 Simple Patterns</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.1_Signaling"><div class="tree-item-contents heading-link" heading-name="7.1.1 Signaling"><span class="tree-item-title">7.1.1 Signaling</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.2_Rendevous"><div class="tree-item-contents heading-link" heading-name="7.1.2 Rendevous"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7.1.2 Rendevous</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.2.1_Two_Threads_Meet-up"><div class="tree-item-contents heading-link" heading-name="7.1.2.1 Two Threads Meet-up"><span class="tree-item-title">7.1.2.1 Two Threads Meet-up</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.2.2_Several_Threads_Meet-up"><div class="tree-item-contents heading-link" heading-name="7.1.2.2 Several Threads Meet-up"><span class="tree-item-title">7.1.2.2 Several Threads Meet-up</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.3_Barrier_Pattern"><div class="tree-item-contents heading-link" heading-name="7.1.3 Barrier Pattern"><span class="tree-item-title">7.1.3 Barrier Pattern</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#7.1.4_Turnstile_Pattern"><div class="tree-item-contents heading-link" heading-name="7.1.4 Turnstile Pattern"><span class="tree-item-title">7.1.4 Turnstile Pattern</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第八课_Classical_Concurrency_Problem"><div class="tree-item-contents heading-link" heading-name="第八课 Classical Concurrency Problem"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第八课 Classical Concurrency Problem</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1_Producer-Consumer_Problem/Bounded_Buffer_Problem"><div class="tree-item-contents heading-link" heading-name="8.1 Producer-Consumer Problem/Bounded Buffer Problem"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.1 Producer-Consumer Problem/Bounded Buffer Problem</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1.1_遵纪守法"><div class="tree-item-contents heading-link" heading-name="8.1.1 遵纪守法"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.1.1 遵纪守法</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1.1.1_Checking_All_the_Time"><div class="tree-item-contents heading-link" heading-name="8.1.1.1 Checking All the Time"><span class="tree-item-title">8.1.1.1 Checking All the Time</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1.1.2_Check_and_Sleep"><div class="tree-item-contents heading-link" heading-name="8.1.1.2 Check and Sleep"><span class="tree-item-title">8.1.1.2 Check and Sleep</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1.1.3_Swap_the_Waits"><div class="tree-item-contents heading-link" heading-name="8.1.1.3 Swap the Waits"><span class="tree-item-title">8.1.1.3 Swap the Waits</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.1.2_Multi-Producers_and_Consumers"><div class="tree-item-contents heading-link" heading-name="8.1.2 Multi-Producers and Consumers"><span class="tree-item-title">8.1.2 Multi-Producers and Consumers</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2_Readers-Writers_Problem"><div class="tree-item-contents heading-link" heading-name="8.2 Readers-Writers Problem"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.2 Readers-Writers Problem</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.1_Here_Comes_Mutant_Fellow"><div class="tree-item-contents heading-link" heading-name="8.2.1 Here Comes Mutant Fellow"><span class="tree-item-title">8.2.1 Here Comes Mutant Fellow</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.2_RW_Solution-1"><div class="tree-item-contents heading-link" heading-name="8.2.2 RW Solution-1"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.2.2 RW Solution-1</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.2.1_RW_Solution-1_Analysis"><div class="tree-item-contents heading-link" heading-name="8.2.2.1 RW Solution-1 Analysis"><span class="tree-item-title">8.2.2.1 RW Solution-1 Analysis</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.3_RW_Solution-2:_Writer's_Gotta_be_Tough"><div class="tree-item-contents heading-link" heading-name="8.2.3 RW Solution-2: Writer's Gotta be Tough"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">8.2.3 RW Solution-2: Writer's Gotta be Tough</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.3.1_RW_Solution-2_Analysis"><div class="tree-item-contents heading-link" heading-name="8.2.3.1 RW Solution-2 Analysis"><span class="tree-item-title">8.2.3.1 RW Solution-2 Analysis</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.4_RW_Solution-3:_Writer_Priority"><div class="tree-item-contents heading-link" heading-name="8.2.4 RW Solution-3: Writer Priority"><span class="tree-item-title">8.2.4 RW Solution-3: Writer Priority</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.2.x_Multi-Readers_and_Writers"><div class="tree-item-contents heading-link" heading-name="8.2.x Multi-Readers and Writers"><span class="tree-item-title">8.2.x Multi-Readers and Writers</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#8.3_RW_Lock_in_POSIX_thread"><div class="tree-item-contents heading-link" heading-name="8.3 RW Lock in POSIX thread"><span class="tree-item-title">8.3 RW Lock in POSIX thread</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#第九课_Condition_Variables,_Monitor_and_Atomic_Types"><div class="tree-item-contents heading-link" heading-name="第九课 Condition Variables, Monitor and Atomic Types"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第九课 Condition Variables, Monitor and Atomic Types</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1_Condition_Variables"><div class="tree-item-contents heading-link" heading-name="9.1 Condition Variables"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.1 Condition Variables</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1_CV_in_POSIX"><div class="tree-item-contents heading-link" heading-name="9.1.1 CV in POSIX"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.1.1 CV in POSIX</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1.1_`pthread_cond_init()`"><div class="tree-item-contents heading-link" heading-name="9.1.1.1 `pthread_cond_init()`"><span class="tree-item-title">9.1.1.1 <code>pthread_cond_init()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1.2_`pthread_cond_wait()`"><div class="tree-item-contents heading-link" heading-name="9.1.1.2 `pthread_cond_wait()`"><span class="tree-item-title">9.1.1.2 <code>pthread_cond_wait()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1.3_`pthread_cond_signal()`"><div class="tree-item-contents heading-link" heading-name="9.1.1.3 `pthread_cond_signal()`"><span class="tree-item-title">9.1.1.3 <code>pthread_cond_signal()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1.4_`pthread_cond_broadcast()`"><div class="tree-item-contents heading-link" heading-name="9.1.1.4 `pthread_cond_broadcast()`"><span class="tree-item-title">9.1.1.4 <code>pthread_cond_broadcast()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.1.5_`pthread_cond_destroy()`"><div class="tree-item-contents heading-link" heading-name="9.1.1.5 `pthread_cond_destroy()`"><span class="tree-item-title">9.1.1.5 <code>pthread_cond_destroy()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.2_Always_Stick_with_Mutex_Locks"><div class="tree-item-contents heading-link" heading-name="9.1.2 Always Stick with Mutex Locks"><span class="tree-item-title">9.1.2 Always Stick with Mutex Locks</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.1.3_Interview_Question:_Can_CV_Be_Integrated_with_Mutexes?"><div class="tree-item-contents heading-link" heading-name="9.1.3 Interview Question: Can CV Be Integrated with Mutexes?"><span class="tree-item-title">9.1.3 Interview Question: Can CV Be Integrated with Mutexes?</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.2_Monitors"><div class="tree-item-contents heading-link" heading-name="9.2 Monitors"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.2 Monitors</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.2.1_封装和抽象"><div class="tree-item-contents heading-link" heading-name="9.2.1 封装和抽象"><span class="tree-item-title">9.2.1 封装和抽象</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.2.2_人工队_vs._机器队"><div class="tree-item-contents heading-link" heading-name="9.2.2 人工队 vs. 机器队"><span class="tree-item-title">9.2.2 人工队 vs. 机器队</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3_Atomic_Types"><div class="tree-item-contents heading-link" heading-name="9.3 Atomic Types"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.3 Atomic Types</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3.1_加锁？枷锁！"><div class="tree-item-contents heading-link" heading-name="9.3.1 加锁？枷锁！"><span class="tree-item-title">9.3.1 加锁？枷锁！</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3.2_Another_Layers_of_Abstraction"><div class="tree-item-contents heading-link" heading-name="9.3.2 Another Layers of Abstraction"><span class="tree-item-title">9.3.2 Another Layers of Abstraction</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3.3_Atomic_Operations"><div class="tree-item-contents heading-link" heading-name="9.3.3 Atomic Operations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9.3.3 Atomic Operations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3.3.1_Atomic_Operations_in_GCC"><div class="tree-item-contents heading-link" heading-name="9.3.3.1 Atomic Operations in GCC"><span class="tree-item-title">9.3.3.1 Atomic Operations in GCC</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\10.-synchronization-and-mutex.html#9.3.3.x_Atomic_Reading"><div class="tree-item-contents heading-link" heading-name="9.3.3.x Atomic Reading"><span class="tree-item-title">9.3.3.x Atomic Reading</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>